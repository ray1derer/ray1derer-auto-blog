<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ì œ26ê°•: AI ê¸°ë°˜ ì„±ëŠ¥ í”„ë¡œíŒŒì¼ë§ê³¼ ìµœì í™” | Cursor AI ë§ˆìŠ¤í„° í´ë˜ìŠ¤</title>
    <link rel="stylesheet" href="../assets/lesson-style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>
<body>
    <div class="lesson-container">
        <header class="lesson-header">
            <div class="lesson-title">
                <h1><i class="fas fa-chart-line"></i> ì œ26ê°•: AI ê¸°ë°˜ ì„±ëŠ¥ í”„ë¡œíŒŒì¼ë§ê³¼ ìµœì í™”</h1>
                <p class="lesson-subtitle">ì§€ëŠ¥í˜• ì„±ëŠ¥ ë¶„ì„ê³¼ ìë™ ìµœì í™” ì‹œìŠ¤í…œ êµ¬ì¶•</p>
            </div>
            <div class="lesson-meta">
                <span class="difficulty"><i class="fas fa-signal"></i> ë‚œì´ë„: ê³ ê¸‰</span>
                <span class="duration"><i class="fas fa-clock"></i> ì˜ˆìƒ ì‹œê°„: 70ë¶„</span>
                <span class="category"><i class="fas fa-folder"></i> ì¹´í…Œê³ ë¦¬: ê³ ê¸‰</span>
            </div>
        </header>

        <nav class="lesson-nav">
            <a href="lesson25.html" class="nav-link prev">
                <i class="fas fa-chevron-left"></i> ì´ì „ ê°•ì˜
            </a>
            <span class="nav-title">ì œ26ê°•: AI ê¸°ë°˜ ì„±ëŠ¥ í”„ë¡œíŒŒì¼ë§ê³¼ ìµœì í™”</span>
            <a href="lesson27.html" class="nav-link next">
                ë‹¤ìŒ ê°•ì˜ <i class="fas fa-chevron-right"></i>
            </a>
        </nav>

        <main class="lesson-content">
            <section class="learning-objectives">
                <h2><i class="fas fa-bullseye"></i> í•™ìŠµ ëª©í‘œ</h2>
                <ul>
                    <li>AIë¥¼ í™œìš©í•œ ì„±ëŠ¥ ë³‘ëª© ì§€ì  ìë™ íƒì§€</li>
                    <li>ì‹¤ì‹œê°„ ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ê³¼ ì˜ˆì¸¡ ë¶„ì„</li>
                    <li>ìë™ ìµœì í™” ì œì•ˆê³¼ ì ìš©</li>
                    <li>ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ì™€ ì„±ëŠ¥ ì €í•˜ íŒ¨í„´ ì¸ì‹</li>
                    <li>í”„ë¡œë•ì…˜ í™˜ê²½ ì„±ëŠ¥ ì§„ë‹¨ ë„êµ¬ ê°œë°œ</li>
                </ul>
            </section>

            <section class="content-section">
                <h2><i class="fas fa-microscope"></i> ì§€ëŠ¥í˜• ì„±ëŠ¥ í”„ë¡œíŒŒì¼ëŸ¬</h2>
                
                <div class="info-box">
                    <p>Cursor AIëŠ” ì• í”Œë¦¬ì¼€ì´ì…˜ì˜ ì„±ëŠ¥ì„ ì‹¤ì‹œê°„ìœ¼ë¡œ ë¶„ì„í•˜ê³ , ì ì¬ì ì¸ ë³‘ëª© ì§€ì ì„ ìë™ìœ¼ë¡œ íƒì§€í•˜ì—¬ ìµœì í™” ë°©ì•ˆì„ ì œì‹œí•©ë‹ˆë‹¤. ë¨¸ì‹ ëŸ¬ë‹ì„ í™œìš©í•´ ì„±ëŠ¥ íŒ¨í„´ì„ í•™ìŠµí•˜ê³  ì˜ˆì¸¡í•©ë‹ˆë‹¤.</p>
                </div>

                <h3>AI ì„±ëŠ¥ ë¶„ì„ ì‹œìŠ¤í…œ</h3>
                <div class="performance-analyzer">
                    <div class="analyzer-implementation">
                        <h4>ì‹¤ì‹œê°„ ì„±ëŠ¥ í”„ë¡œíŒŒì¼ë§ ë„êµ¬</h4>
                        <pre><code>// profiler/AIPerformanceProfiler.ts
import { CursorAI } from '@cursor/api';
import { performance, PerformanceObserver } from 'perf_hooks';
import * as v8 from 'v8';
import * as pprof from 'pprof';

export class AIPerformanceProfiler {
    private cursor: CursorAI;
    private metrics: Map<string, PerformanceMetric[]>;
    private anomalyDetector: AnomalyDetector;
    private optimizer: PerformanceOptimizer;
    private isProfilingActive: boolean = false;

    constructor() {
        this.cursor = new CursorAI();
        this.metrics = new Map();
        this.anomalyDetector = new AnomalyDetector();
        this.optimizer = new PerformanceOptimizer();
        this.setupObservers();
    }

    async startProfiling(config: ProfilingConfig): Promise<void> {
        this.isProfilingActive = true;
        
        // CPU í”„ë¡œíŒŒì¼ë§ ì‹œì‘
        if (config.cpu) {
            await pprof.time.start({
                durationMillis: config.duration || 60000,
                intervalMicros: 1000
            });
        }

        // ë©”ëª¨ë¦¬ í”„ë¡œíŒŒì¼ë§ ì‹œì‘
        if (config.memory) {
            this.startMemoryProfiling();
        }

        // ë„¤íŠ¸ì›Œí¬ í”„ë¡œíŒŒì¼ë§
        if (config.network) {
            this.startNetworkProfiling();
        }

        // ì‹¤ì‹œê°„ ë¶„ì„ ì‹œì‘
        this.startRealtimeAnalysis();
    }

    private setupObservers() {
        // Performance Observer ì„¤ì •
        const obs = new PerformanceObserver((list) => {
            for (const entry of list.getEntries()) {
                this.recordMetric(entry);
                
                // ì‹¤ì‹œê°„ ì´ìƒ íƒì§€
                if (this.anomalyDetector.isAnomaly(entry)) {
                    this.handleAnomaly(entry);
                }
            }
        });

        obs.observe({ 
            entryTypes: ['measure', 'function', 'mark', 'navigation', 'resource'] 
        });

        // V8 ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
        if (v8.setFlagsFromString) {
            v8.setFlagsFromString('--expose-gc');
        }
    }

    private async recordMetric(entry: PerformanceEntry) {
        const metric: PerformanceMetric = {
            name: entry.name,
            type: entry.entryType,
            startTime: entry.startTime,
            duration: entry.duration,
            timestamp: Date.now(),
            metadata: await this.enrichMetadata(entry)
        };

        const key = `${entry.entryType}:${entry.name}`;
        if (!this.metrics.has(key)) {
            this.metrics.set(key, []);
        }
        
        this.metrics.get(key)!.push(metric);

        // ë²„í¼ í¬ê¸° ì œí•œ
        const buffer = this.metrics.get(key)!;
        if (buffer.length > 10000) {
            buffer.shift();
        }
    }

    private async enrichMetadata(entry: PerformanceEntry): Promise<any> {
        const metadata: any = {};

        // ìŠ¤íƒ íŠ¸ë ˆì´ìŠ¤ ìˆ˜ì§‘
        if (entry.duration > 100) { // 100ms ì´ìƒ ì†Œìš”ëœ ì‘ì—…
            metadata.stackTrace = new Error().stack;
        }

        // ë©”ëª¨ë¦¬ ìƒíƒœ
        metadata.memory = process.memoryUsage();

        // CPU ì‚¬ìš©ë¥ 
        metadata.cpuUsage = process.cpuUsage();

        return metadata;
    }

    async analyzePerformance(): Promise<PerformanceReport> {
        const report: PerformanceReport = {
            summary: await this.generateSummary(),
            bottlenecks: await this.identifyBottlenecks(),
            memoryLeaks: await this.detectMemoryLeaks(),
            optimizations: await this.suggestOptimizations(),
            predictions: await this.predictFutureIssues()
        };

        return report;
    }

    private async identifyBottlenecks(): Promise<Bottleneck[]> {
        const bottlenecks: Bottleneck[] = [];
        
        // ê° ë©”íŠ¸ë¦­ ì¹´í…Œê³ ë¦¬ ë¶„ì„
        for (const [key, metrics] of this.metrics) {
            const analysis = await this.analyzeMetricPattern(metrics);
            
            if (analysis.isBottleneck) {
                bottlenecks.push({
                    type: analysis.type,
                    location: analysis.location,
                    impact: analysis.impact,
                    frequency: analysis.frequency,
                    suggestions: await this.generateOptimizationSuggestions(analysis)
                });
            }
        }

        // AIë¡œ ë³µì¡í•œ íŒ¨í„´ ë¶„ì„
        const aiAnalysis = await this.performAIAnalysis();
        bottlenecks.push(...aiAnalysis.bottlenecks);

        return bottlenecks.sort((a, b) => b.impact - a.impact);
    }

    private async performAIAnalysis(): Promise<AIAnalysisResult> {
        const metricsSnapshot = this.exportMetricsForAI();
        
        const prompt = `
ì„±ëŠ¥ ë©”íŠ¸ë¦­ì„ ë¶„ì„í•˜ì—¬ ë³‘ëª© ì§€ì ê³¼ ìµœì í™” ê¸°íšŒë¥¼ ì°¾ì•„ì£¼ì„¸ìš”:

ë©”íŠ¸ë¦­ ë°ì´í„°:
${JSON.stringify(metricsSnapshot, null, 2)}

ë‹¤ìŒì„ ë¶„ì„í•´ì£¼ì„¸ìš”:
1. ë°˜ë³µì ì¸ ì„±ëŠ¥ ì €í•˜ íŒ¨í„´
2. ë¦¬ì†ŒìŠ¤ ì‚¬ìš© ì´ìƒ ì§•í›„
3. ì‘ë‹µ ì‹œê°„ ì¦ê°€ ì¶”ì„¸
4. ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ê°€ëŠ¥ì„±
5. ë¹„íš¨ìœ¨ì ì¸ ì•Œê³ ë¦¬ì¦˜ ì‚¬ìš©

ê° ë¬¸ì œì— ëŒ€í•´:
- ê·¼ë³¸ ì›ì¸
- ì˜í–¥ë„ (1-10)
- êµ¬ì²´ì ì¸ í•´ê²° ë°©ì•ˆ
- ì˜ˆìƒ ì„±ëŠ¥ ê°œì„ ìœ¨
`;

        const response = await this.cursor.ai.generateCode(prompt);
        return JSON.parse(response);
    }

    private async detectMemoryLeaks(): Promise<MemoryLeak[]> {
        const leaks: MemoryLeak[] = [];
        
        // í™ ìŠ¤ëƒ…ìƒ· ë¹„êµ
        const heapSnapshots = await this.collectHeapSnapshots();
        
        for (let i = 1; i < heapSnapshots.length; i++) {
            const diff = await this.compareHeapSnapshots(
                heapSnapshots[i - 1],
                heapSnapshots[i]
            );
            
            // ì§€ì†ì ìœ¼ë¡œ ì¦ê°€í•˜ëŠ” ê°ì²´ íƒì§€
            const growingObjects = diff.filter(obj => 
                obj.retainedSizeDiff > 0 && 
                obj.instanceCountDiff > 0
            );
            
            for (const obj of growingObjects) {
                if (this.isLikelyLeak(obj)) {
                    leaks.push({
                        className: obj.className,
                        retainedSize: obj.retainedSize,
                        instanceCount: obj.instanceCount,
                        growthRate: obj.growthRate,
                        stackTrace: await this.findAllocationStack(obj),
                        severity: this.calculateLeakSeverity(obj),
                        fix: await this.suggestLeakFix(obj)
                    });
                }
            }
        }

        return leaks;
    }

    private async suggestOptimizations(): Promise<Optimization[]> {
        const optimizations: Optimization[] = [];
        
        // 1. í•¨ìˆ˜ ì‹¤í–‰ ì‹œê°„ ìµœì í™”
        const slowFunctions = await this.identifySlowFunctions();
        for (const func of slowFunctions) {
            const optimization = await this.optimizeFunction(func);
            if (optimization) {
                optimizations.push(optimization);
            }
        }

        // 2. ë Œë”ë§ ìµœì í™”
        const renderingIssues = await this.analyzeRendering();
        optimizations.push(...renderingIssues.optimizations);

        // 3. ë„¤íŠ¸ì›Œí¬ ìµœì í™”
        const networkOptimizations = await this.analyzeNetworkPerformance();
        optimizations.push(...networkOptimizations);

        // 4. ë²ˆë“¤ í¬ê¸° ìµœì í™”
        const bundleOptimizations = await this.analyzeBundleSize();
        optimizations.push(...bundleOptimizations);

        return optimizations.sort((a, b) => b.estimatedImprovement - a.estimatedImprovement);
    }

    private async optimizeFunction(func: SlowFunction): Promise<Optimization | null> {
        const code = await this.getFunctionCode(func);
        
        const prompt = `
ë‹¤ìŒ í•¨ìˆ˜ì˜ ì„±ëŠ¥ì„ ìµœì í™”í•´ì£¼ì„¸ìš”:

í•¨ìˆ˜ëª…: ${func.name}
í‰ê·  ì‹¤í–‰ ì‹œê°„: ${func.avgDuration}ms
í˜¸ì¶œ ë¹ˆë„: ${func.callCount}/ë¶„

ì½”ë“œ:
\`\`\`javascript
${code}
\`\`\`

ìµœì í™” ì œì•ˆ:
1. ì•Œê³ ë¦¬ì¦˜ ê°œì„ 
2. ë¶ˆí•„ìš”í•œ ì—°ì‚° ì œê±°
3. ìºì‹± ì ìš©
4. ë¹„ë™ê¸° ì²˜ë¦¬
5. ë©”ëª¨ì´ì œì´ì…˜

ìµœì í™”ëœ ì½”ë“œì™€ ì˜ˆìƒ ê°œì„ ìœ¨ì„ ì œê³µí•´ì£¼ì„¸ìš”.
`;

        const response = await this.cursor.ai.generateCode(prompt);
        const optimization = JSON.parse(response);

        return {
            type: 'function',
            target: func.name,
            currentPerformance: func.avgDuration,
            estimatedImprovement: optimization.improvementPercentage,
            suggestion: optimization.description,
            code: optimization.optimizedCode,
            risk: optimization.risk || 'low'
        };
    }

    private async predictFutureIssues(): Promise<PerformancePrediction[]> {
        const predictions: PerformancePrediction[] = [];
        
        // ì‹œê³„ì—´ ë¶„ì„ìœ¼ë¡œ íŠ¸ë Œë“œ ì˜ˆì¸¡
        for (const [key, metrics] of this.metrics) {
            const trend = this.analyzeTrend(metrics);
            
            if (trend.isWorrying) {
                const prediction = await this.generatePrediction(key, trend);
                predictions.push(prediction);
            }
        }

        // ML ëª¨ë¸ë¡œ ë³µì¡í•œ íŒ¨í„´ ì˜ˆì¸¡
        const mlPredictions = await this.runMLPrediction();
        predictions.push(...mlPredictions);

        return predictions;
    }

    private analyzeTrend(metrics: PerformanceMetric[]): TrendAnalysis {
        if (metrics.length < 10) {
            return { isWorrying: false };
        }

        // ì´ë™ í‰ê·  ê³„ì‚°
        const windowSize = Math.min(10, Math.floor(metrics.length / 3));
        const movingAverages = [];
        
        for (let i = windowSize; i < metrics.length; i++) {
            const window = metrics.slice(i - windowSize, i);
            const avg = window.reduce((sum, m) => sum + m.duration, 0) / windowSize;
            movingAverages.push(avg);
        }

        // íŠ¸ë Œë“œ ê³„ì‚°
        const trend = this.calculateTrendSlope(movingAverages);
        
        return {
            isWorrying: trend.slope > 0.1 && trend.r2 > 0.7,
            slope: trend.slope,
            confidence: trend.r2,
            projection: this.projectFuture(trend, movingAverages)
        };
    }

    async applyOptimization(optimization: Optimization): Promise<ApplyResult> {
        console.log(`ğŸ”§ ìµœì í™” ì ìš© ì¤‘: ${optimization.target}`);
        
        // ë°±ì—… ìƒì„±
        const backup = await this.createBackup(optimization.target);
        
        try {
            // ìµœì í™” ì ìš©
            switch (optimization.type) {
                case 'function':
                    await this.applyFunctionOptimization(optimization);
                    break;
                case 'query':
                    await this.applyQueryOptimization(optimization);
                    break;
                case 'rendering':
                    await this.applyRenderingOptimization(optimization);
                    break;
                case 'caching':
                    await this.applyCachingStrategy(optimization);
                    break;
            }

            // ì„±ëŠ¥ ê²€ì¦
            const validation = await this.validateOptimization(optimization);
            
            if (validation.improved) {
                return {
                    success: true,
                    actualImprovement: validation.improvementPercentage,
                    message: `ì„±ëŠ¥ì´ ${validation.improvementPercentage}% ê°œì„ ë˜ì—ˆìŠµë‹ˆë‹¤.`
                };
            } else {
                // ë¡¤ë°±
                await this.rollback(backup);
                return {
                    success: false,
                    message: 'ì„±ëŠ¥ ê°œì„ ì´ í™•ì¸ë˜ì§€ ì•Šì•„ ë¡¤ë°±í–ˆìŠµë‹ˆë‹¤.'
                };
            }
        } catch (error) {
            await this.rollback(backup);
            throw error;
        }
    }
}

// ì‹¤ì‹œê°„ ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ ëŒ€ì‹œë³´ë“œ
export class PerformanceDashboard {
    private profiler: AIPerformanceProfiler;
    private websocket: WebSocket;
    private charts: Map<string, Chart>;

    constructor() {
        this.profiler = new AIPerformanceProfiler();
        this.charts = new Map();
        this.setupRealtimeUpdates();
    }

    private setupRealtimeUpdates() {
        // ì‹¤ì‹œê°„ ë©”íŠ¸ë¦­ ìŠ¤íŠ¸ë¦¬ë°
        setInterval(async () => {
            const metrics = await this.profiler.getCurrentMetrics();
            this.updateCharts(metrics);
            this.broadcastMetrics(metrics);
        }, 1000);

        // AI ë¶„ì„ ì£¼ê¸°ì  ì‹¤í–‰
        setInterval(async () => {
            const analysis = await this.profiler.analyzePerformance();
            this.updateAnalysis(analysis);
        }, 30000); // 30ì´ˆë§ˆë‹¤
    }

    private updateCharts(metrics: RealtimeMetrics) {
        // CPU ì‚¬ìš©ë¥  ì°¨íŠ¸ ì—…ë°ì´íŠ¸
        this.updateChart('cpu', {
            timestamp: Date.now(),
            value: metrics.cpu.usage,
            threshold: 80
        });

        // ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ì°¨íŠ¸
        this.updateChart('memory', {
            timestamp: Date.now(),
            value: metrics.memory.heapUsed / metrics.memory.heapTotal * 100,
            threshold: 90
        });

        // ì‘ë‹µ ì‹œê°„ ì°¨íŠ¸
        this.updateChart('responseTime', {
            timestamp: Date.now(),
            value: metrics.responseTime.p95,
            threshold: metrics.responseTime.sla
        });

        // ì²˜ë¦¬ëŸ‰ ì°¨íŠ¸
        this.updateChart('throughput', {
            timestamp: Date.now(),
            value: metrics.throughput.requestsPerSecond
        });
    }

    async generatePerformanceReport(): Promise<string> {
        const analysis = await this.profiler.analyzePerformance();
        
        return `
# ì„±ëŠ¥ ë¶„ì„ ë³´ê³ ì„œ

## ìš”ì•½
- ì „ì²´ ì„±ëŠ¥ ì ìˆ˜: ${analysis.summary.overallScore}/100
- ì£¼ìš” ë³‘ëª© ì§€ì : ${analysis.bottlenecks.length}ê°œ
- ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ì˜ì‹¬: ${analysis.memoryLeaks.length}ê°œ
- ìµœì í™” ì œì•ˆ: ${analysis.optimizations.length}ê°œ

## ìƒì„¸ ë¶„ì„

### 1. ë³‘ëª© ì§€ì 
${analysis.bottlenecks.map(b => `
#### ${b.type} - ${b.location}
- ì˜í–¥ë„: ${b.impact}/10
- ë°œìƒ ë¹ˆë„: ${b.frequency}íšŒ/ë¶„
- ê¶Œì¥ ì¡°ì¹˜: ${b.suggestions.join(', ')}
`).join('\n')}

### 2. ë©”ëª¨ë¦¬ ë¶„ì„
${analysis.memoryLeaks.map(leak => `
#### ${leak.className}
- ëˆ„ìˆ˜ í¬ê¸°: ${formatBytes(leak.retainedSize)}
- ì¸ìŠ¤í„´ìŠ¤ ìˆ˜: ${leak.instanceCount}
- ì‹¬ê°ë„: ${leak.severity}
- í•´ê²° ë°©ì•ˆ: ${leak.fix}
`).join('\n')}

### 3. ìµœì í™” ì œì•ˆ
${analysis.optimizations.map(opt => `
#### ${opt.target}
- ì˜ˆìƒ ê°œì„ ìœ¨: ${opt.estimatedImprovement}%
- ìœ„í—˜ë„: ${opt.risk}
- êµ¬í˜„ ë°©ë²•:
\`\`\`javascript
${opt.code}
\`\`\`
`).join('\n')}

### 4. í–¥í›„ ì˜ˆì¸¡
${analysis.predictions.map(pred => `
- ${pred.metric}: ${pred.timeframe}ë‚´ ${pred.prediction}
  - ì‹ ë¢°ë„: ${pred.confidence}%
  - ê¶Œì¥ ì¡°ì¹˜: ${pred.recommendation}
`).join('\n')}
`;
    }
}

// ì„±ëŠ¥ ìµœì í™” ìë™í™”
export class AutoPerformanceOptimizer {
    private profiler: AIPerformanceProfiler;
    private config: OptimizerConfig;
    private optimizationHistory: OptimizationHistory[];

    constructor(config: OptimizerConfig) {
        this.profiler = new AIPerformanceProfiler();
        this.config = config;
        this.optimizationHistory = [];
    }

    async startAutoOptimization(): Promise<void> {
        console.log('ğŸ¤– ìë™ ì„±ëŠ¥ ìµœì í™” ì‹œì‘...');
        
        // ì§€ì†ì ì¸ ëª¨ë‹ˆí„°ë§ ë° ìµœì í™”
        setInterval(async () => {
            await this.optimizationCycle();
        }, this.config.interval || 300000); // 5ë¶„ë§ˆë‹¤
    }

    private async optimizationCycle(): Promise<void> {
        // 1. ì„±ëŠ¥ ë¶„ì„
        const analysis = await this.profiler.analyzePerformance();
        
        // 2. ìµœì í™” ëŒ€ìƒ ì„ ì •
        const targets = this.selectOptimizationTargets(analysis);
        
        // 3. ê° ëŒ€ìƒì— ëŒ€í•´ ìµœì í™” ìˆ˜í–‰
        for (const target of targets) {
            try {
                const result = await this.optimizeTarget(target);
                
                this.optimizationHistory.push({
                    timestamp: new Date(),
                    target: target.name,
                    result,
                    improvement: result.actualImprovement
                });
                
                // ì„±ê³µì ì¸ ìµœì í™” í•™ìŠµ
                if (result.success) {
                    await this.learnFromSuccess(target, result);
                }
            } catch (error) {
                console.error(`ìµœì í™” ì‹¤íŒ¨: ${target.name}`, error);
            }
        }
        
        // 4. ë³´ê³ ì„œ ìƒì„±
        await this.generateOptimizationReport();
    }

    private selectOptimizationTargets(analysis: PerformanceReport): OptimizationTarget[] {
        const targets: OptimizationTarget[] = [];
        
        // ìë™ ìµœì í™” ê°€ëŠ¥í•œ í•­ëª© í•„í„°ë§
        const autoOptimizable = analysis.optimizations.filter(opt => 
            opt.risk === 'low' && 
            opt.estimatedImprovement > this.config.minImprovement
        );
        
        // ìš°ì„ ìˆœìœ„ ì •ë ¬
        return autoOptimizable
            .sort((a, b) => b.estimatedImprovement - a.estimatedImprovement)
            .slice(0, this.config.maxConcurrent || 3)
            .map(opt => ({
                name: opt.target,
                type: opt.type,
                optimization: opt
            }));
    }

    private async optimizeTarget(target: OptimizationTarget): Promise<OptimizationResult> {
        console.log(`ğŸ¯ ìµœì í™” ëŒ€ìƒ: ${target.name}`);
        
        // ì‚¬ì „ ì„±ëŠ¥ ì¸¡ì •
        const beforeMetrics = await this.measurePerformance(target);
        
        // ìµœì í™” ì ìš©
        await this.profiler.applyOptimization(target.optimization);
        
        // ì•ˆì •í™” ëŒ€ê¸°
        await this.waitForStabilization();
        
        // ì‚¬í›„ ì„±ëŠ¥ ì¸¡ì •
        const afterMetrics = await this.measurePerformance(target);
        
        // ê°œì„ ìœ¨ ê³„ì‚°
        const improvement = this.calculateImprovement(beforeMetrics, afterMetrics);
        
        return {
            success: improvement > 0,
            actualImprovement: improvement,
            beforeMetrics,
            afterMetrics
        };
    }

    private async learnFromSuccess(
        target: OptimizationTarget, 
        result: OptimizationResult
    ): Promise<void> {
        // ì„±ê³µì ì¸ ìµœì í™” íŒ¨í„´ í•™ìŠµ
        const pattern = {
            targetType: target.type,
            optimization: target.optimization,
            actualImprovement: result.actualImprovement,
            context: await this.captureContext()
        };
        
        // AI ëª¨ë¸ ì—…ë°ì´íŠ¸
        await this.updateOptimizationModel(pattern);
    }

    private async generateOptimizationReport(): Promise<void> {
        const report = {
            period: {
                from: this.optimizationHistory[0]?.timestamp || new Date(),
                to: new Date()
            },
            totalOptimizations: this.optimizationHistory.length,
            successfulOptimizations: this.optimizationHistory.filter(h => h.result.success).length,
            totalImprovement: this.optimizationHistory.reduce((sum, h) => 
                sum + (h.improvement || 0), 0
            ),
            topOptimizations: this.optimizationHistory
                .sort((a, b) => (b.improvement || 0) - (a.improvement || 0))
                .slice(0, 5)
        };
        
        // ë³´ê³ ì„œ ì €ì¥ ë° ì•Œë¦¼
        await this.saveReport(report);
        await this.notifyStakeholders(report);
    }
}
</code></pre>
                    </div>
                </div>

                <h3>ë©”ëª¨ë¦¬ í”„ë¡œíŒŒì¼ë§ê³¼ ìµœì í™”</h3>
                <div class="memory-profiling">
                    <div class="memory-tools">
                        <h4>ê³ ê¸‰ ë©”ëª¨ë¦¬ ë¶„ì„ ë„êµ¬</h4>
                        <pre><code>// profiler/MemoryProfiler.ts
export class AdvancedMemoryProfiler {
    private heapSnapshots: HeapSnapshot[] = [];
    private retainerGraphs: Map<string, RetainerGraph> = new Map();
    private cursor: CursorAI;

    constructor() {
        this.cursor = new CursorAI();
        this.setupMemoryTracking();
    }

    private setupMemoryTracking() {
        // ê°€ë¹„ì§€ ì»¬ë ‰ì…˜ ì´ë²¤íŠ¸ ì¶”ì 
        if (global.gc) {
            const originalGC = global.gc;
            global.gc = () => {
                const before = process.memoryUsage();
                originalGC();
                const after = process.memoryUsage();
                
                this.recordGCEvent({
                    before,
                    after,
                    freed: before.heapUsed - after.heapUsed,
                    timestamp: Date.now()
                });
            };
        }

        // ì£¼ê¸°ì  ìŠ¤ëƒ…ìƒ·
        setInterval(() => {
            this.takeHeapSnapshot();
        }, 60000); // 1ë¶„ë§ˆë‹¤
    }

    async analyzeMemoryLeaks(): Promise<MemoryLeakReport> {
        if (this.heapSnapshots.length < 2) {
            throw new Error('ìµœì†Œ 2ê°œì˜ í™ ìŠ¤ëƒ…ìƒ·ì´ í•„ìš”í•©ë‹ˆë‹¤.');
        }

        const leaks: DetectedLeak[] = [];
        
        // ìŠ¤ëƒ…ìƒ· ê°„ ë¹„êµ
        for (let i = 1; i < this.heapSnapshots.length; i++) {
            const prev = this.heapSnapshots[i - 1];
            const curr = this.heapSnapshots[i];
            
            const growth = await this.compareSnapshots(prev, curr);
            
            // ì§€ì†ì ìœ¼ë¡œ ì¦ê°€í•˜ëŠ” ê°ì²´ ì°¾ê¸°
            for (const [className, stats] of growth) {
                if (this.isLikelyLeak(stats)) {
                    const leak = await this.analyzeLeakPattern(className, stats);
                    leaks.push(leak);
                }
            }
        }

        // AIë¡œ ë³µì¡í•œ ë©”ëª¨ë¦¬ íŒ¨í„´ ë¶„ì„
        const aiAnalysis = await this.performAIMemoryAnalysis(leaks);
        
        return {
            leaks: leaks.sort((a, b) => b.severity - a.severity),
            recommendations: aiAnalysis.recommendations,
            estimatedImpact: aiAnalysis.estimatedImpact,
            fixStrategies: await this.generateFixStrategies(leaks)
        };
    }

    private async analyzeLeakPattern(
        className: string, 
        stats: MemoryStats
    ): Promise<DetectedLeak> {
        // ê°ì²´ì˜ ë¦¬í…Œì´ë„ˆ ì²´ì¸ ë¶„ì„
        const retainerChain = await this.findRetainerChain(className);
        
        // í• ë‹¹ ìŠ¤íƒ íŠ¸ë ˆì´ìŠ¤ ì°¾ê¸°
        const allocationStack = await this.findAllocationSource(className);
        
        // ëˆ„ìˆ˜ íŒ¨í„´ ë¶„ë¥˜
        const pattern = this.classifyLeakPattern(stats, retainerChain);
        
        return {
            className,
            pattern,
            severity: this.calculateSeverity(stats),
            growthRate: stats.growthRate,
            retainedSize: stats.currentSize,
            retainerChain,
            allocationStack,
            suggestedFix: await this.suggestFix(pattern, retainerChain)
        };
    }

    private async performAIMemoryAnalysis(leaks: DetectedLeak[]): Promise<AIMemoryAnalysis> {
        const prompt = `
ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ íŒ¨í„´ì„ ë¶„ì„í•˜ê³  í•´ê²° ë°©ì•ˆì„ ì œì‹œí•´ì£¼ì„¸ìš”:

ë°œê²¬ëœ ëˆ„ìˆ˜:
${JSON.stringify(leaks.map(l => ({
    className: l.className,
    pattern: l.pattern,
    growthRate: l.growthRate,
    retainerChain: l.retainerChain
})), null, 2)}

ë‹¤ìŒì„ í¬í•¨í•´ì£¼ì„¸ìš”:
1. ëˆ„ìˆ˜ì˜ ê·¼ë³¸ ì›ì¸
2. ì „ì²´ ì‹œìŠ¤í…œì— ë¯¸ì¹˜ëŠ” ì˜í–¥
3. ìš°ì„ ìˆœìœ„ê°€ ë†’ì€ ìˆ˜ì • ì‚¬í•­
4. ì¥ê¸°ì ì¸ ë©”ëª¨ë¦¬ ê´€ë¦¬ ì „ëµ
5. ì˜ˆë°© ë°©ë²•
`;

        const response = await this.cursor.ai.generateCode(prompt);
        return JSON.parse(response);
    }

    private async suggestFix(pattern: LeakPattern, retainerChain: string[]): Promise<MemoryFix> {
        const fixStrategies = {
            'event-listener': {
                description: 'ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì œê±°',
                code: `
// ì»´í¬ë„ŒíŠ¸ ì–¸ë§ˆìš´íŠ¸ ì‹œ ë¦¬ìŠ¤ë„ˆ ì œê±°
componentWillUnmount() {
    this.eventEmitter.removeListener('event', this.handler);
    // ë˜ëŠ”
    this.subscription?.unsubscribe();
}

// React Hook ì‚¬ìš© ì‹œ
useEffect(() => {
    const handler = () => { /* ... */ };
    element.addEventListener('click', handler);
    
    return () => {
        element.removeEventListener('click', handler);
    };
}, []);`
            },
            'closure': {
                description: 'í´ë¡œì € ì°¸ì¡° í•´ì œ',
                code: `
// ë¬¸ì œê°€ ìˆëŠ” ì½”ë“œ
function createHandler(largeData) {
    return function() {
        // largeDataë¥¼ ê³„ì† ì°¸ì¡°
        console.log(largeData.id);
    };
}

// ê°œì„ ëœ ì½”ë“œ
function createHandler(largeData) {
    const id = largeData.id; // í•„ìš”í•œ ë°ì´í„°ë§Œ ì¶”ì¶œ
    return function() {
        console.log(id);
    };
}`
            },
            'dom-reference': {
                description: 'DOM ì°¸ì¡° ì •ë¦¬',
                code: `
// DOM ìš”ì†Œ ì°¸ì¡° í•´ì œ
class Component {
    cleanup() {
        this.domElement = null;
        this.childElements = [];
        this.cache.clear();
    }
}

// WeakMap ì‚¬ìš©ìœ¼ë¡œ ìë™ ì •ë¦¬
const domCache = new WeakMap();
domCache.set(element, data); // elementê°€ GCë˜ë©´ ìë™ ì œê±°`
            },
            'timer': {
                description: 'íƒ€ì´ë¨¸ ì •ë¦¬',
                code: `
class Component {
    timers = new Set();
    
    setTimeout(callback, delay) {
        const timer = window.setTimeout(() => {
            this.timers.delete(timer);
            callback();
        }, delay);
        this.timers.add(timer);
        return timer;
    }
    
    cleanup() {
        this.timers.forEach(timer => clearTimeout(timer));
        this.timers.clear();
    }
}`
            }
        };

        return fixStrategies[pattern] || {
            description: 'ìˆ˜ë™ ë¶„ì„ í•„ìš”',
            code: '// êµ¬ì²´ì ì¸ ì½”ë“œ ì»¨í…ìŠ¤íŠ¸ë¥¼ í™•ì¸í•´ì£¼ì„¸ìš”'
        };
    }

    async optimizeMemoryUsage(): Promise<MemoryOptimizationResult> {
        const currentUsage = process.memoryUsage();
        const optimizations: AppliedOptimization[] = [];

        // 1. í° ê°ì²´ í’€ë§
        const largeObjects = await this.identifyLargeObjects();
        for (const obj of largeObjects) {
            if (obj.canPool) {
                const pooling = await this.implementObjectPooling(obj);
                optimizations.push(pooling);
            }
        }

        // 2. ë¬¸ìì—´ ì¸í„°ë‹
        const duplicateStrings = await this.findDuplicateStrings();
        if (duplicateStrings.saveable > 1024 * 1024) { // 1MB ì´ìƒ
            const interning = await this.implementStringInterning();
            optimizations.push(interning);
        }

        // 3. ì•½í•œ ì°¸ì¡° ì ìš©
        const cacheOptimizations = await this.optimizeCaches();
        optimizations.push(...cacheOptimizations);

        // 4. ë©”ëª¨ë¦¬ ì••ì¶•
        if (currentUsage.external > 100 * 1024 * 1024) { // 100MB ì´ìƒ
            const compression = await this.implementMemoryCompression();
            optimizations.push(compression);
        }

        const afterUsage = process.memoryUsage();
        
        return {
            before: currentUsage,
            after: afterUsage,
            saved: currentUsage.heapUsed - afterUsage.heapUsed,
            optimizations,
            recommendations: await this.generateMemoryRecommendations()
        };
    }

    private async implementObjectPooling(obj: LargeObject): Promise<AppliedOptimization> {
        const poolCode = `
class ${obj.className}Pool {
    private pool: ${obj.className}[] = [];
    private maxSize = ${obj.recommendedPoolSize};
    
    acquire(): ${obj.className} {
        if (this.pool.length > 0) {
            return this.pool.pop()!.reset();
        }
        return new ${obj.className}();
    }
    
    release(obj: ${obj.className}): void {
        if (this.pool.length < this.maxSize) {
            obj.reset();
            this.pool.push(obj);
        }
    }
    
    clear(): void {
        this.pool = [];
    }
}

// ì‚¬ìš© ì˜ˆ
const pool = new ${obj.className}Pool();
const obj = pool.acquire();
try {
    // ê°ì²´ ì‚¬ìš©
} finally {
    pool.release(obj);
}`;

        return {
            type: 'object-pooling',
            target: obj.className,
            code: poolCode,
            estimatedSaving: obj.size * obj.instanceCount * 0.7,
            applied: true
        };
    }
}

// í”„ë¡œë•ì…˜ ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§
export class ProductionPerformanceMonitor {
    private metrics: MetricsCollector;
    private alerts: AlertManager;
    private dashboard: PerformanceDashboard;

    constructor() {
        this.metrics = new MetricsCollector();
        this.alerts = new AlertManager();
        this.dashboard = new PerformanceDashboard();
        this.setupProductionMonitoring();
    }

    private setupProductionMonitoring() {
        // APM (Application Performance Monitoring) ì„¤ì •
        this.setupAPM();
        
        // ì»¤ìŠ¤í…€ ë©”íŠ¸ë¦­ ìˆ˜ì§‘
        this.setupCustomMetrics();
        
        // ì‹¤ì‹œê°„ ì•Œë¦¼ ì„¤ì •
        this.setupAlerts();
        
        // ì„±ëŠ¥ ì´ìƒ ìë™ ëŒ€ì‘
        this.setupAutoResponse();
    }

    private setupAPM() {
        // ë¶„ì‚° íŠ¸ë ˆì´ì‹±
        const tracer = new DistributedTracer({
            serviceName: 'my-app',
            samplingRate: 0.1 // 10% ìƒ˜í”Œë§
        });

        // ëª¨ë“  HTTP ìš”ì²­ ì¶”ì 
        app.use((req, res, next) => {
            const span = tracer.startSpan('http-request', {
                'http.method': req.method,
                'http.url': req.url
            });

            res.on('finish', () => {
                span.setTag('http.status_code', res.statusCode);
                span.finish();
            });

            next();
        });

        // ë°ì´í„°ë² ì´ìŠ¤ ì¿¼ë¦¬ ì¶”ì 
        mongoose.plugin((schema) => {
            schema.pre('find', function() {
                this._startTime = Date.now();
            });

            schema.post('find', function() {
                const duration = Date.now() - this._startTime;
                tracer.recordMetric('db.query.duration', duration, {
                    collection: this.mongooseCollection.name,
                    operation: 'find'
                });
            });
        });
    }

    private setupAlerts() {
        // CPU ì‚¬ìš©ë¥  ì•Œë¦¼
        this.alerts.addRule({
            name: 'high-cpu',
            condition: 'cpu.usage > 80',
            duration: '5m',
            action: async () => {
                await this.notifyOps('ë†’ì€ CPU ì‚¬ìš©ë¥  ê°ì§€');
                await this.triggerAutoScaling();
            }
        });

        // ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ì•Œë¦¼
        this.alerts.addRule({
            name: 'memory-leak',
            condition: 'memory.growth_rate > 10MB/min',
            duration: '10m',
            action: async () => {
                const analysis = await this.analyzeMemoryLeak();
                await this.notifyDev('ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ì˜ì‹¬', analysis);
            }
        });

        // ì‘ë‹µ ì‹œê°„ ì €í•˜ ì•Œë¦¼
        this.alerts.addRule({
            name: 'slow-response',
            condition: 'response_time.p95 > 1000ms',
            duration: '3m',
            action: async () => {
                const bottlenecks = await this.identifyBottlenecks();
                await this.applyEmergencyOptimizations(bottlenecks);
            }
        });
    }

    private async applyEmergencyOptimizations(bottlenecks: Bottleneck[]) {
        for (const bottleneck of bottlenecks) {
            switch (bottleneck.type) {
                case 'database':
                    // ì¿¼ë¦¬ ìºì‹œ í™œì„±í™”
                    await this.enableQueryCache();
                    // ì½ê¸° ì „ìš© ë³µì œë³¸ìœ¼ë¡œ íŠ¸ë˜í”½ ë¶„ì‚°
                    await this.enableReadReplicas();
                    break;
                    
                case 'computation':
                    // ë¬´ê±°ìš´ ì—°ì‚°ì„ ì›Œì»¤ë¡œ ì´ë™
                    await this.offloadToWorkers(bottleneck.target);
                    break;
                    
                case 'memory':
                    // ê¸´ê¸‰ ê°€ë¹„ì§€ ì»¬ë ‰ì…˜
                    if (global.gc) global.gc();
                    // ìºì‹œ í¬ê¸° ì¶•ì†Œ
                    await this.reduceCacheSize();
                    break;
            }
        }
    }
}
</code></pre>
                    </div>
                </div>
            </section>

            <section class="content-section">
                <h2><i class="fas fa-brain"></i> ì˜ˆì¸¡ì  ì„±ëŠ¥ ê´€ë¦¬</h2>
                
                <h3>ML ê¸°ë°˜ ì„±ëŠ¥ ì˜ˆì¸¡ ì‹œìŠ¤í…œ</h3>
                <div class="predictive-performance">
                    <div class="ml-prediction">
                        <h4>ì„±ëŠ¥ ì˜ˆì¸¡ ë° ì‚¬ì „ ëŒ€ì‘</h4>
                        <pre><code>// ml/PerformancePredictor.ts
export class PerformancePredictor {
    private model: TensorFlowModel;
    private historicalData: PerformanceTimeSeries;
    private cursor: CursorAI;

    constructor() {
        this.cursor = new CursorAI();
        this.model = this.loadOrTrainModel();
        this.historicalData = new PerformanceTimeSeries();
    }

    async predictPerformanceIssues(horizon: number = 24): Promise<PredictionResult> {
        const features = await this.extractFeatures();
        const predictions = await this.model.predict(features, horizon);
        
        const issues = this.identifyPotentialIssues(predictions);
        const recommendations = await this.generatePreventiveActions(issues);
        
        return {
            predictions,
            issues,
            recommendations,
            confidence: this.calculateConfidence(predictions)
        };
    }

    private async extractFeatures(): Promise<Features> {
        const now = Date.now();
        const features = {
            // ì‹œê°„ì  íŠ¹ì§•
            hourOfDay: new Date(now).getHours(),
            dayOfWeek: new Date(now).getDay(),
            isWeekend: [0, 6].includes(new Date(now).getDay()),
            
            // ì„±ëŠ¥ ë©”íŠ¸ë¦­
            cpuUsage: await this.getAverageCPU(5), // 5ë¶„ í‰ê· 
            memoryUsage: await this.getAverageMemory(5),
            responseTime: await this.getAverageResponseTime(5),
            errorRate: await this.getErrorRate(5),
            
            // íŠ¸ë˜í”½ íŒ¨í„´
            requestRate: await this.getRequestRate(),
            uniqueUsers: await this.getUniqueUsers(60), // 1ì‹œê°„
            
            // ì‹œìŠ¤í…œ ìƒíƒœ
            dbConnections: await this.getDBConnections(),
            cacheHitRate: await this.getCacheHitRate(),
            
            // ì™¸ë¶€ ìš”ì¸
            deploymentRecent: await this.wasRecentDeployment(60), // 1ì‹œê°„ ë‚´
            maintenanceScheduled: await this.isMaintenanceScheduled(24) // 24ì‹œê°„ ë‚´
        };
        
        return this.normalizeFeatures(features);
    }

    private identifyPotentialIssues(predictions: Predictions): PotentialIssue[] {
        const issues: PotentialIssue[] = [];
        
        // CPU ìŠ¤íŒŒì´í¬ ì˜ˆì¸¡
        const cpuSpikes = predictions.cpu.filter(p => p.value > 85);
        if (cpuSpikes.length > 0) {
            issues.push({
                type: 'cpu-spike',
                severity: 'high',
                timeframe: cpuSpikes[0].timestamp,
                probability: cpuSpikes[0].confidence,
                impact: 'Service degradation expected'
            });
        }
        
        // ë©”ëª¨ë¦¬ ë¶€ì¡± ì˜ˆì¸¡
        const memoryIssues = predictions.memory.filter(p => p.value > 90);
        if (memoryIssues.length > 0) {
            issues.push({
                type: 'memory-exhaustion',
                severity: 'critical',
                timeframe: memoryIssues[0].timestamp,
                probability: memoryIssues[0].confidence,
                impact: 'Out of memory errors likely'
            });
        }
        
        // íŠ¸ë˜í”½ ì„œì§€ ì˜ˆì¸¡
        const trafficSurge = this.detectTrafficAnomaly(predictions.traffic);
        if (trafficSurge) {
            issues.push({
                type: 'traffic-surge',
                severity: 'medium',
                timeframe: trafficSurge.timestamp,
                probability: trafficSurge.confidence,
                impact: 'Increased latency expected'
            });
        }
        
        return issues;
    }

    private async generatePreventiveActions(issues: PotentialIssue[]): Promise<PreventiveAction[]> {
        const actions: PreventiveAction[] = [];
        
        for (const issue of issues) {
            const prompt = `
ì˜ˆì¸¡ëœ ì„±ëŠ¥ ë¬¸ì œì— ëŒ€í•œ ì˜ˆë°© ì¡°ì¹˜ë¥¼ ì œì•ˆí•´ì£¼ì„¸ìš”:

ë¬¸ì œ ìœ í˜•: ${issue.type}
ì‹¬ê°ë„: ${issue.severity}
ì˜ˆìƒ ì‹œê°„: ${new Date(issue.timeframe).toISOString()}
ë°œìƒ í™•ë¥ : ${issue.probability}%
ì˜ˆìƒ ì˜í–¥: ${issue.impact}

í˜„ì¬ ì‹œìŠ¤í…œ ìƒíƒœ:
${JSON.stringify(await this.getCurrentSystemState(), null, 2)}

ë‹¤ìŒì„ í¬í•¨í•œ ì¡°ì¹˜ ê³„íšì„ ì œì‹œí•´ì£¼ì„¸ìš”:
1. ì¦‰ì‹œ ì‹¤í–‰í•  ìë™í™” ì¡°ì¹˜
2. ìˆ˜ë™ ê°œì…ì´ í•„ìš”í•œ ì¡°ì¹˜
3. ì˜ˆë°© íš¨ê³¼ ì¶”ì •ì¹˜
4. ë¶€ì‘ìš© ë° ìœ„í—˜
`;

            const response = await this.cursor.ai.generateCode(prompt);
            const actionPlan = JSON.parse(response);
            
            actions.push({
                issue: issue.type,
                automated: actionPlan.automated,
                manual: actionPlan.manual,
                effectiveness: actionPlan.effectiveness,
                risks: actionPlan.risks,
                priority: this.calculatePriority(issue, actionPlan)
            });
        }
        
        return actions.sort((a, b) => b.priority - a.priority);
    }

    async executePreventiveActions(actions: PreventiveAction[]): Promise<ExecutionResult[]> {
        const results: ExecutionResult[] = [];
        
        for (const action of actions) {
            if (action.automated && action.priority > 7) {
                try {
                    const result = await this.executeAutomatedAction(action);
                    results.push(result);
                    
                    // ì‹¤í–‰ ê²°ê³¼ í•™ìŠµ
                    await this.learnFromExecution(action, result);
                } catch (error) {
                    console.error(`ì˜ˆë°© ì¡°ì¹˜ ì‹¤í–‰ ì‹¤íŒ¨: ${action.issue}`, error);
                    results.push({
                        action: action.issue,
                        success: false,
                        error: error.message
                    });
                }
            }
        }
        
        // ìˆ˜ë™ ì¡°ì¹˜ ì•Œë¦¼
        const manualActions = actions.filter(a => !a.automated || a.priority <= 7);
        if (manualActions.length > 0) {
            await this.notifyOpsTeam(manualActions);
        }
        
        return results;
    }

    private async executeAutomatedAction(action: PreventiveAction): Promise<ExecutionResult> {
        console.log(`ğŸ¤– ìë™ ì˜ˆë°© ì¡°ì¹˜ ì‹¤í–‰: ${action.issue}`);
        
        switch (action.issue) {
            case 'cpu-spike':
                // ìë™ ìŠ¤ì¼€ì¼ë§
                await this.scaleOut(2); // ì¸ìŠ¤í„´ìŠ¤ 2ê°œ ì¶”ê°€
                // ìš”ì²­ ì œí•œ ì„ì‹œ ì ìš©
                await this.enableRateLimiting(1000); // 1000 req/min
                break;
                
            case 'memory-exhaustion':
                // ìºì‹œ ì •ë¦¬
                await this.clearCaches(['session', 'query']);
                // ë©”ëª¨ë¦¬ ì§‘ì•½ì  ì‘ì—… ì¼ì‹œ ì¤‘ì§€
                await this.pauseBackgroundJobs();
                // ê°€ë¹„ì§€ ì»¬ë ‰ì…˜ ê°•ì œ ì‹¤í–‰
                if (global.gc) global.gc();
                break;
                
            case 'traffic-surge':
                // CDN ìºì‹œ ì˜ˆì—´
                await this.warmCDNCache();
                // ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° í’€ í™•ì¥
                await this.expandConnectionPool(50);
                // ì½ê¸° ë³µì œë³¸ í™œì„±í™”
                await this.enableReadReplicas();
                break;
        }
        
        return {
            action: action.issue,
            success: true,
            metrics: await this.measureActionImpact()
        };
    }

    private async trainModel(): Promise<TensorFlowModel> {
        console.log('ğŸ§  ì„±ëŠ¥ ì˜ˆì¸¡ ëª¨ë¸ í•™ìŠµ ì¤‘...');
        
        // ê³¼ê±° ë°ì´í„° ë¡œë“œ
        const trainingData = await this.loadHistoricalData();
        
        // LSTM ëª¨ë¸ êµ¬ì„±
        const model = tf.sequential({
            layers: [
                tf.layers.lstm({
                    units: 128,
                    returnSequences: true,
                    inputShape: [24, 15] // 24ì‹œê°„, 15ê°œ íŠ¹ì§•
                }),
                tf.layers.dropout({ rate: 0.2 }),
                tf.layers.lstm({
                    units: 64,
                    returnSequences: false
                }),
                tf.layers.dense({ units: 32, activation: 'relu' }),
                tf.layers.dense({ units: 4 }) // CPU, Memory, Response Time, Error Rate
            ]
        });
        
        model.compile({
            optimizer: tf.train.adam(0.001),
            loss: 'meanSquaredError',
            metrics: ['mae']
        });
        
        // ëª¨ë¸ í•™ìŠµ
        await model.fit(trainingData.features, trainingData.labels, {
            epochs: 100,
            batchSize: 32,
            validationSplit: 0.2,
            callbacks: {
                onEpochEnd: (epoch, logs) => {
                    console.log(`Epoch ${epoch}: loss = ${logs.loss.toFixed(4)}`);
                }
            }
        });
        
        return model;
    }
}

// ì§€ëŠ¥í˜• ì„±ëŠ¥ ìµœì í™” ì œì•ˆ
export class IntelligentOptimizationSuggester {
    private cursor: CursorAI;
    private codeAnalyzer: CodeAnalyzer;
    private benchmarker: Benchmarker;

    async suggestOptimizations(targetFile: string): Promise<OptimizationSuggestion[]> {
        const code = await fs.readFile(targetFile, 'utf-8');
        const ast = this.codeAnalyzer.parse(code);
        
        const suggestions: OptimizationSuggestion[] = [];
        
        // 1. ì•Œê³ ë¦¬ì¦˜ ìµœì í™”
        const algorithmSuggestions = await this.analyzeAlgorithms(ast);
        suggestions.push(...algorithmSuggestions);
        
        // 2. ë°ì´í„° êµ¬ì¡° ìµœì í™”
        const dataStructureSuggestions = await this.analyzeDataStructures(ast);
        suggestions.push(...dataStructureSuggestions);
        
        // 3. ë¹„ë™ê¸° íŒ¨í„´ ìµœì í™”
        const asyncSuggestions = await this.analyzeAsyncPatterns(ast);
        suggestions.push(...asyncSuggestions);
        
        // 4. ë©”ëª¨ë¦¬ ì‚¬ìš© ìµœì í™”
        const memorySuggestions = await this.analyzeMemoryUsage(ast);
        suggestions.push(...memorySuggestions);
        
        // 5. AI ê¸°ë°˜ ê³ ê¸‰ ìµœì í™”
        const aiSuggestions = await this.getAISuggestions(code, suggestions);
        suggestions.push(...aiSuggestions);
        
        // ê° ì œì•ˆì˜ ì˜í–¥ë„ ì¸¡ì •
        for (const suggestion of suggestions) {
            suggestion.estimatedImprovement = await this.benchmarkSuggestion(
                code,
                suggestion
            );
        }
        
        return suggestions.sort((a, b) => 
            b.estimatedImprovement - a.estimatedImprovement
        );
    }

    private async analyzeAlgorithms(ast: AST): Promise<OptimizationSuggestion[]> {
        const suggestions: OptimizationSuggestion[] = [];
        
        // ì¤‘ì²© ë£¨í”„ ê°ì§€
        ast.traverse({
            ForStatement(path) {
                const nestedLoops = path.findDescendants('ForStatement');
                if (nestedLoops.length > 0) {
                    suggestions.push({
                        type: 'algorithm',
                        location: path.node.loc,
                        issue: 'ì¤‘ì²© ë£¨í”„ ê°ì§€ (O(nÂ²) ì´ìƒì˜ ë³µì¡ë„)',
                        suggestion: 'í•´ì‹œ í…Œì´ë¸”ì´ë‚˜ ë” íš¨ìœ¨ì ì¸ ì•Œê³ ë¦¬ì¦˜ ì‚¬ìš© ê³ ë ¤',
                        code: this.generateOptimizedLoop(path.node)
                    });
                }
            }
        });
        
        return suggestions;
    }

    private async getAISuggestions(
        code: string, 
        existingSuggestions: OptimizationSuggestion[]
    ): Promise<OptimizationSuggestion[]> {
        const prompt = `
ë‹¤ìŒ ì½”ë“œì˜ ì„±ëŠ¥ì„ ìµœì í™”í•  ìˆ˜ ìˆëŠ” ê³ ê¸‰ ë°©ë²•ì„ ì œì•ˆí•´ì£¼ì„¸ìš”:

ì½”ë“œ:
\`\`\`javascript
${code}
\`\`\`

ì´ë¯¸ ë°œê²¬ëœ ìµœì í™” í¬ì¸íŠ¸:
${existingSuggestions.map(s => `- ${s.issue}`).join('\n')}

ë‹¤ìŒ ê´€ì ì—ì„œ ì¶”ê°€ ìµœì í™”ë¥¼ ì°¾ì•„ì£¼ì„¸ìš”:
1. ë³‘ë ¬ ì²˜ë¦¬ ê¸°íšŒ
2. ìºì‹± ì „ëµ
3. ë ˆì´ì§€ ë¡œë”©
4. ë©”ëª¨ì´ì œì´ì…˜
5. ì›¹ ì›Œì»¤ í™œìš©
6. WASM í™œìš© ê°€ëŠ¥ì„±

ê° ìµœì í™”ì— ëŒ€í•´ êµ¬ì²´ì ì¸ êµ¬í˜„ ì½”ë“œë¥¼ ì œê³µí•´ì£¼ì„¸ìš”.
`;

        const response = await this.cursor.ai.generateCode(prompt);
        return JSON.parse(response);
    }

    private async benchmarkSuggestion(
        originalCode: string,
        suggestion: OptimizationSuggestion
    ): Promise<number> {
        // ì›ë³¸ ì½”ë“œ ë²¤ì¹˜ë§ˆí¬
        const originalPerf = await this.benchmarker.run(originalCode);
        
        // ìµœì í™”ëœ ì½”ë“œ ë²¤ì¹˜ë§ˆí¬
        const optimizedCode = this.applyOptimization(originalCode, suggestion);
        const optimizedPerf = await this.benchmarker.run(optimizedCode);
        
        // ê°œì„ ìœ¨ ê³„ì‚°
        const improvement = ((originalPerf.time - optimizedPerf.time) / originalPerf.time) * 100;
        
        return Math.max(0, improvement);
    }
}
</code></pre>
                    </div>
                </div>
            </section>

            <section class="practice-section">
                <h2><i class="fas fa-laptop-code"></i> ì‹¤ìŠµ: ì¢…í•© ì„±ëŠ¥ ìµœì í™” ì‹œìŠ¤í…œ êµ¬ì¶•</h2>
                
                <div class="exercise">
                    <h3>ê³¼ì œ: AI ê¸°ë°˜ ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ ë° ìµœì í™” í”Œë«í¼</h3>
                    <p>ë‹¤ìŒ ìš”êµ¬ì‚¬í•­ì„ ë§Œì¡±í•˜ëŠ” ì„±ëŠ¥ ê´€ë¦¬ ì‹œìŠ¤í…œì„ êµ¬ì¶•í•˜ì„¸ìš”:</p>
                    
                    <div class="requirements">
                        <h4>ìš”êµ¬ì‚¬í•­:</h4>
                        <ul>
                            <li>ì‹¤ì‹œê°„ ì„±ëŠ¥ ë©”íŠ¸ë¦­ ìˆ˜ì§‘ ë° ì‹œê°í™”</li>
                            <li>AI ê¸°ë°˜ ì´ìƒ íƒì§€ ë° ì˜ˆì¸¡</li>
                            <li>ìë™ ì„±ëŠ¥ ìµœì í™” ì‹¤í–‰</li>
                            <li>ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ìë™ íƒì§€ ë° ìˆ˜ì •</li>
                            <li>ì„±ëŠ¥ ì €í•˜ ì˜ˆì¸¡ ë° ì‚¬ì „ ëŒ€ì‘</li>
                            <li>ìƒì„¸í•œ ì„±ëŠ¥ ë³´ê³ ì„œ ìƒì„±</li>
                        </ul>
                    </div>

                    <div class="hints">
                        <h4>íŒíŠ¸:</h4>
                        <ul>
                            <li>Performance Observer API í™œìš©</li>
                            <li>Worker Threadsë¡œ ë¬´ê±°ìš´ ë¶„ì„ ì‘ì—… ë¶„ë¦¬</li>
                            <li>ì‹œê³„ì—´ ë°ì´í„°ë² ì´ìŠ¤ ì‚¬ìš© (InfluxDB ë“±)</li>
                            <li>Grafana ì—°ë™ìœ¼ë¡œ ì‹œê°í™”</li>
                            <li>TensorFlow.jsë¡œ ì˜ˆì¸¡ ëª¨ë¸ êµ¬í˜„</li>
                        </ul>
                    </div>
                </div>
            </section>

            <section class="summary-section">
                <h2><i class="fas fa-bookmark"></i> í•µì‹¬ ìš”ì•½</h2>
                <div class="summary-grid">
                    <div class="summary-item">
                        <h3>ì„±ëŠ¥ í”„ë¡œíŒŒì¼ë§</h3>
                        <ul>
                            <li>ì‹¤ì‹œê°„ ë©”íŠ¸ë¦­ ìˆ˜ì§‘</li>
                            <li>ë³‘ëª© ì§€ì  ìë™ íƒì§€</li>
                            <li>ìƒì„¸ ë¶„ì„ ë¦¬í¬íŠ¸</li>
                        </ul>
                    </div>
                    <div class="summary-item">
                        <h3>ë©”ëª¨ë¦¬ ê´€ë¦¬</h3>
                        <ul>
                            <li>ëˆ„ìˆ˜ íŒ¨í„´ ì¸ì‹</li>
                            <li>í™ ìŠ¤ëƒ…ìƒ· ë¶„ì„</li>
                            <li>ìë™ ìµœì í™”</li>
                        </ul>
                    </div>
                    <div class="summary-item">
                        <h3>ì˜ˆì¸¡ì  ê´€ë¦¬</h3>
                        <ul>
                            <li>ML ê¸°ë°˜ ì˜ˆì¸¡</li>
                            <li>ì‚¬ì „ ëŒ€ì‘ ìë™í™”</li>
                            <li>ë¦¬ìŠ¤í¬ í‰ê°€</li>
                        </ul>
                    </div>
                    <div class="summary-item">
                        <h3>ìµœì í™” ìë™í™”</h3>
                        <ul>
                            <li>ì½”ë“œ ë ˆë²¨ ìµœì í™”</li>
                            <li>ì‹œìŠ¤í…œ ë ˆë²¨ ì¡°ì •</li>
                            <li>ì§€ì†ì  ê°œì„ </li>
                        </ul>
                    </div>
                </div>
            </section>
        </main>

        <aside class="sidebar">
            <div class="progress-indicator">
                <h3>ì§„í–‰ ìƒí™©</h3>
                <div class="progress-bar">
                    <div class="progress-fill" style="width: 86.67%;"></div>
                </div>
                <span>26/30 ê°•ì˜ (86.67%)</span>
            </div>

            <nav class="lesson-nav-sidebar">
                <h3>ì „ì²´ ê°•ì˜</h3>
                <ul>
                    <li><a href="lesson24.html">ì œ24ê°•: ë¬¸ì„œí™” ìë™í™”</a></li>
                    <li><a href="lesson25.html">ì œ25ê°•: ë§ˆì´ê·¸ë ˆì´ì…˜ ë„êµ¬</a></li>
                    <li class="current">ì œ26ê°•: ì„±ëŠ¥ í”„ë¡œíŒŒì¼ë§</li>
                    <li><a href="lesson27.html">ì œ27ê°•: AI ë””ë²„ê¹… ë„êµ¬</a></li>
                    <li><a href="lesson28.html">ì œ28ê°•: í”„ë¡œì íŠ¸ ìë™í™”</a></li>
                </ul>
            </nav>

            <div class="study-tips">
                <h3>í•™ìŠµ íŒ</h3>
                <ul>
                    <li>ì„±ëŠ¥ ìµœì í™”ëŠ” ì¸¡ì •ì—ì„œ ì‹œì‘í•©ë‹ˆë‹¤</li>
                    <li>ì¡°ê¸° ìµœì í™”ë³´ë‹¤ëŠ” ë³‘ëª© ì§€ì  íŒŒì•…ì´ ì¤‘ìš”í•©ë‹ˆë‹¤</li>
                    <li>í”„ë¡œë•ì…˜ í™˜ê²½ì˜ ì‹¤ì œ ë°ì´í„°ë¡œ ë¶„ì„í•˜ì„¸ìš”</li>
                    <li>ì‘ì€ ê°œì„ ì´ ëª¨ì—¬ í° ì„±ê³¼ë¥¼ ë§Œë“­ë‹ˆë‹¤</li>
                </ul>
            </div>
        </aside>
    </div>

    <script src="../assets/lesson-script.js"></script>
</body>
</html>