<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ì œ27ê°•: AI ê¸°ë°˜ ë””ë²„ê¹…ê³¼ ë¬¸ì œ í•´ê²° ë„êµ¬ | Cursor AI ë§ˆìŠ¤í„° í´ë˜ìŠ¤</title>
    <link rel="stylesheet" href="../assets/lesson-style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>
<body>
    <div class="lesson-container">
        <header class="lesson-header">
            <div class="lesson-title">
                <h1><i class="fas fa-bug"></i> ì œ27ê°•: AI ê¸°ë°˜ ë””ë²„ê¹…ê³¼ ë¬¸ì œ í•´ê²° ë„êµ¬</h1>
                <p class="lesson-subtitle">ì§€ëŠ¥í˜• ë””ë²„ê±°ë¡œ ë³µì¡í•œ ë²„ê·¸ë¥¼ ë¹ ë¥´ê²Œ í•´ê²°í•˜ê¸°</p>
            </div>
            <div class="lesson-meta">
                <span class="difficulty"><i class="fas fa-signal"></i> ë‚œì´ë„: ê³ ê¸‰</span>
                <span class="duration"><i class="fas fa-clock"></i> ì˜ˆìƒ ì‹œê°„: 65ë¶„</span>
                <span class="category"><i class="fas fa-folder"></i> ì¹´í…Œê³ ë¦¬: ê³ ê¸‰</span>
            </div>
        </header>

        <nav class="lesson-nav">
            <a href="lesson26.html" class="nav-link prev">
                <i class="fas fa-chevron-left"></i> ì´ì „ ê°•ì˜
            </a>
            <span class="nav-title">ì œ27ê°•: AI ê¸°ë°˜ ë””ë²„ê¹…ê³¼ ë¬¸ì œ í•´ê²° ë„êµ¬</span>
            <a href="lesson28.html" class="nav-link next">
                ë‹¤ìŒ ê°•ì˜ <i class="fas fa-chevron-right"></i>
            </a>
        </nav>

        <main class="lesson-content">
            <section class="learning-objectives">
                <h2><i class="fas fa-bullseye"></i> í•™ìŠµ ëª©í‘œ</h2>
                <ul>
                    <li>AIë¥¼ í™œìš©í•œ ë²„ê·¸ ìë™ íƒì§€ì™€ ì›ì¸ ë¶„ì„</li>
                    <li>ìŠ¤íƒ íŠ¸ë ˆì´ìŠ¤ ë¶„ì„ê³¼ í•´ê²°ì±… ì œì•ˆ</li>
                    <li>ì‹œê°„ ì—¬í–‰ ë””ë²„ê¹…ê³¼ ìƒíƒœ ì¬í˜„</li>
                    <li>ë¶„ì‚° ì‹œìŠ¤í…œ ë””ë²„ê¹… ìë™í™”</li>
                    <li>ì˜ˆì¸¡ì  ë²„ê·¸ íƒì§€ì™€ ì˜ˆë°©</li>
                </ul>
            </section>

            <section class="content-section">
                <h2><i class="fas fa-search"></i> ì§€ëŠ¥í˜• ë²„ê·¸ íƒì§€ ì‹œìŠ¤í…œ</h2>
                
                <div class="info-box">
                    <p>Cursor AIëŠ” ì½”ë“œ ì‹¤í–‰ì„ ì‹¤ì‹œê°„ìœ¼ë¡œ ë¶„ì„í•˜ì—¬ ë²„ê·¸ë¥¼ ìë™ìœ¼ë¡œ íƒì§€í•˜ê³ , ê·¼ë³¸ ì›ì¸ì„ íŒŒì•…í•˜ì—¬ êµ¬ì²´ì ì¸ í•´ê²° ë°©ì•ˆì„ ì œì‹œí•©ë‹ˆë‹¤. ë³µì¡í•œ ë²„ê·¸ë„ AIì˜ íŒ¨í„´ ì¸ì‹ìœ¼ë¡œ ë¹ ë¥´ê²Œ í•´ê²°í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</p>
                </div>

                <h3>AI ë””ë²„ê±° êµ¬í˜„</h3>
                <div class="ai-debugger">
                    <div class="debugger-implementation">
                        <h4>ìŠ¤ë§ˆíŠ¸ ë””ë²„ê¹… ì‹œìŠ¤í…œ</h4>
                        <pre><code>// debugger/AIDebugger.ts
import { CursorAI } from '@cursor/api';
import { SourceMapConsumer } from 'source-map';
import * as inspector from 'inspector';
import { AsyncLocalStorage } from 'async_hooks';

export class AIDebugger {
    private cursor: CursorAI;
    private session: inspector.Session;
    private executionContext: AsyncLocalStorage<ExecutionContext>;
    private breakpoints: Map<string, Breakpoint>;
    private errorPatterns: ErrorPatternDatabase;

    constructor() {
        this.cursor = new CursorAI();
        this.session = new inspector.Session();
        this.session.connect();
        this.executionContext = new AsyncLocalStorage();
        this.breakpoints = new Map();
        this.errorPatterns = new ErrorPatternDatabase();
        this.setupDebugger();
    }

    private setupDebugger() {
        // ì „ì—­ ì—ëŸ¬ í•¸ë“¤ëŸ¬ ì„¤ì •
        process.on('uncaughtException', async (error, origin) => {
            await this.handleError(error, origin);
        });

        process.on('unhandledRejection', async (reason, promise) => {
            await this.handleRejection(reason, promise);
        });

        // ë””ë²„ê±° í”„ë¡œí† ì½œ í™œì„±í™”
        this.session.post('Debugger.enable');
        this.session.post('Runtime.enable');
        this.session.post('Profiler.enable');
        
        // ë¸Œë ˆì´í¬í¬ì¸íŠ¸ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
        this.session.on('Debugger.paused', async (params) => {
            await this.handleBreakpoint(params);
        });
    }

    async analyzeError(error: Error): Promise<ErrorAnalysis> {
        const stackFrames = await this.parseStackTrace(error.stack!);
        const sourceCode = await this.extractRelevantCode(stackFrames);
        const executionHistory = this.getExecutionHistory();

        // AIë¡œ ì—ëŸ¬ ë¶„ì„
        const prompt = `
ë‹¤ìŒ ì—ëŸ¬ë¥¼ ë¶„ì„í•˜ê³  í•´ê²° ë°©ì•ˆì„ ì œì‹œí•´ì£¼ì„¸ìš”:

ì—ëŸ¬ ë©”ì‹œì§€: ${error.message}
ì—ëŸ¬ íƒ€ì…: ${error.name}

ìŠ¤íƒ íŠ¸ë ˆì´ìŠ¤:
${error.stack}

ê´€ë ¨ ì½”ë“œ:
${sourceCode.map(s => `
íŒŒì¼: ${s.file}
ë¼ì¸ ${s.line}:
\`\`\`javascript
${s.code}
\`\`\`
`).join('\n')}

ì‹¤í–‰ ì»¨í…ìŠ¤íŠ¸:
${JSON.stringify(executionHistory, null, 2)}

ë‹¤ìŒì„ í¬í•¨í•´ì£¼ì„¸ìš”:
1. ì—ëŸ¬ì˜ ê·¼ë³¸ ì›ì¸
2. êµ¬ì²´ì ì¸ í•´ê²° ë°©ë²•
3. ì¬ë°œ ë°©ì§€ ë°©ì•ˆ
4. ê´€ë ¨ëœ ë‹¤ë¥¸ ì ì¬ì  ë¬¸ì œ
`;

        const analysis = await this.cursor.ai.generateCode(prompt);
        const parsedAnalysis = JSON.parse(analysis);

        return {
            error: {
                type: error.name,
                message: error.message,
                stack: stackFrames
            },
            rootCause: parsedAnalysis.rootCause,
            solutions: parsedAnalysis.solutions,
            preventiveMeasures: parsedAnalysis.preventiveMeasures,
            relatedIssues: parsedAnalysis.relatedIssues,
            confidence: this.calculateConfidence(parsedAnalysis)
        };
    }

    private async parseStackTrace(stack: string): Promise<StackFrame[]> {
        const frames: StackFrame[] = [];
        const lines = stack.split('\n');
        
        for (const line of lines) {
            const match = line.match(/at\s+(.+?)\s+\((.+?):(\d+):(\d+)\)/);
            if (match) {
                const [, functionName, file, lineStr, columnStr] = match;
                const line = parseInt(lineStr);
                const column = parseInt(columnStr);
                
                // ì†ŒìŠ¤ë§µ ì²˜ë¦¬
                const originalPosition = await this.resolveSourceMap(file, line, column);
                
                frames.push({
                    functionName,
                    file: originalPosition.source || file,
                    line: originalPosition.line || line,
                    column: originalPosition.column || column,
                    source: await this.getSourceCode(originalPosition.source || file, originalPosition.line || line)
                });
            }
        }
        
        return frames;
    }

    async setSmartBreakpoint(condition: string): Promise<void> {
        // AIë¡œ ë¸Œë ˆì´í¬í¬ì¸íŠ¸ ì¡°ê±´ ìƒì„±
        const prompt = `
ë‹¤ìŒ ì¡°ê±´ì— ë§ëŠ” ë¸Œë ˆì´í¬í¬ì¸íŠ¸ ì„¤ì •ì„ ìƒì„±í•´ì£¼ì„¸ìš”:

ì¡°ê±´: ${condition}

ë‹¤ìŒ í˜•ì‹ìœ¼ë¡œ ì œê³µí•´ì£¼ì„¸ìš”:
- íŒŒì¼ íŒ¨í„´
- ë¼ì¸ ë²ˆí˜¸ ë˜ëŠ” í•¨ìˆ˜ëª…
- ì¡°ê±´ì‹ (JavaScript)
- ìˆ˜ì§‘í•  ë°ì´í„°
`;

        const config = await this.cursor.ai.generateCode(prompt);
        const breakpointConfig = JSON.parse(config);

        // ë¸Œë ˆì´í¬í¬ì¸íŠ¸ ì„¤ì •
        const files = await this.findMatchingFiles(breakpointConfig.filePattern);
        
        for (const file of files) {
            const breakpoint = await this.createBreakpoint({
                file,
                line: breakpointConfig.line,
                condition: breakpointConfig.condition,
                dataCollection: breakpointConfig.dataCollection
            });
            
            this.breakpoints.set(breakpoint.id, breakpoint);
        }
    }

    private async handleBreakpoint(params: any): Promise<void> {
        const callFrames = params.callFrames;
        const breakpointId = params.hitBreakpoints[0];
        const breakpoint = this.breakpoints.get(breakpointId);
        
        if (!breakpoint) return;

        // ì‹¤í–‰ ì»¨í…ìŠ¤íŠ¸ ìˆ˜ì§‘
        const context = await this.collectExecutionContext(callFrames);
        
        // AI ë¶„ì„
        const analysis = await this.analyzeBreakpointHit(breakpoint, context);
        
        // ì¡°ê±´ë¶€ ê³„ì† ì‹¤í–‰
        if (analysis.shouldContinue) {
            this.session.post('Debugger.resume');
        } else {
            // ë¬¸ì œ ë°œê²¬ - ìƒì„¸ ë¶„ì„
            await this.performDeepAnalysis(context, analysis);
        }
    }

    async debugAsyncFlow(functionName: string): Promise<AsyncFlowAnalysis> {
        const traces: AsyncTrace[] = [];
        const errors: AsyncError[] = [];
        
        // ë¹„ë™ê¸° í›… ì„¤ì •
        const asyncHook = async_hooks.createHook({
            init(asyncId, type, triggerAsyncId) {
                if (this.shouldTrack(type)) {
                    traces.push({
                        asyncId,
                        type,
                        triggerAsyncId,
                        timestamp: Date.now(),
                        stack: new Error().stack
                    });
                }
            },
            before(asyncId) {
                const trace = traces.find(t => t.asyncId === asyncId);
                if (trace) {
                    trace.executionStart = Date.now();
                }
            },
            after(asyncId) {
                const trace = traces.find(t => t.asyncId === asyncId);
                if (trace) {
                    trace.executionEnd = Date.now();
                    trace.duration = trace.executionEnd - trace.executionStart!;
                }
            },
            destroy(asyncId) {
                const index = traces.findIndex(t => t.asyncId === asyncId);
                if (index !== -1) {
                    traces.splice(index, 1);
                }
            }
        });
        
        asyncHook.enable();
        
        // í•¨ìˆ˜ ì‹¤í–‰ ì¶”ì 
        try {
            await this.executeWithTracking(functionName);
        } catch (error) {
            errors.push({
                error,
                asyncId: async_hooks.executionAsyncId(),
                context: this.executionContext.getStore()
            });
        } finally {
            asyncHook.disable();
        }
        
        // ë¹„ë™ê¸° íë¦„ ë¶„ì„
        return this.analyzeAsyncFlow(traces, errors);
    }

    private async analyzeAsyncFlow(
        traces: AsyncTrace[], 
        errors: AsyncError[]
    ): Promise<AsyncFlowAnalysis> {
        // ë¹„ë™ê¸° ì²´ì¸ ì¬êµ¬ì„±
        const chains = this.reconstructAsyncChains(traces);
        
        // ë³‘ëª© ì§€ì  ì‹ë³„
        const bottlenecks = chains
            .filter(chain => chain.totalDuration > 1000)
            .sort((a, b) => b.totalDuration - a.totalDuration);
        
        // ì—ëŸ¬ ì „íŒŒ ê²½ë¡œ ì¶”ì 
        const errorPaths = errors.map(error => 
            this.traceErrorPropagation(error, traces)
        );
        
        // AI ë¶„ì„
        const prompt = `
ë¹„ë™ê¸° ì‹¤í–‰ íë¦„ì„ ë¶„ì„í•´ì£¼ì„¸ìš”:

ë¹„ë™ê¸° ì²´ì¸:
${JSON.stringify(chains, null, 2)}

ì—ëŸ¬ ë°œìƒ:
${JSON.stringify(errorPaths, null, 2)}

ë‹¤ìŒì„ ë¶„ì„í•´ì£¼ì„¸ìš”:
1. ë¹„íš¨ìœ¨ì ì¸ ë¹„ë™ê¸° íŒ¨í„´
2. ì ì¬ì  ë ˆì´ìŠ¤ ì»¨ë””ì…˜
3. ì—ëŸ¬ ì²˜ë¦¬ ëˆ„ë½
4. ì„±ëŠ¥ ê°œì„  ê¸°íšŒ
`;

        const analysis = await this.cursor.ai.generateCode(prompt);
        
        return {
            chains,
            bottlenecks,
            errors: errorPaths,
            recommendations: JSON.parse(analysis)
        };
    }

    async timeTravel(targetState: string): Promise<TimeTravelResult> {
        // ì‹¤í–‰ íˆìŠ¤í† ë¦¬ì—ì„œ íƒ€ê²Ÿ ìƒíƒœ ì°¾ê¸°
        const snapshot = await this.findStateSnapshot(targetState);
        
        if (!snapshot) {
            throw new Error('í•´ë‹¹ ìƒíƒœë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
        }
        
        // ìƒíƒœ ë³µì›
        await this.restoreState(snapshot);
        
        // ì‹¤í–‰ ê²½ë¡œ ì¬í˜„
        const executionPath = await this.replayExecution(snapshot);
        
        return {
            snapshot,
            executionPath,
            variables: snapshot.variables,
            callStack: snapshot.callStack
        };
    }
}

// ë¶„ì‚° ì‹œìŠ¤í…œ ë””ë²„ê±°
export class DistributedDebugger {
    private debuggers: Map<string, AIDebugger>;
    private correlator: TraceCorrelator;
    private cursor: CursorAI;

    constructor() {
        this.debuggers = new Map();
        this.correlator = new TraceCorrelator();
        this.cursor = new CursorAI();
    }

    async traceDistributedRequest(requestId: string): Promise<DistributedTrace> {
        const traces: ServiceTrace[] = [];
        
        // ëª¨ë“  ì„œë¹„ìŠ¤ì—ì„œ íŠ¸ë ˆì´ìŠ¤ ìˆ˜ì§‘
        for (const [service, debugger] of this.debuggers) {
            const serviceTraces = await debugger.getTracesForRequest(requestId);
            traces.push({
                service,
                traces: serviceTraces,
                logs: await this.getServiceLogs(service, requestId),
                metrics: await this.getServiceMetrics(service, requestId)
            });
        }
        
        // íŠ¸ë ˆì´ìŠ¤ ìƒê´€ê´€ê³„ ë¶„ì„
        const correlation = await this.correlator.correlate(traces);
        
        // ë¶„ì‚° ì‹œìŠ¤í…œ ë¬¸ì œ ì§„ë‹¨
        const diagnosis = await this.diagnoseDistributedIssues(correlation);
        
        return {
            requestId,
            services: traces,
            correlation,
            diagnosis,
            visualization: this.generateTraceVisualization(correlation)
        };
    }

    private async diagnoseDistributedIssues(
        correlation: TraceCorrelation
    ): Promise<DistributedDiagnosis> {
        const issues: DistributedIssue[] = [];
        
        // 1. íƒ€ì„ì•„ì›ƒ ìºìŠ¤ì¼€ì´ë“œ ê²€ì‚¬
        const timeoutCascades = this.detectTimeoutCascades(correlation);
        issues.push(...timeoutCascades);
        
        // 2. ì„œë¹„ìŠ¤ ê°„ ë¶ˆì¼ì¹˜ ê²€ì‚¬
        const inconsistencies = this.detectInconsistencies(correlation);
        issues.push(...inconsistencies);
        
        // 3. ë¶„ì‚° ë°ë“œë½ ê²€ì‚¬
        const deadlocks = await this.detectDistributedDeadlocks(correlation);
        issues.push(...deadlocks);
        
        // AI ì§„ë‹¨
        const prompt = `
ë¶„ì‚° ì‹œìŠ¤í…œ íŠ¸ë ˆì´ìŠ¤ë¥¼ ë¶„ì„í•´ì£¼ì„¸ìš”:

ì„œë¹„ìŠ¤ ìˆ˜: ${correlation.services.length}
ì´ ì‹¤í–‰ ì‹œê°„: ${correlation.totalDuration}ms
ì—ëŸ¬ ë°œìƒ: ${correlation.errors.length}

íŠ¸ë ˆì´ìŠ¤ ë°ì´í„°:
${JSON.stringify(correlation, null, 2)}

ë‹¤ìŒì„ ì§„ë‹¨í•´ì£¼ì„¸ìš”:
1. ê·¼ë³¸ ì›ì¸ ì„œë¹„ìŠ¤
2. ì—ëŸ¬ ì „íŒŒ ê²½ë¡œ
3. ì„±ëŠ¥ ë³‘ëª© ì§€ì 
4. í•´ê²° ìš°ì„ ìˆœìœ„
5. ì¥ê¸°ì  ê°œì„  ë°©ì•ˆ
`;

        const aiDiagnosis = await this.cursor.ai.generateCode(prompt);
        
        return {
            issues,
            rootCause: JSON.parse(aiDiagnosis).rootCause,
            propagationPath: JSON.parse(aiDiagnosis).propagationPath,
            recommendations: JSON.parse(aiDiagnosis).recommendations
        };
    }
}

// ì˜ˆì¸¡ì  ë²„ê·¸ íƒì§€
export class PredictiveBugDetector {
    private cursor: CursorAI;
    private codeAnalyzer: CodeAnalyzer;
    private historicalBugs: BugDatabase;
    private ml: MachineLearningEngine;

    async analyzeFutureRisks(codebase: string): Promise<RiskAnalysis> {
        const risks: PotentialBug[] = [];
        
        // 1. ì •ì  ë¶„ì„ìœ¼ë¡œ ìœ„í—˜ íŒ¨í„´ íƒì§€
        const staticRisks = await this.performStaticAnalysis(codebase);
        risks.push(...staticRisks);
        
        // 2. ê³¼ê±° ë²„ê·¸ íŒ¨í„´ê³¼ ë¹„êµ
        const historicalPatterns = await this.matchHistoricalPatterns(codebase);
        risks.push(...historicalPatterns);
        
        // 3. ML ëª¨ë¸ë¡œ ì ì¬ì  ë²„ê·¸ ì˜ˆì¸¡
        const mlPredictions = await this.ml.predictBugs(codebase);
        risks.push(...mlPredictions);
        
        // 4. AI ì¢…í•© ë¶„ì„
        const aiAnalysis = await this.performAIRiskAnalysis(codebase, risks);
        
        return {
            risks: risks.sort((a, b) => b.probability - a.probability),
            criticalPaths: aiAnalysis.criticalPaths,
            preventiveMeasures: aiAnalysis.preventiveMeasures,
            testSuggestions: await this.generateTestSuggestions(risks)
        };
    }

    private async performStaticAnalysis(codebase: string): Promise<PotentialBug[]> {
        const bugs: PotentialBug[] = [];
        const files = await this.getSourceFiles(codebase);
        
        for (const file of files) {
            const ast = await this.codeAnalyzer.parse(file);
            
            // ìœ„í—˜í•œ íŒ¨í„´ ê²€ì‚¬
            ast.traverse({
                // Null/Undefined ì°¸ì¡° ìœ„í—˜
                MemberExpression(path) {
                    if (!path.node.optional && this.isNullableType(path.node.object)) {
                        bugs.push({
                            type: 'null-reference',
                            file: file.path,
                            line: path.node.loc.start.line,
                            probability: 0.7,
                            impact: 'runtime-error',
                            description: 'Null ë˜ëŠ” undefined ì°¸ì¡° ê°€ëŠ¥ì„±',
                            suggestion: 'Optional chaining (?.) ì‚¬ìš©'
                        });
                    }
                },
                
                // ë¬´í•œ ë£¨í”„ ìœ„í—˜
                WhileStatement(path) {
                    if (!this.hasBreakCondition(path.node)) {
                        bugs.push({
                            type: 'infinite-loop',
                            file: file.path,
                            line: path.node.loc.start.line,
                            probability: 0.8,
                            impact: 'performance',
                            description: 'ë¬´í•œ ë£¨í”„ ê°€ëŠ¥ì„±',
                            suggestion: 'ëª…í™•í•œ ì¢…ë£Œ ì¡°ê±´ ì¶”ê°€'
                        });
                    }
                },
                
                // ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ìœ„í—˜
                CallExpression(path) {
                    if (this.isEventListenerAdd(path.node) && 
                        !this.hasCorrespondingRemove(path)) {
                        bugs.push({
                            type: 'memory-leak',
                            file: file.path,
                            line: path.node.loc.start.line,
                            probability: 0.6,
                            impact: 'memory',
                            description: 'ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë©”ëª¨ë¦¬ ëˆ„ìˆ˜',
                            suggestion: 'removeEventListener ì¶”ê°€'
                        });
                    }
                }
            });
        }
        
        return bugs;
    }

    private async performAIRiskAnalysis(
        codebase: string, 
        risks: PotentialBug[]
    ): Promise<AIRiskAnalysis> {
        const prompt = `
ì½”ë“œë² ì´ìŠ¤ì˜ ì ì¬ì  ìœ„í—˜ì„ ë¶„ì„í•´ì£¼ì„¸ìš”:

ë°œê²¬ëœ ìœ„í—˜ ìš”ì†Œ:
${JSON.stringify(risks.slice(0, 20), null, 2)}

ì „ì²´ í†µê³„:
- ì´ ìœ„í—˜ ìš”ì†Œ: ${risks.length}
- ë†’ìŒ: ${risks.filter(r => r.probability > 0.7).length}
- ì¤‘ê°„: ${risks.filter(r => r.probability >= 0.4 && r.probability <= 0.7).length}
- ë‚®ìŒ: ${risks.filter(r => r.probability < 0.4).length}

ë‹¤ìŒì„ ë¶„ì„í•´ì£¼ì„¸ìš”:
1. ê°€ì¥ ìœ„í—˜í•œ ì½”ë“œ ê²½ë¡œ
2. ì‹œìŠ¤í…œ ì „ì²´ì— ë¯¸ì¹  ì˜í–¥
3. ìš°ì„ ì ìœ¼ë¡œ ìˆ˜ì •í•´ì•¼ í•  í•­ëª©
4. ì˜ˆë°© ì „ëµ
5. í…ŒìŠ¤íŠ¸ ì»¤ë²„ë¦¬ì§€ ê°•í™” ë°©ì•ˆ
`;

        const response = await this.cursor.ai.generateCode(prompt);
        return JSON.parse(response);
    }

    async generateTestSuggestions(risks: PotentialBug[]): Promise<TestSuggestion[]> {
        const suggestions: TestSuggestion[] = [];
        
        // ìœ„í—˜ë³„ í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ ìƒì„±
        for (const risk of risks.slice(0, 10)) { // ìƒìœ„ 10ê°œ
            const prompt = `
ë‹¤ìŒ ì ì¬ì  ë²„ê·¸ë¥¼ ê²€ì¦í•˜ëŠ” í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ë¥¼ ìƒì„±í•´ì£¼ì„¸ìš”:

ë²„ê·¸ ìœ í˜•: ${risk.type}
ìœ„ì¹˜: ${risk.file}:${risk.line}
ì„¤ëª…: ${risk.description}
í™•ë¥ : ${risk.probability}

í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ë¥¼ Jest í˜•ì‹ìœ¼ë¡œ ì‘ì„±í•´ì£¼ì„¸ìš”.
`;

            const testCode = await this.cursor.ai.generateCode(prompt);
            
            suggestions.push({
                risk,
                testCode,
                framework: 'jest',
                priority: risk.probability * this.getImpactScore(risk.impact)
            });
        }
        
        return suggestions.sort((a, b) => b.priority - a.priority);
    }
}

// ì‹¤ì‹œê°„ ë””ë²„ê¹… UI
export class DebuggerUI {
    private debugger: AIDebugger;
    private websocket: WebSocket;
    private visualization: DebugVisualization;

    constructor() {
        this.debugger = new AIDebugger();
        this.visualization = new DebugVisualization();
        this.setupRealtimeDebugging();
    }

    private setupRealtimeDebugging() {
        // WebSocketìœ¼ë¡œ ì‹¤ì‹œê°„ ë””ë²„ê¹… ì •ë³´ ì „ì†¡
        this.websocket.on('connection', (socket) => {
            // ì‹¤ì‹œê°„ ë³€ìˆ˜ ê°ì‹œ
            socket.on('watch', async (expression) => {
                const watcher = await this.debugger.createWatcher(expression);
                watcher.on('change', (value) => {
                    socket.emit('watchUpdate', { expression, value });
                });
            });
            
            // ì¡°ê±´ë¶€ ë¸Œë ˆì´í¬í¬ì¸íŠ¸
            socket.on('conditionalBreak', async (condition) => {
                await this.debugger.setSmartBreakpoint(condition);
            });
            
            // ì‹œê°„ ì—¬í–‰ ë””ë²„ê¹…
            socket.on('timeTravel', async (targetState) => {
                const result = await this.debugger.timeTravel(targetState);
                socket.emit('timeTravelResult', result);
            });
        });
    }

    async visualizeExecutionFlow(functionName: string): Promise<string> {
        const flow = await this.debugger.traceExecutionFlow(functionName);
        
        return `
<div class="execution-flow">
    <h3>ì‹¤í–‰ íë¦„: ${functionName}</h3>
    
    <div class="flow-diagram">
        ${this.visualization.generateFlowDiagram(flow)}
    </div>
    
    <div class="performance-metrics">
        <h4>ì„±ëŠ¥ ë©”íŠ¸ë¦­</h4>
        <ul>
            <li>ì´ ì‹¤í–‰ ì‹œê°„: ${flow.totalDuration}ms</li>
            <li>í•¨ìˆ˜ í˜¸ì¶œ ìˆ˜: ${flow.functionCalls}</li>
            <li>ë©”ëª¨ë¦¬ í• ë‹¹: ${flow.memoryAllocated}MB</li>
        </ul>
    </div>
    
    <div class="bottlenecks">
        <h4>ë³‘ëª© ì§€ì </h4>
        ${flow.bottlenecks.map(b => `
            <div class="bottleneck">
                <span class="location">${b.location}</span>
                <span class="duration">${b.duration}ms</span>
                <span class="percentage">${b.percentage}%</span>
            </div>
        `).join('')}
    </div>
    
    <div class="ai-insights">
        <h4>AI ì¸ì‚¬ì´íŠ¸</h4>
        ${flow.insights.map(insight => `
            <div class="insight ${insight.type}">
                <i class="fas fa-${insight.icon}"></i>
                ${insight.message}
            </div>
        `).join('')}
    </div>
</div>
        `;
    }
}

// ë²„ê·¸ ìë™ ìˆ˜ì •
export class AutoBugFixer {
    private cursor: CursorAI;
    private testRunner: TestRunner;
    private versionControl: VersionControl;

    async attemptAutoFix(bug: DetectedBug): Promise<AutoFixResult> {
        console.log(`ğŸ”§ ìë™ ìˆ˜ì • ì‹œë„: ${bug.type}`);
        
        // 1. ë²„ê·¸ ìœ í˜•ë³„ ìˆ˜ì • ì „ëµ ì„ íƒ
        const strategy = this.selectFixStrategy(bug);
        
        // 2. AIë¡œ ìˆ˜ì • ì½”ë“œ ìƒì„±
        const fixedCode = await this.generateFix(bug, strategy);
        
        // 3. ìˆ˜ì • ì ìš© (ì„ì‹œ)
        const backup = await this.createBackup(bug.file);
        await this.applyFix(bug.file, fixedCode);
        
        // 4. í…ŒìŠ¤íŠ¸ ì‹¤í–‰
        const testResult = await this.testRunner.run();
        
        if (testResult.passed) {
            // 5. ìˆ˜ì • í™•ì •
            await this.versionControl.commit(
                `fix: ${bug.type} in ${bug.file}:${bug.line}`,
                fixedCode
            );
            
            return {
                success: true,
                fixedCode,
                testsPassed: true,
                confidence: 0.9
            };
        } else {
            // ë¡¤ë°±
            await this.restore(backup);
            
            return {
                success: false,
                reason: 'Tests failed after fix',
                testErrors: testResult.errors
            };
        }
    }

    private async generateFix(bug: DetectedBug, strategy: FixStrategy): Promise<string> {
        const context = await this.gatherContext(bug);
        
        const prompt = `
ë‹¤ìŒ ë²„ê·¸ë¥¼ ìˆ˜ì •í•´ì£¼ì„¸ìš”:

ë²„ê·¸ ì •ë³´:
- ìœ í˜•: ${bug.type}
- ìœ„ì¹˜: ${bug.file}:${bug.line}
- ì„¤ëª…: ${bug.description}

ì›ë³¸ ì½”ë“œ:
\`\`\`javascript
${context.originalCode}
\`\`\`

ì»¨í…ìŠ¤íŠ¸:
${JSON.stringify(context.surroundingCode, null, 2)}

ìˆ˜ì • ì „ëµ: ${strategy.approach}

ìš”êµ¬ì‚¬í•­:
1. ë²„ê·¸ë¥¼ ì™„ì „íˆ ìˆ˜ì •
2. ê¸°ì¡´ ê¸°ëŠ¥ì„ ë³´ì¡´
3. ì½”ë“œ ìŠ¤íƒ€ì¼ ìœ ì§€
4. ì„±ëŠ¥ ì €í•˜ ì—†ìŒ
`;

        const fixedCode = await this.cursor.ai.generateCode(prompt);
        return fixedCode;
    }
}
</code></pre>
                    </div>
                </div>

                <h3>ê³ ê¸‰ ë””ë²„ê¹… ê¸°ë²•</h3>
                <div class="advanced-debugging">
                    <div class="debugging-techniques">
                        <h4>ì‹œê°„ ì—¬í–‰ ë””ë²„ê¹…ê³¼ ìƒíƒœ ì¬í˜„</h4>
                        <pre><code>// debugger/TimeTravelDebugger.ts
export class TimeTravelDebugger {
    private stateSnapshots: StateSnapshot[] = [];
    private maxSnapshots: number = 1000;
    private recordingActive: boolean = false;
    private cursor: CursorAI;

    startRecording() {
        this.recordingActive = true;
        this.instrumentCode();
        
        console.log('âºï¸ ì‹œê°„ ì—¬í–‰ ë””ë²„ê¹… ë…¹í™” ì‹œì‘...');
    }

    private instrumentCode() {
        // Proxyë¥¼ ì‚¬ìš©í•œ ìƒíƒœ ë³€ê²½ ê°ì§€
        const handler = {
            set: (target: any, property: string, value: any) => {
                if (this.recordingActive) {
                    this.recordStateChange({
                        timestamp: Date.now(),
                        target,
                        property,
                        oldValue: target[property],
                        newValue: value,
                        stack: new Error().stack
                    });
                }
                target[property] = value;
                return true;
            },
            
            deleteProperty: (target: any, property: string) => {
                if (this.recordingActive) {
                    this.recordStateChange({
                        timestamp: Date.now(),
                        target,
                        property,
                        oldValue: target[property],
                        newValue: undefined,
                        operation: 'delete',
                        stack: new Error().stack
                    });
                }
                delete target[property];
                return true;
            }
        };
        
        // ì „ì—­ ê°ì²´ í”„ë¡ì‹œí™”
        global.window = new Proxy(global.window || {}, handler);
        global.document = new Proxy(global.document || {}, handler);
    }

    private recordStateChange(change: StateChange) {
        const snapshot: StateSnapshot = {
            id: this.generateSnapshotId(),
            timestamp: change.timestamp,
            changes: [change],
            memoryUsage: process.memoryUsage(),
            callStack: this.captureCallStack(),
            asyncContext: this.captureAsyncContext()
        };
        
        this.stateSnapshots.push(snapshot);
        
        // ë©”ëª¨ë¦¬ ê´€ë¦¬
        if (this.stateSnapshots.length > this.maxSnapshots) {
            this.stateSnapshots.shift();
        }
        
        // ì¤‘ìš”í•œ ë³€ê²½ ì‚¬í•­ ë¶„ì„
        if (this.isSignificantChange(change)) {
            this.analyzeStateChange(change);
        }
    }

    async travelTo(timestamp: number): Promise<ApplicationState> {
        const targetSnapshot = this.findNearestSnapshot(timestamp);
        
        if (!targetSnapshot) {
            throw new Error('í•´ë‹¹ ì‹œì ì˜ ìŠ¤ëƒ…ìƒ·ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
        }
        
        // ìƒíƒœ ë³µì›
        const restoredState = await this.restoreState(targetSnapshot);
        
        // ì‹¤í–‰ ì»¨í…ìŠ¤íŠ¸ ì¬í˜„
        await this.recreateExecutionContext(targetSnapshot);
        
        return restoredState;
    }

    async findBugOrigin(errorState: ErrorState): Promise<BugOrigin> {
        // ì—ëŸ¬ ë°œìƒ ì‹œì ì˜ ìŠ¤ëƒ…ìƒ· ì°¾ê¸°
        const errorSnapshot = this.stateSnapshots.find(s => 
            s.timestamp >= errorState.timestamp - 100 &&
            s.timestamp <= errorState.timestamp + 100
        );
        
        if (!errorSnapshot) {
            throw new Error('ì—ëŸ¬ ë°œìƒ ì‹œì ì˜ ìŠ¤ëƒ…ìƒ·ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
        }
        
        // ì—­ë°©í–¥ ì¶”ì 
        let currentIndex = this.stateSnapshots.indexOf(errorSnapshot);
        const suspiciousChanges: StateChange[] = [];
        
        while (currentIndex >= 0) {
            const snapshot = this.stateSnapshots[currentIndex];
            
            // AIë¡œ ì˜ì‹¬ìŠ¤ëŸ¬ìš´ ë³€ê²½ ì‚¬í•­ ë¶„ì„
            const analysis = await this.analyzeSnapshotForBugs(snapshot, errorState);
            
            if (analysis.isSuspicious) {
                suspiciousChanges.push(...snapshot.changes);
                
                if (analysis.isLikelyOrigin) {
                    break;
                }
            }
            
            currentIndex--;
        }
        
        // ê·¼ë³¸ ì›ì¸ ë¶„ì„
        const rootCause = await this.analyzeRootCause(suspiciousChanges, errorState);
        
        return {
            originSnapshot: this.stateSnapshots[currentIndex],
            suspiciousChanges,
            rootCause,
            timeline: this.generateBugTimeline(currentIndex, errorSnapshot)
        };
    }

    private async analyzeSnapshotForBugs(
        snapshot: StateSnapshot, 
        errorState: ErrorState
    ): Promise<SnapshotAnalysis> {
        const prompt = `
ìƒíƒœ ìŠ¤ëƒ…ìƒ·ì„ ë¶„ì„í•˜ì—¬ ë²„ê·¸ì™€ì˜ ì—°ê´€ì„±ì„ íŒë‹¨í•´ì£¼ì„¸ìš”:

ì—ëŸ¬ ì •ë³´:
${JSON.stringify(errorState, null, 2)}

ìŠ¤ëƒ…ìƒ· ì •ë³´:
- ì‹œê°„: ${new Date(snapshot.timestamp).toISOString()}
- ë³€ê²½ ì‚¬í•­: ${JSON.stringify(snapshot.changes, null, 2)}
- ì½œ ìŠ¤íƒ: ${snapshot.callStack.slice(0, 5).join('\n')}

ë‹¤ìŒì„ íŒë‹¨í•´ì£¼ì„¸ìš”:
1. ì´ ë³€ê²½ì´ ì—ëŸ¬ì™€ ê´€ë ¨ìˆì„ ê°€ëŠ¥ì„± (0-1)
2. ë²„ê·¸ì˜ ê·¼ë³¸ ì›ì¸ì¼ ê°€ëŠ¥ì„± (0-1)
3. ì˜ì‹¬ìŠ¤ëŸ¬ìš´ íŒ¨í„´
4. ì¶”ê°€ ì¡°ì‚¬ê°€ í•„ìš”í•œ ë¶€ë¶„
`;

        const analysis = await this.cursor.ai.generateCode(prompt);
        return JSON.parse(analysis);
    }

    async generateReplayScript(startTime: number, endTime: number): Promise<string> {
        const snapshots = this.stateSnapshots.filter(s => 
            s.timestamp >= startTime && s.timestamp <= endTime
        );
        
        const replayScript = `
// ìë™ ìƒì„±ëœ ì¬í˜„ ìŠ¤í¬ë¦½íŠ¸
// ì‹œì‘: ${new Date(startTime).toISOString()}
// ì¢…ë£Œ: ${new Date(endTime).toISOString()}

async function replayExecution() {
    const states = [];
    
${snapshots.map(snapshot => `
    // ${new Date(snapshot.timestamp).toISOString()}
    await delay(${snapshot.timestamp - (snapshots[0]?.timestamp || 0)});
    ${snapshot.changes.map(change => 
        this.generateReplayCommand(change)
    ).join('\n    ')}
    states.push(captureCurrentState());
`).join('\n')}
    
    return states;
}

function delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

function captureCurrentState() {
    return {
        timestamp: Date.now(),
        dom: document.body.innerHTML,
        globals: Object.keys(window),
        memory: performance.memory
    };
}

// ì‹¤í–‰
replayExecution().then(states => {
    console.log('ì¬í˜„ ì™„ë£Œ:', states);
});
`;
        
        return replayScript;
    }
}

// ë¹„ì£¼ì–¼ ë””ë²„ê¹…
export class VisualDebugger {
    private canvas: HTMLCanvasElement;
    private ctx: CanvasRenderingContext2D;
    private debugger: AIDebugger;

    async visualizeDataFlow(functionName: string): Promise<void> {
        const flow = await this.debugger.traceDataFlow(functionName);
        
        // ë°ì´í„° íë¦„ ì‹œê°í™”
        this.clearCanvas();
        
        // ë…¸ë“œ ê·¸ë¦¬ê¸° (ë³€ìˆ˜, í•¨ìˆ˜)
        flow.nodes.forEach(node => {
            this.drawNode(node);
        });
        
        // ì—£ì§€ ê·¸ë¦¬ê¸° (ë°ì´í„° íë¦„)
        flow.edges.forEach(edge => {
            this.drawEdge(edge);
        });
        
        // ì• ë‹ˆë©”ì´ì…˜
        this.animateDataFlow(flow);
    }

    private drawNode(node: DataNode) {
        const { x, y } = node.position;
        const radius = 30;
        
        // ë…¸ë“œ íƒ€ì…ë³„ ìƒ‰ìƒ
        const colors = {
            variable: '#3498db',
            function: '#2ecc71',
            parameter: '#f39c12',
            return: '#e74c3c'
        };
        
        this.ctx.beginPath();
        this.ctx.arc(x, y, radius, 0, 2 * Math.PI);
        this.ctx.fillStyle = colors[node.type] || '#95a5a6';
        this.ctx.fill();
        
        // ë¼ë²¨
        this.ctx.fillStyle = '#fff';
        this.ctx.font = '12px Arial';
        this.ctx.textAlign = 'center';
        this.ctx.textBaseline = 'middle';
        this.ctx.fillText(node.name, x, y);
        
        // ê°’ í‘œì‹œ
        if (node.value !== undefined) {
            this.ctx.font = '10px Arial';
            this.ctx.fillStyle = '#333';
            this.ctx.fillText(String(node.value), x, y + radius + 10);
        }
    }

    private animateDataFlow(flow: DataFlow) {
        let currentStep = 0;
        
        const animate = () => {
            if (currentStep >= flow.steps.length) {
                currentStep = 0;
            }
            
            const step = flow.steps[currentStep];
            
            // í˜„ì¬ ë‹¨ê³„ í•˜ì´ë¼ì´íŠ¸
            this.highlightStep(step);
            
            // ë°ì´í„° ì´ë™ ì• ë‹ˆë©”ì´ì…˜
            if (step.dataTransfer) {
                this.animateDataTransfer(
                    step.dataTransfer.from,
                    step.dataTransfer.to,
                    step.dataTransfer.value
                );
            }
            
            currentStep++;
            
            setTimeout(() => {
                requestAnimationFrame(animate);
            }, 1000);
        };
        
        animate();
    }

    async visualizeMemoryLayout(snapshot: MemorySnapshot): Promise<void> {
        const layout = this.analyzeMemoryLayout(snapshot);
        
        // ë©”ëª¨ë¦¬ ë§µ ê·¸ë¦¬ê¸°
        this.drawMemoryMap(layout);
        
        // ê°ì²´ ì°¸ì¡° ê·¸ë˜í”„
        this.drawReferenceGraph(layout.references);
        
        // ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ íˆíŠ¸ë§µ
        this.drawMemoryHeatmap(layout.usage);
        
        // ê°€ë¹„ì§€ ì»¬ë ‰ì…˜ ì˜ˆìƒ
        this.highlightGCCandidates(layout.gcCandidates);
    }
}

// í˜‘ì—… ë””ë²„ê¹…
export class CollaborativeDebugger {
    private session: DebugSession;
    private participants: Map<string, Participant>;
    private sharedBreakpoints: SharedBreakpoint[];

    async createDebugSession(problem: string): Promise<string> {
        this.session = {
            id: this.generateSessionId(),
            problem,
            created: new Date(),
            participants: [],
            sharedState: {}
        };
        
        // WebRTC ì—°ê²° ì„¤ì •
        await this.setupPeerConnections();
        
        // ê³µìœ  ë””ë²„ê¹… í™˜ê²½ ì´ˆê¸°í™”
        await this.initializeSharedEnvironment();
        
        return this.session.id;
    }

    async shareBreakpoint(breakpoint: Breakpoint, annotation: string) {
        const shared: SharedBreakpoint = {
            ...breakpoint,
            sharedBy: this.currentUser,
            annotation,
            timestamp: Date.now()
        };
        
        this.sharedBreakpoints.push(shared);
        
        // ë‹¤ë¥¸ ì°¸ê°€ìì—ê²Œ ë¸Œë¡œë“œìºìŠ¤íŠ¸
        this.broadcast('breakpoint-shared', shared);
        
        // AI ë„ìš°ë¯¸ í™œì„±í™”
        if (this.session.aiAssistant) {
            const suggestion = await this.getAISuggestion(shared);
            this.broadcast('ai-suggestion', suggestion);
        }
    }

    async collaborativeAnalysis(error: Error): Promise<CollaborativeAnalysis> {
        // ëª¨ë“  ì°¸ê°€ìì˜ ê´€ì  ìˆ˜ì§‘
        const perspectives = await this.collectPerspectives(error);
        
        // AI ì¢…í•© ë¶„ì„
        const synthesis = await this.synthesizeAnalysis(perspectives);
        
        // íˆ¬í‘œë¥¼ í†µí•œ í•´ê²°ì±… ìš°ì„ ìˆœìœ„ ê²°ì •
        const votedSolutions = await this.voteSolutions(synthesis.solutions);
        
        return {
            error,
            perspectives,
            synthesis,
            agreedSolution: votedSolutions[0],
            actionItems: this.assignActionItems(votedSolutions)
        };
    }
}
</code></pre>
                    </div>
                </div>
            </section>

            <section class="content-section">
                <h2><i class="fas fa-magic"></i> ìë™ ë¬¸ì œ í•´ê²°</h2>
                
                <h3>AI ê¸°ë°˜ ìë™ ìˆ˜ì • ì‹œìŠ¤í…œ</h3>
                <div class="auto-fix-system">
                    <div class="auto-fix-implementation">
                        <h4>ìŠ¤ë§ˆíŠ¸ ë²„ê·¸ ìˆ˜ì • ì—”ì§„</h4>
                        <pre><code>// fixer/SmartBugFixer.ts
export class SmartBugFixer {
    private cursor: CursorAI;
    private testSuite: TestSuite;
    private codebase: Codebase;

    async fixBug(bug: Bug): Promise<FixResult> {
        console.log(`ğŸ¤– ë²„ê·¸ ìë™ ìˆ˜ì • ì‹œì‘: ${bug.id}`);
        
        // 1. ë²„ê·¸ ì»¨í…ìŠ¤íŠ¸ ìˆ˜ì§‘
        const context = await this.gatherBugContext(bug);
        
        // 2. ìˆ˜ì • ì „ëµ ê²°ì •
        const strategies = await this.determineFixStrategies(bug, context);
        
        // 3. ê° ì „ëµë³„ë¡œ ìˆ˜ì • ì‹œë„
        for (const strategy of strategies) {
            try {
                const fix = await this.applyStrategy(strategy, bug, context);
                
                // 4. ìˆ˜ì • ê²€ì¦
                const validation = await this.validateFix(fix);
                
                if (validation.success) {
                    // 5. íšŒê·€ í…ŒìŠ¤íŠ¸
                    const regressionTest = await this.runRegressionTests(fix);
                    
                    if (regressionTest.passed) {
                        return {
                            success: true,
                            fix,
                            validation,
                            confidence: this.calculateConfidence(fix, validation)
                        };
                    }
                }
            } catch (error) {
                console.error(`ì „ëµ ${strategy.name} ì‹¤íŒ¨:`, error);
            }
        }
        
        // ìë™ ìˆ˜ì • ì‹¤íŒ¨ ì‹œ ìˆ˜ë™ ìˆ˜ì • ê°€ì´ë“œ ì œê³µ
        return {
            success: false,
            manualFixGuide: await this.generateManualFixGuide(bug, context)
        };
    }

    private async determineFixStrategies(
        bug: Bug, 
        context: BugContext
    ): Promise<FixStrategy[]> {
        const strategies: FixStrategy[] = [];
        
        // 1. íŒ¨í„´ ê¸°ë°˜ ìˆ˜ì •
        if (this.knownPatterns.has(bug.type)) {
            strategies.push({
                name: 'pattern-based',
                apply: async () => this.applyPatternFix(bug, context)
            });
        }
        
        // 2. AI ìƒì„± ìˆ˜ì •
        strategies.push({
            name: 'ai-generated',
            apply: async () => this.generateAIFix(bug, context)
        });
        
        // 3. ìœ ì‚¬ ë²„ê·¸ ì°¸ì¡° ìˆ˜ì •
        const similarBugs = await this.findSimilarBugs(bug);
        if (similarBugs.length > 0) {
            strategies.push({
                name: 'similarity-based',
                apply: async () => this.applySimilarFix(bug, similarBugs[0])
            });
        }
        
        // 4. ì ì§„ì  ìˆ˜ì •
        strategies.push({
            name: 'incremental',
            apply: async () => this.applyIncrementalFix(bug, context)
        });
        
        return strategies;
    }

    private async generateAIFix(bug: Bug, context: BugContext): Promise<Fix> {
        const prompt = `
ë‹¤ìŒ ë²„ê·¸ë¥¼ ìˆ˜ì •í•˜ëŠ” ì½”ë“œë¥¼ ìƒì„±í•´ì£¼ì„¸ìš”:

ë²„ê·¸ ì •ë³´:
- ID: ${bug.id}
- ìœ í˜•: ${bug.type}
- ì„¤ëª…: ${bug.description}
- íŒŒì¼: ${bug.location.file}
- ë¼ì¸: ${bug.location.line}

ì—ëŸ¬ ë©”ì‹œì§€:
${bug.errorMessage}

ìŠ¤íƒ íŠ¸ë ˆì´ìŠ¤:
${bug.stackTrace}

í˜„ì¬ ì½”ë“œ:
\`\`\`${context.language}
${context.buggyCode}
\`\`\`

ì£¼ë³€ ì½”ë“œ:
\`\`\`${context.language}
${context.surroundingCode}
\`\`\`

ê´€ë ¨ í…ŒìŠ¤íŠ¸:
\`\`\`${context.language}
${context.relatedTests}
\`\`\`

ìš”êµ¬ì‚¬í•­:
1. ë²„ê·¸ë¥¼ ì™„ì „íˆ ìˆ˜ì •
2. ê¸°ì¡´ í…ŒìŠ¤íŠ¸ë¥¼ í†µê³¼
3. ìƒˆë¡œìš´ ë²„ê·¸ë¥¼ ë§Œë“¤ì§€ ì•ŠìŒ
4. ì½”ë“œ ìŠ¤íƒ€ì¼ ìœ ì§€
5. ì„±ëŠ¥ ì €í•˜ ì—†ìŒ
`;

        const fixedCode = await this.cursor.ai.generateCode(prompt);
        
        // ìˆ˜ì • ì‚¬í•­ íŒŒì‹±
        const diff = this.generateDiff(context.buggyCode, fixedCode);
        
        return {
            id: this.generateFixId(),
            bugId: bug.id,
            code: fixedCode,
            diff,
            explanation: await this.explainFix(bug, fixedCode),
            confidence: 0.85
        };
    }

    private async validateFix(fix: Fix): Promise<ValidationResult> {
        const validation: ValidationResult = {
            success: true,
            tests: [],
            issues: []
        };
        
        // 1. ë¬¸ë²• ê²€ì‚¬
        const syntaxCheck = await this.checkSyntax(fix.code);
        if (!syntaxCheck.valid) {
            validation.success = false;
            validation.issues.push({
                type: 'syntax',
                message: syntaxCheck.error
            });
            return validation;
        }
        
        // 2. íƒ€ì… ê²€ì‚¬
        const typeCheck = await this.checkTypes(fix.code);
        if (!typeCheck.valid) {
            validation.issues.push({
                type: 'type',
                message: typeCheck.error,
                severity: 'warning'
            });
        }
        
        // 3. ë‹¨ìœ„ í…ŒìŠ¤íŠ¸
        const unitTests = await this.runUnitTests(fix);
        validation.tests.push(...unitTests);
        
        if (unitTests.some(t => !t.passed)) {
            validation.success = false;
        }
        
        // 4. í†µí•© í…ŒìŠ¤íŠ¸
        const integrationTests = await this.runIntegrationTests(fix);
        validation.tests.push(...integrationTests);
        
        // 5. ì„±ëŠ¥ ê²€ì¦
        const perfCheck = await this.checkPerformance(fix);
        if (perfCheck.degraded) {
            validation.issues.push({
                type: 'performance',
                message: `ì„±ëŠ¥ì´ ${perfCheck.degradation}% ì €í•˜ë˜ì—ˆìŠµë‹ˆë‹¤.`,
                severity: 'warning'
            });
        }
        
        return validation;
    }

    async generateFixReport(bug: Bug, fix: Fix): Promise<string> {
        const validation = fix.validation;
        const confidence = fix.confidence;
        
        return `
# ë²„ê·¸ ìˆ˜ì • ë³´ê³ ì„œ

## ë²„ê·¸ ì •ë³´
- **ID**: ${bug.id}
- **ìœ í˜•**: ${bug.type}
- **ì‹¬ê°ë„**: ${bug.severity}
- **ìœ„ì¹˜**: ${bug.location.file}:${bug.location.line}

## ìˆ˜ì • ë‚´ìš©
### ë³€ê²½ ì‚¬í•­
\`\`\`diff
${fix.diff}
\`\`\`

### ì„¤ëª…
${fix.explanation}

## ê²€ì¦ ê²°ê³¼
- **ì‹ ë¢°ë„**: ${(confidence * 100).toFixed(1)}%
- **í…ŒìŠ¤íŠ¸ í†µê³¼**: ${validation.tests.filter(t => t.passed).length}/${validation.tests.length}
- **ì„±ëŠ¥ ì˜í–¥**: ${validation.performanceImpact || 'ì—†ìŒ'}

## ì ìš© ë°©ë²•
1. ë³€ê²½ ì‚¬í•­ ê²€í† 
2. ë¡œì»¬ì—ì„œ í…ŒìŠ¤íŠ¸ ì‹¤í–‰
3. ì½”ë“œ ë¦¬ë·° ìš”ì²­
4. ë°°í¬

## ì£¼ì˜ ì‚¬í•­
${fix.warnings?.map(w => `- ${w}`).join('\n') || 'ì—†ìŒ'}
`;
    }
}

// ì˜ˆë°©ì  ë²„ê·¸ íƒì§€
export class PreventiveBugDetection {
    private analyzer: CodeAnalyzer;
    private ml: MLModel;
    private cursor: CursorAI;

    async scanForPotentialBugs(codebase: string): Promise<PotentialBugReport> {
        const potentialBugs: PotentialBug[] = [];
        
        // 1. ì •ì  ë¶„ì„
        const staticIssues = await this.performStaticAnalysis(codebase);
        potentialBugs.push(...staticIssues);
        
        // 2. íŒ¨í„´ ë§¤ì¹­
        const patternIssues = await this.detectDangerousPatterns(codebase);
        potentialBugs.push(...patternIssues);
        
        // 3. ML ì˜ˆì¸¡
        const mlPredictions = await this.predictBugsWithML(codebase);
        potentialBugs.push(...mlPredictions);
        
        // 4. AI ì¢…í•© ë¶„ì„
        const aiInsights = await this.getAIInsights(codebase, potentialBugs);
        
        return {
            potentialBugs: potentialBugs.sort((a, b) => b.risk - a.risk),
            summary: this.generateSummary(potentialBugs),
            recommendations: aiInsights.recommendations,
            preventiveMeasures: await this.suggestPreventiveMeasures(potentialBugs)
        };
    }

    private async detectDangerousPatterns(codebase: string): Promise<PotentialBug[]> {
        const patterns = [
            {
                name: 'race-condition',
                regex: /setState\s*\(\s*{\s*\.\.\.this\.state/g,
                risk: 0.8,
                description: 'setStateì—ì„œ this.state ì§ì ‘ ì°¸ì¡° (React)',
                fix: 'setStateì˜ í•¨ìˆ˜í˜• ì—…ë°ì´íŠ¸ ì‚¬ìš©'
            },
            {
                name: 'memory-leak-timer',
                regex: /setInterval|setTimeout(?!.*clear)/g,
                risk: 0.6,
                description: 'í´ë¦¬ì–´ë˜ì§€ ì•ŠëŠ” íƒ€ì´ë¨¸',
                fix: 'componentWillUnmountë‚˜ cleanupì—ì„œ íƒ€ì´ë¨¸ ì •ë¦¬'
            },
            {
                name: 'sql-injection',
                regex: /query\s*\(\s*['"`].*\$\{.*\}.*['"`]/g,
                risk: 0.9,
                description: 'SQL ì¸ì ì…˜ ì·¨ì•½ì ',
                fix: 'Prepared statements ì‚¬ìš©'
            },
            {
                name: 'undefined-check',
                regex: /if\s*\(\s*\w+\s*=\s*undefined\s*\)/g,
                risk: 0.7,
                description: 'ì˜ëª»ëœ undefined ì²´í¬',
                fix: '=== ì‚¬ìš©'
            }
        ];
        
        const issues: PotentialBug[] = [];
        const files = await this.getSourceFiles(codebase);
        
        for (const file of files) {
            const content = await fs.readFile(file, 'utf-8');
            
            for (const pattern of patterns) {
                const matches = content.matchAll(pattern.regex);
                
                for (const match of matches) {
                    const line = content.substring(0, match.index).split('\n').length;
                    
                    issues.push({
                        type: pattern.name,
                        file,
                        line,
                        risk: pattern.risk,
                        description: pattern.description,
                        suggestedFix: pattern.fix,
                        codeSnippet: this.extractSnippet(content, line)
                    });
                }
            }
        }
        
        return issues;
    }

    private async getAIInsights(
        codebase: string, 
        potentialBugs: PotentialBug[]
    ): Promise<AIInsights> {
        const prompt = `
ì½”ë“œë² ì´ìŠ¤ì˜ ì ì¬ì  ë²„ê·¸ë¥¼ ë¶„ì„í•˜ê³  ì¸ì‚¬ì´íŠ¸ë¥¼ ì œê³µí•´ì£¼ì„¸ìš”:

ë°œê²¬ëœ ì ì¬ì  ë²„ê·¸ ìš”ì•½:
${this.summarizeBugs(potentialBugs)}

ì½”ë“œë² ì´ìŠ¤ í†µê³„:
- ì´ íŒŒì¼ ìˆ˜: ${await this.countFiles(codebase)}
- ì´ ë¼ì¸ ìˆ˜: ${await this.countLines(codebase)}
- ì£¼ìš” ì–¸ì–´: ${await this.detectLanguages(codebase)}

ë‹¤ìŒì„ ë¶„ì„í•´ì£¼ì„¸ìš”:
1. ê°€ì¥ ìœ„í—˜í•œ íŒ¨í„´
2. ì‹œìŠ¤í…œ ì „ì²´ì ì¸ ì·¨ì•½ì 
3. ì•„í‚¤í…ì²˜ ê°œì„  ì œì•ˆ
4. ì½”ë“œ í’ˆì§ˆ í–¥ìƒ ë°©ì•ˆ
5. ì¥ê¸°ì  ê¸°ìˆ  ë¶€ì±„ ê´€ë¦¬
`;

        const response = await this.cursor.ai.generateCode(prompt);
        return JSON.parse(response);
    }

    async suggestPreventiveMeasures(
        potentialBugs: PotentialBug[]
    ): Promise<PreventiveMeasure[]> {
        const measures: PreventiveMeasure[] = [];
        
        // ë²„ê·¸ ìœ í˜•ë³„ ê·¸ë£¹í™”
        const bugsByType = this.groupBugsByType(potentialBugs);
        
        for (const [type, bugs] of bugsByType) {
            const measure = await this.generatePreventiveMeasure(type, bugs);
            measures.push(measure);
        }
        
        // ì „ì²´ì ì¸ ì˜ˆë°© ì¡°ì¹˜
        measures.push({
            type: 'general',
            title: 'ì½”ë“œ ë¦¬ë·° í”„ë¡œì„¸ìŠ¤ ê°•í™”',
            description: 'AI ê¸°ë°˜ ìë™ ì½”ë“œ ë¦¬ë·° ë„ì…',
            implementation: `
// .github/workflows/ai-review.yml
name: AI Code Review
on: [pull_request]
jobs:
  review:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: AI Review
        run: |
          npx @cursor/cli review \\
            --strict \\
            --check-patterns \\
            --suggest-fixes
`,
            estimatedImpact: 'high',
            effort: 'low'
        });
        
        return measures.sort((a, b) => {
            const impactScore = { high: 3, medium: 2, low: 1 };
            const effortScore = { low: 3, medium: 2, high: 1 };
            
            return (impactScore[b.estimatedImpact] * effortScore[b.effort]) -
                   (impactScore[a.estimatedImpact] * effortScore[a.effort]);
        });
    }
}
</code></pre>
                    </div>
                </div>
            </section>

            <section class="practice-section">
                <h2><i class="fas fa-laptop-code"></i> ì‹¤ìŠµ: AI ë””ë²„ê¹… ë„êµ¬ êµ¬ì¶•</h2>
                
                <div class="exercise">
                    <h3>ê³¼ì œ: ì§€ëŠ¥í˜• ë””ë²„ê¹… í”Œë«í¼ ê°œë°œ</h3>
                    <p>ë‹¤ìŒ ìš”êµ¬ì‚¬í•­ì„ ë§Œì¡±í•˜ëŠ” AI ê¸°ë°˜ ë””ë²„ê¹… ì‹œìŠ¤í…œì„ êµ¬ì¶•í•˜ì„¸ìš”:</p>
                    
                    <div class="requirements">
                        <h4>ìš”êµ¬ì‚¬í•­:</h4>
                        <ul>
                            <li>ì‹¤ì‹œê°„ ë²„ê·¸ íƒì§€ì™€ ì•Œë¦¼</li>
                            <li>ìë™ ê·¼ë³¸ ì›ì¸ ë¶„ì„</li>
                            <li>ì‹œê°„ ì—¬í–‰ ë””ë²„ê¹… ê¸°ëŠ¥</li>
                            <li>AI ê¸°ë°˜ ìˆ˜ì • ì œì•ˆ</li>
                            <li>í˜‘ì—… ë””ë²„ê¹… ì„¸ì…˜</li>
                            <li>ë²„ê·¸ ì˜ˆë°© ë¦¬í¬íŠ¸ ìƒì„±</li>
                        </ul>
                    </div>

                    <div class="hints">
                        <h4>íŒíŠ¸:</h4>
                        <ul>
                            <li>Chrome DevTools Protocol í™œìš©</li>
                            <li>Source Mapìœ¼ë¡œ ì›ë³¸ ì½”ë“œ ì¶”ì </li>
                            <li>WebSocketìœ¼ë¡œ ì‹¤ì‹œê°„ í˜‘ì—…</li>
                            <li>Proxyë¡œ ìƒíƒœ ë³€ê²½ ê°ì§€</li>
                            <li>AST ë¶„ì„ìœ¼ë¡œ íŒ¨í„´ íƒì§€</li>
                        </ul>
                    </div>
                </div>
            </section>

            <section class="summary-section">
                <h2><i class="fas fa-bookmark"></i> í•µì‹¬ ìš”ì•½</h2>
                <div class="summary-grid">
                    <div class="summary-item">
                        <h3>ë²„ê·¸ íƒì§€</h3>
                        <ul>
                            <li>ì‹¤ì‹œê°„ ì—ëŸ¬ ë¶„ì„</li>
                            <li>íŒ¨í„´ ê¸°ë°˜ íƒì§€</li>
                            <li>ì˜ˆì¸¡ì  ë²„ê·¸ ë°œê²¬</li>
                        </ul>
                    </div>
                    <div class="summary-item">
                        <h3>ì›ì¸ ë¶„ì„</h3>
                        <ul>
                            <li>ìŠ¤íƒ íŠ¸ë ˆì´ìŠ¤ ë¶„ì„</li>
                            <li>ì‹¤í–‰ ì»¨í…ìŠ¤íŠ¸ ì¶”ì </li>
                            <li>AI ê·¼ë³¸ ì›ì¸ ì§„ë‹¨</li>
                        </ul>
                    </div>
                    <div class="summary-item">
                        <h3>ë””ë²„ê¹… ê¸°ë²•</h3>
                        <ul>
                            <li>ì‹œê°„ ì—¬í–‰ ë””ë²„ê¹…</li>
                            <li>ë¹„ì£¼ì–¼ ë””ë²„ê¹…</li>
                            <li>ë¶„ì‚° ì‹œìŠ¤í…œ ì¶”ì </li>
                        </ul>
                    </div>
                    <div class="summary-item">
                        <h3>ìë™ ìˆ˜ì •</h3>
                        <ul>
                            <li>AI ì½”ë“œ ìƒì„±</li>
                            <li>ìë™ ê²€ì¦</li>
                            <li>ì•ˆì „í•œ ì ìš©</li>
                        </ul>
                    </div>
                </div>
            </section>
        </main>

        <aside class="sidebar">
            <div class="progress-indicator">
                <h3>ì§„í–‰ ìƒí™©</h3>
                <div class="progress-bar">
                    <div class="progress-fill" style="width: 90%;"></div>
                </div>
                <span>27/30 ê°•ì˜ (90%)</span>
            </div>

            <nav class="lesson-nav-sidebar">
                <h3>ì „ì²´ ê°•ì˜</h3>
                <ul>
                    <li><a href="lesson25.html">ì œ25ê°•: ë§ˆì´ê·¸ë ˆì´ì…˜ ë„êµ¬</a></li>
                    <li><a href="lesson26.html">ì œ26ê°•: ì„±ëŠ¥ í”„ë¡œíŒŒì¼ë§</a></li>
                    <li class="current">ì œ27ê°•: AI ë””ë²„ê¹… ë„êµ¬</li>
                    <li><a href="lesson28.html">ì œ28ê°•: í”„ë¡œì íŠ¸ ìë™í™”</a></li>
                    <li><a href="lesson29.html">ì œ29ê°•: AI ê°œë°œ ìƒíƒœê³„</a></li>
                </ul>
            </nav>

            <div class="study-tips">
                <h3>í•™ìŠµ íŒ</h3>
                <ul>
                    <li>ë””ë²„ê¹…ì€ ì²´ê³„ì ì¸ ì ‘ê·¼ì´ ì¤‘ìš”í•©ë‹ˆë‹¤</li>
                    <li>ë¡œê·¸ì™€ ë¸Œë ˆì´í¬í¬ì¸íŠ¸ë¥¼ ì ê·¹ í™œìš©í•˜ì„¸ìš”</li>
                    <li>ë¬¸ì œë¥¼ ì¬í˜„í•  ìˆ˜ ìˆì–´ì•¼ í•´ê²°í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤</li>
                    <li>ê·¼ë³¸ ì›ì¸ì„ ì°¾ëŠ” ê²ƒì´ ì¤‘ìš”í•©ë‹ˆë‹¤</li>
                </ul>
            </div>
        </aside>
    </div>

    <script src="../assets/lesson-script.js"></script>
</body>
</html>