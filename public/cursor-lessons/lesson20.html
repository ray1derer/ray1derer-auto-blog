<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ì œ20ê°•: ëŒ€ê·œëª¨ í”„ë¡œì íŠ¸ ì•„í‚¤í…ì²˜ | Cursor AI ë§ˆìŠ¤í„° í´ë˜ìŠ¤</title>
    <link rel="stylesheet" href="../assets/lesson-style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>
<body>
    <div class="lesson-container">
        <header class="lesson-header">
            <div class="lesson-title">
                <h1><i class="fas fa-building"></i> ì œ20ê°•: ëŒ€ê·œëª¨ í”„ë¡œì íŠ¸ ì•„í‚¤í…ì²˜</h1>
                <p class="lesson-subtitle">AIì™€ í•¨ê»˜ ì„¤ê³„í•˜ëŠ” í™•ì¥ ê°€ëŠ¥í•œ ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜</p>
            </div>
            <div class="lesson-meta">
                <span class="difficulty"><i class="fas fa-signal"></i> ë‚œì´ë„: ì¤‘ê¸‰</span>
                <span class="duration"><i class="fas fa-clock"></i> ì˜ˆìƒ ì‹œê°„: 65ë¶„</span>
                <span class="category"><i class="fas fa-folder"></i> ì¹´í…Œê³ ë¦¬: ì¤‘ê¸‰</span>
            </div>
        </header>

        <nav class="lesson-nav">
            <a href="lesson19.html" class="nav-link prev">
                <i class="fas fa-chevron-left"></i> ì´ì „ ê°•ì˜
            </a>
            <span class="nav-title">ì œ20ê°•: ëŒ€ê·œëª¨ í”„ë¡œì íŠ¸ ì•„í‚¤í…ì²˜</span>
            <a href="lesson21.html" class="nav-link next">
                ë‹¤ìŒ ê°•ì˜ <i class="fas fa-chevron-right"></i>
            </a>
        </nav>

        <main class="lesson-content">
            <section class="learning-objectives">
                <h2><i class="fas fa-bullseye"></i> í•™ìŠµ ëª©í‘œ</h2>
                <ul>
                    <li>AIë¥¼ í™œìš©í•œ ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜ ì„¤ê³„ ì›ì¹™ ì´í•´í•˜ê¸°</li>
                    <li>ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤ vs ëª¨ë†€ë¦¬ìŠ¤ ì„ íƒê³¼ ì „í™˜ ì „ëµ</li>
                    <li>ì´ë²¤íŠ¸ ì£¼ë„ ì•„í‚¤í…ì²˜ì™€ CQRS íŒ¨í„´ êµ¬í˜„í•˜ê¸°</li>
                    <li>ë„ë©”ì¸ ì£¼ë„ ì„¤ê³„(DDD)ì™€ í—¥ì‚¬ê³ ë‚  ì•„í‚¤í…ì²˜ ì ìš©í•˜ê¸°</li>
                    <li>ë¶„ì‚° ì‹œìŠ¤í…œì˜ ë³µì¡ì„± ê´€ë¦¬ì™€ ëª¨ë‹ˆí„°ë§ êµ¬ì¶•í•˜ê¸°</li>
                </ul>
            </section>

            <section class="content-section">
                <h2><i class="fas fa-project-diagram"></i> ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜ ì„¤ê³„</h2>
                
                <div class="info-box">
                    <p>Cursor AIëŠ” í”„ë¡œì íŠ¸ì˜ ìš”êµ¬ì‚¬í•­ì„ ë¶„ì„í•˜ì—¬ ìµœì ì˜ ì•„í‚¤í…ì²˜ë¥¼ ì œì•ˆí•©ë‹ˆë‹¤. í™•ì¥ì„±, ìœ ì§€ë³´ìˆ˜ì„±, ì„±ëŠ¥ì„ ëª¨ë‘ ê³ ë ¤í•œ ì„¤ê³„ë¥¼ ìë™ìœ¼ë¡œ ìƒì„±í•©ë‹ˆë‹¤.</p>
                </div>

                <h3>ì´ì»¤ë¨¸ìŠ¤ í”Œë«í¼ ì•„í‚¤í…ì²˜</h3>
                <div class="architecture-example">
                    <div class="architecture-request">
                        <h4>ìš”êµ¬ì‚¬í•­: ëŒ€ê·œëª¨ ì´ì»¤ë¨¸ìŠ¤ í”Œë«í¼ ì„¤ê³„</h4>
                        <p>AIì—ê²Œ ìš”ì²­: "ì¼ì¼ 100ë§Œ ì£¼ë¬¸ì„ ì²˜ë¦¬í•  ìˆ˜ ìˆëŠ” ì´ì»¤ë¨¸ìŠ¤ ì•„í‚¤í…ì²˜ë¥¼ ì„¤ê³„í•´ì¤˜"</p>
                    </div>

                    <div class="ai-architecture">
                        <h4>AIê°€ ì œì•ˆí•œ ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜</h4>
                        <pre><code>// architecture/system-design.md
# ëŒ€ê·œëª¨ ì´ì»¤ë¨¸ìŠ¤ í”Œë«í¼ ì•„í‚¤í…ì²˜

## 1. ì „ì²´ ì‹œìŠ¤í…œ êµ¬ì¡°

```mermaid
graph TB
    subgraph "Client Layer"
        WEB[Web App]
        MOBILE[Mobile App]
        ADMIN[Admin Portal]
    end
    
    subgraph "API Gateway Layer"
        KONG[Kong API Gateway]
        AUTH[Auth Service]
    end
    
    subgraph "Service Layer"
        USER[User Service]
        PRODUCT[Product Service]
        ORDER[Order Service]
        PAYMENT[Payment Service]
        INVENTORY[Inventory Service]
        NOTIFICATION[Notification Service]
        SEARCH[Search Service]
        RECOMMENDATION[Recommendation Service]
    end
    
    subgraph "Message Layer"
        KAFKA[Apache Kafka]
        REDIS_PUBSUB[Redis Pub/Sub]
    end
    
    subgraph "Data Layer"
        POSTGRES[(PostgreSQL)]
        MONGODB[(MongoDB)]
        ELASTICSEARCH[(Elasticsearch)]
        REDIS[(Redis Cache)]
        S3[AWS S3]
    end
    
    subgraph "Infrastructure"
        K8S[Kubernetes]
        PROMETHEUS[Prometheus]
        GRAFANA[Grafana]
        ELK[ELK Stack]
    end
```

## 2. ì„œë¹„ìŠ¤ë³„ ìƒì„¸ ì„¤ê³„

### 2.1 User Service
- **ì±…ì„**: ì‚¬ìš©ì ì¸ì¦/ì¸ê°€, í”„ë¡œí•„ ê´€ë¦¬
- **ê¸°ìˆ  ìŠ¤íƒ**: Node.js, PostgreSQL, Redis
- **API ì„¤ê³„**:
  ```yaml
  /api/v1/users:
    post:
      summary: ì‚¬ìš©ì ë“±ë¡
    get:
      summary: ì‚¬ìš©ì ëª©ë¡ ì¡°íšŒ
  
  /api/v1/users/{userId}:
    get:
      summary: ì‚¬ìš©ì ì •ë³´ ì¡°íšŒ
    put:
      summary: ì‚¬ìš©ì ì •ë³´ ìˆ˜ì •
    delete:
      summary: ì‚¬ìš©ì ì‚­ì œ
  
  /api/v1/auth/login:
    post:
      summary: ë¡œê·¸ì¸
  
  /api/v1/auth/refresh:
    post:
      summary: í† í° ê°±ì‹ 
  ```

### 2.2 Order Service
- **ì±…ì„**: ì£¼ë¬¸ ìƒì„±, ì²˜ë¦¬, ìƒíƒœ ê´€ë¦¬
- **ê¸°ìˆ  ìŠ¤íƒ**: Java Spring Boot, PostgreSQL, Kafka
- **ì´ë²¤íŠ¸ ê¸°ë°˜ ì²˜ë¦¬**:
  - OrderCreated
  - OrderPaid
  - OrderShipped
  - OrderDelivered
  - OrderCancelled

### 2.3 Payment Service
- **ì±…ì„**: ê²°ì œ ì²˜ë¦¬, í™˜ë¶ˆ, ì •ì‚°
- **ê¸°ìˆ  ìŠ¤íƒ**: Go, PostgreSQL, Redis
- **ì™¸ë¶€ ì—°ë™**: Stripe, PayPal, êµ­ë‚´ PGì‚¬

## 3. ë°ì´í„°ë² ì´ìŠ¤ ì„¤ê³„

### 3.1 ë¶„ì‚° ë°ì´í„° ê´€ë¦¬
- **CQRS íŒ¨í„´ ì ìš©**
  - Command: PostgreSQL (íŠ¸ëœì­ì…˜ ë³´ì¥)
  - Query: Elasticsearch (ë¹ ë¥¸ ì¡°íšŒ)
  
### 3.2 ë°ì´í„°ë² ì´ìŠ¤ ìƒ¤ë”©
- User DB: user_id ê¸°ë°˜ ìƒ¤ë”©
- Order DB: ë‚ ì§œ ê¸°ë°˜ íŒŒí‹°ì…”ë‹
- Product DB: category_id ê¸°ë°˜ ìƒ¤ë”©

## 4. í™•ì¥ì„± ì „ëµ

### 4.1 ìˆ˜í‰ í™•ì¥
- Kubernetes HPA ê¸°ë°˜ ìë™ ìŠ¤ì¼€ì¼ë§
- ì„œë¹„ìŠ¤ë³„ ë…ë¦½ì  í™•ì¥ ê°€ëŠ¥
- ë°ì´í„°ë² ì´ìŠ¤ ì½ê¸° ë³µì œë³¸ í™œìš©

### 4.2 ìºì‹± ì „ëµ
- L1 Cache: ì• í”Œë¦¬ì¼€ì´ì…˜ ë©”ëª¨ë¦¬ (LRU)
- L2 Cache: Redis Cluster
- CDN: ì •ì  ìì› ë° API ì‘ë‹µ ìºì‹±

## 5. ì•ˆì •ì„± ë³´ì¥

### 5.1 ì„œí‚· ë¸Œë ˆì´ì»¤
- Hystrix/Resilience4j ì ìš©
- ì¥ì•  ì „íŒŒ ë°©ì§€
- ìš°ì•„í•œ ì„±ëŠ¥ ì €í•˜

### 5.2 ì¬ì‹œë„ ë° íƒ€ì„ì•„ì›ƒ
- Exponential Backoff
- Dead Letter Queue
- ë¹„ë™ê¸° ì²˜ë¦¬

## 6. ëª¨ë‹ˆí„°ë§ ë° ê´€ì°°ì„±

### 6.1 ë©”íŠ¸ë¦­
- Prometheus + Grafana
- ì»¤ìŠ¤í…€ ë¹„ì¦ˆë‹ˆìŠ¤ ë©”íŠ¸ë¦­
- SLI/SLO ëŒ€ì‹œë³´ë“œ

### 6.2 ë¡œê¹…
- ELK Stack (Elasticsearch, Logstash, Kibana)
- êµ¬ì¡°í™”ëœ ë¡œê¹…
- ë¶„ì‚° ì¶”ì  (Jaeger)

### 6.3 ì•Œë¦¼
- PagerDuty ì—°ë™
- Slack ì•Œë¦¼
- ìë™ ì¸ì‹œë˜íŠ¸ ìƒì„±</code></pre>
                    </div>

                    <div class="microservices-code">
                        <h4>ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤ êµ¬í˜„ ì˜ˆì‹œ</h4>
                        <pre><code>// services/order-service/src/main/java/com/ecommerce/order/OrderService.java
@Service
@Slf4j
@RequiredArgsConstructor
public class OrderService {
    private final OrderRepository orderRepository;
    private final InventoryServiceClient inventoryClient;
    private final PaymentServiceClient paymentClient;
    private final KafkaTemplate<String, OrderEvent> kafkaTemplate;
    private final CircuitBreaker circuitBreaker;
    
    @Transactional
    public OrderResponse createOrder(CreateOrderRequest request) {
        log.info("Creating order for user: {}", request.getUserId());
        
        // 1. ì¬ê³  í™•ì¸ (Circuit Breaker ì ìš©)
        boolean stockAvailable = circuitBreaker.executeSupplier(() -> 
            inventoryClient.checkStock(request.getItems())
        );
        
        if (!stockAvailable) {
            throw new InsufficientStockException("Some items are out of stock");
        }
        
        // 2. ì£¼ë¬¸ ìƒì„±
        Order order = Order.builder()
            .userId(request.getUserId())
            .items(mapToOrderItems(request.getItems()))
            .status(OrderStatus.PENDING)
            .totalAmount(calculateTotal(request.getItems()))
            .build();
        
        Order savedOrder = orderRepository.save(order);
        
        // 3. ì¬ê³  ì˜ˆì•½ (Saga íŒ¨í„´)
        CompletableFuture<Void> inventoryReservation = CompletableFuture.runAsync(() -> {
            try {
                inventoryClient.reserveStock(savedOrder.getId(), request.getItems());
            } catch (Exception e) {
                log.error("Failed to reserve inventory", e);
                compensateOrder(savedOrder.getId());
                throw new OrderProcessingException("Inventory reservation failed");
            }
        });
        
        // 4. ê²°ì œ ì²˜ë¦¬
        CompletableFuture<PaymentResult> paymentProcessing = CompletableFuture.supplyAsync(() -> {
            try {
                return paymentClient.processPayment(
                    savedOrder.getId(),
                    savedOrder.getTotalAmount(),
                    request.getPaymentMethod()
                );
            } catch (Exception e) {
                log.error("Payment processing failed", e);
                compensateInventory(savedOrder.getId());
                compensateOrder(savedOrder.getId());
                throw new PaymentException("Payment failed");
            }
        });
        
        // 5. ë¹„ë™ê¸° ì²˜ë¦¬ ì™„ë£Œ ëŒ€ê¸°
        try {
            CompletableFuture.allOf(inventoryReservation, paymentProcessing).join();
            PaymentResult paymentResult = paymentProcessing.get();
            
            // 6. ì£¼ë¬¸ ìƒíƒœ ì—…ë°ì´íŠ¸
            savedOrder.setStatus(OrderStatus.CONFIRMED);
            savedOrder.setPaymentId(paymentResult.getTransactionId());
            orderRepository.save(savedOrder);
            
            // 7. ì´ë²¤íŠ¸ ë°œí–‰
            publishOrderEvent(new OrderCreatedEvent(savedOrder));
            
            return OrderResponse.from(savedOrder);
            
        } catch (Exception e) {
            // ë³´ìƒ íŠ¸ëœì­ì…˜
            compensateAll(savedOrder.getId());
            throw new OrderCreationException("Failed to create order", e);
        }
    }
    
    private void publishOrderEvent(OrderEvent event) {
        kafkaTemplate.send("order-events", event.getOrderId(), event)
            .addCallback(
                result -> log.info("Event published: {}", event),
                ex -> log.error("Failed to publish event", ex)
            );
    }
    
    // Saga ë³´ìƒ ë¡œì§
    private void compensateOrder(String orderId) {
        orderRepository.findById(orderId).ifPresent(order -> {
            order.setStatus(OrderStatus.CANCELLED);
            orderRepository.save(order);
            publishOrderEvent(new OrderCancelledEvent(order));
        });
    }
    
    private void compensateInventory(String orderId) {
        try {
            inventoryClient.releaseStock(orderId);
        } catch (Exception e) {
            log.error("Failed to compensate inventory", e);
            // Dead Letter Queueë¡œ ì „ì†¡
            sendToDeadLetterQueue("inventory-compensation", orderId);
        }
    }
}

// Domain Event
@Value
@Builder
public class OrderCreatedEvent implements OrderEvent {
    String eventId = UUID.randomUUID().toString();
    String orderId;
    String userId;
    Instant timestamp = Instant.now();
    List<OrderItem> items;
    BigDecimal totalAmount;
    
    @Override
    public String getEventType() {
        return "ORDER_CREATED";
    }
}

// Event Handler
@Component
@Slf4j
@RequiredArgsConstructor
public class OrderEventHandler {
    private final NotificationService notificationService;
    private final AnalyticsService analyticsService;
    private final RecommendationService recommendationService;
    
    @KafkaListener(topics = "order-events")
    @Retryable(maxAttempts = 3, backoff = @Backoff(delay = 1000))
    public void handleOrderEvent(OrderEvent event) {
        log.info("Processing event: {} for order: {}", 
            event.getEventType(), event.getOrderId());
        
        switch (event.getEventType()) {
            case "ORDER_CREATED":
                handleOrderCreated((OrderCreatedEvent) event);
                break;
            case "ORDER_CANCELLED":
                handleOrderCancelled((OrderCancelledEvent) event);
                break;
            default:
                log.warn("Unknown event type: {}", event.getEventType());
        }
    }
    
    private void handleOrderCreated(OrderCreatedEvent event) {
        // ì•Œë¦¼ ë°œì†¡
        CompletableFuture.runAsync(() -> 
            notificationService.sendOrderConfirmation(event)
        );
        
        // ë¶„ì„ ë°ì´í„° ìˆ˜ì§‘
        CompletableFuture.runAsync(() -> 
            analyticsService.trackOrderCreated(event)
        );
        
        // ì¶”ì²œ ì‹œìŠ¤í…œ ì—…ë°ì´íŠ¸
        CompletableFuture.runAsync(() -> 
            recommendationService.updateUserPreferences(event)
        );
    }
}</code></pre>
                    </div>
                </div>
            </section>

            <section class="content-section">
                <h2><i class="fas fa-hexagon"></i> í—¥ì‚¬ê³ ë‚  ì•„í‚¤í…ì²˜</h2>

                <div class="hexagonal-architecture">
                    <h3>í¬íŠ¸ì™€ ì–´ëŒ‘í„° íŒ¨í„´</h3>
                    
                    <div class="hexagonal-structure">
                        <h4>í”„ë¡œì íŠ¸ êµ¬ì¡°</h4>
                        <pre><code>// í—¥ì‚¬ê³ ë‚  ì•„í‚¤í…ì²˜ í”„ë¡œì íŠ¸ êµ¬ì¡°
src/
â”œâ”€â”€ domain/                 # ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ (í•µì‹¬)
â”‚   â”œâ”€â”€ models/            # ë„ë©”ì¸ ì—”í‹°í‹°
â”‚   â”œâ”€â”€ ports/             # ì¸í„°í˜ì´ìŠ¤ ì •ì˜
â”‚   â”‚   â”œâ”€â”€ in/           # ì¸ë°”ìš´ë“œ í¬íŠ¸ (Use Cases)
â”‚   â”‚   â””â”€â”€ out/          # ì•„ì›ƒë°”ìš´ë“œ í¬íŠ¸ (Repository)
â”‚   â””â”€â”€ services/          # ë„ë©”ì¸ ì„œë¹„ìŠ¤
â”œâ”€â”€ application/           # ì• í”Œë¦¬ì¼€ì´ì…˜ ì„œë¹„ìŠ¤
â”‚   â”œâ”€â”€ usecases/         # ìœ ìŠ¤ì¼€ì´ìŠ¤ êµ¬í˜„
â”‚   â””â”€â”€ dto/              # DTO ì •ì˜
â”œâ”€â”€ adapters/             # ì–´ëŒ‘í„° (ì™¸ë¶€ ì„¸ê³„ì™€ì˜ ì—°ê²°)
â”‚   â”œâ”€â”€ in/              # ì¸ë°”ìš´ë“œ ì–´ëŒ‘í„°
â”‚   â”‚   â”œâ”€â”€ web/        # REST API
â”‚   â”‚   â”œâ”€â”€ grpc/      # gRPC
â”‚   â”‚   â””â”€â”€ graphql/   # GraphQL
â”‚   â””â”€â”€ out/             # ì•„ì›ƒë°”ìš´ë“œ ì–´ëŒ‘í„°
â”‚       â”œâ”€â”€ persistence/ # ë°ì´í„°ë² ì´ìŠ¤
â”‚       â”œâ”€â”€ messaging/   # ë©”ì‹œì§€ í
â”‚       â””â”€â”€ external/    # ì™¸ë¶€ API
â””â”€â”€ infrastructure/       # ì¸í”„ë¼ ì„¤ì •
    â”œâ”€â”€ config/          # ì„¤ì • íŒŒì¼
    â””â”€â”€ security/        # ë³´ì•ˆ ì„¤ì •</code></pre>
                    </div>

                    <div class="hexagonal-implementation">
                        <h4>í—¥ì‚¬ê³ ë‚  ì•„í‚¤í…ì²˜ êµ¬í˜„</h4>
                        <pre><code>// domain/models/Product.ts
export class Product {
    private constructor(
        private readonly id: ProductId,
        private name: string,
        private description: string,
        private price: Money,
        private stock: number,
        private category: Category,
        private status: ProductStatus
    ) {
        this.validate();
    }

    static create(props: CreateProductProps): Product {
        const productId = ProductId.generate();
        return new Product(
            productId,
            props.name,
            props.description,
            Money.fromAmount(props.price),
            props.stock,
            props.category,
            ProductStatus.ACTIVE
        );
    }

    updatePrice(newPrice: Money): void {
        if (newPrice.isNegative()) {
            throw new InvalidPriceException('Price cannot be negative');
        }
        this.price = newPrice;
    }

    decreaseStock(quantity: number): void {
        if (this.stock < quantity) {
            throw new InsufficientStockException(
                `Insufficient stock. Available: ${this.stock}, Requested: ${quantity}`
            );
        }
        this.stock -= quantity;
    }

    private validate(): void {
        if (!this.name || this.name.length < 3) {
            throw new ValidationException('Product name must be at least 3 characters');
        }
        if (this.stock < 0) {
            throw new ValidationException('Stock cannot be negative');
        }
    }
}

// domain/ports/in/ManageProductUseCase.ts
export interface ManageProductUseCase {
    createProduct(command: CreateProductCommand): Promise<ProductId>;
    updateProduct(command: UpdateProductCommand): Promise<void>;
    deleteProduct(productId: ProductId): Promise<void>;
}

// domain/ports/out/ProductRepository.ts
export interface ProductRepository {
    save(product: Product): Promise<void>;
    findById(id: ProductId): Promise<Product | null>;
    findByCategory(category: Category): Promise<Product[]>;
    delete(id: ProductId): Promise<void>;
}

// application/usecases/ManageProductService.ts
@Injectable()
export class ManageProductService implements ManageProductUseCase {
    constructor(
        private readonly productRepository: ProductRepository,
        private readonly eventPublisher: EventPublisher,
        private readonly validator: ProductValidator
    ) {}

    async createProduct(command: CreateProductCommand): Promise<ProductId> {
        // ë¹„ì¦ˆë‹ˆìŠ¤ ê·œì¹™ ê²€ì¦
        await this.validator.validateCreateProduct(command);

        // ë„ë©”ì¸ ê°ì²´ ìƒì„±
        const product = Product.create({
            name: command.name,
            description: command.description,
            price: command.price,
            stock: command.stock,
            category: command.category
        });

        // ì €ì¥
        await this.productRepository.save(product);

        // ì´ë²¤íŠ¸ ë°œí–‰
        await this.eventPublisher.publish(
            new ProductCreatedEvent(product.getId(), product.getName())
        );

        return product.getId();
    }

    async updateProduct(command: UpdateProductCommand): Promise<void> {
        const product = await this.productRepository.findById(command.productId);
        
        if (!product) {
            throw new ProductNotFoundException(command.productId);
        }

        // ë„ë©”ì¸ ë¡œì§ ì‹¤í–‰
        if (command.price) {
            product.updatePrice(Money.fromAmount(command.price));
        }
        
        if (command.stock !== undefined) {
            product.updateStock(command.stock);
        }

        // ì €ì¥
        await this.productRepository.save(product);

        // ì´ë²¤íŠ¸ ë°œí–‰
        await this.eventPublisher.publish(
            new ProductUpdatedEvent(product.getId(), command)
        );
    }
}

// adapters/in/web/ProductController.ts
@Controller('/api/v1/products')
@UseGuards(AuthGuard)
export class ProductController {
    constructor(
        private readonly manageProductUseCase: ManageProductUseCase,
        private readonly queryProductUseCase: QueryProductUseCase
    ) {}

    @Post()
    @UseInterceptors(ValidationInterceptor)
    async createProduct(@Body() dto: CreateProductDto): Promise<ProductResponse> {
        const command = CreateProductCommand.fromDto(dto);
        const productId = await this.manageProductUseCase.createProduct(command);
        
        return {
            id: productId.getValue(),
            message: 'Product created successfully'
        };
    }

    @Get(':id')
    async getProduct(@Param('id') id: string): Promise<ProductDto> {
        const query = new GetProductQuery(ProductId.fromString(id));
        const product = await this.queryProductUseCase.getProduct(query);
        
        return ProductDto.fromDomain(product);
    }

    @Put(':id')
    async updateProduct(
        @Param('id') id: string,
        @Body() dto: UpdateProductDto
    ): Promise<void> {
        const command = UpdateProductCommand.fromDto(id, dto);
        await this.manageProductUseCase.updateProduct(command);
    }
}

// adapters/out/persistence/ProductPersistenceAdapter.ts
@Injectable()
export class ProductPersistenceAdapter implements ProductRepository {
    constructor(
        private readonly prisma: PrismaService,
        private readonly mapper: ProductMapper
    ) {}

    async save(product: Product): Promise<void> {
        const data = this.mapper.toPersistence(product);
        
        await this.prisma.product.upsert({
            where: { id: data.id },
            create: data,
            update: data
        });
    }

    async findById(id: ProductId): Promise<Product | null> {
        const data = await this.prisma.product.findUnique({
            where: { id: id.getValue() },
            include: {
                category: true,
                reviews: true
            }
        });

        return data ? this.mapper.toDomain(data) : null;
    }

    async findByCategory(category: Category): Promise<Product[]> {
        const data = await this.prisma.product.findMany({
            where: {
                categoryId: category.getId().getValue(),
                status: 'ACTIVE'
            },
            orderBy: { createdAt: 'desc' }
        });

        return data.map(item => this.mapper.toDomain(item));
    }
}</code></pre>
                    </div>
                </div>
            </section>

            <section class="content-section">
                <h2><i class="fas fa-stream"></i> ì´ë²¤íŠ¸ ì£¼ë„ ì•„í‚¤í…ì²˜</h2>

                <div class="event-driven">
                    <h3>Event Sourcingê³¼ CQRS</h3>
                    
                    <div class="event-sourcing">
                        <h4>ì´ë²¤íŠ¸ ì†Œì‹± êµ¬í˜„</h4>
                        <pre><code>// domain/aggregates/Order.ts
export class Order extends AggregateRoot {
    private orderId: OrderId;
    private customerId: CustomerId;
    private items: OrderItem[] = [];
    private status: OrderStatus;
    private totalAmount: Money;
    private version: number = 0;

    // ì´ë²¤íŠ¸ ì†Œì‹±: ì´ë²¤íŠ¸ì—ì„œ ìƒíƒœ ë³µì›
    static fromEvents(events: DomainEvent[]): Order {
        const order = new Order();
        
        events.forEach(event => {
            order.apply(event, false);
        });
        
        return order;
    }

    // ëª…ë ¹ ì²˜ë¦¬
    placeOrder(command: PlaceOrderCommand): void {
        // ë¹„ì¦ˆë‹ˆìŠ¤ ê·œì¹™ ê²€ì¦
        if (this.items.length === 0) {
            throw new EmptyOrderException();
        }

        // ì´ë²¤íŠ¸ ìƒì„± ë° ì ìš©
        const event = new OrderPlacedEvent({
            orderId: this.orderId,
            customerId: this.customerId,
            items: this.items,
            totalAmount: this.calculateTotal(),
            timestamp: new Date()
        });

        this.apply(event);
    }

    cancelOrder(reason: string): void {
        if (!this.canBeCancelled()) {
            throw new OrderCannotBeCancelledException(this.status);
        }

        const event = new OrderCancelledEvent({
            orderId: this.orderId,
            reason,
            timestamp: new Date()
        });

        this.apply(event);
    }

    // ì´ë²¤íŠ¸ ì ìš©
    protected when(event: DomainEvent): void {
        switch (event.constructor) {
            case OrderPlacedEvent:
                this.onOrderPlaced(event as OrderPlacedEvent);
                break;
            case OrderCancelledEvent:
                this.onOrderCancelled(event as OrderCancelledEvent);
                break;
            case OrderShippedEvent:
                this.onOrderShipped(event as OrderShippedEvent);
                break;
        }
    }

    private onOrderPlaced(event: OrderPlacedEvent): void {
        this.orderId = event.orderId;
        this.customerId = event.customerId;
        this.items = event.items;
        this.status = OrderStatus.PLACED;
        this.totalAmount = event.totalAmount;
    }

    private onOrderCancelled(event: OrderCancelledEvent): void {
        this.status = OrderStatus.CANCELLED;
    }
}

// infrastructure/eventstore/EventStore.ts
export interface EventStore {
    saveEvents(aggregateId: string, events: DomainEvent[], expectedVersion: number): Promise<void>;
    getEvents(aggregateId: string): Promise<DomainEvent[]>;
    getEventsFromSnapshot(aggregateId: string, version: number): Promise<DomainEvent[]>;
    saveSnapshot(aggregateId: string, snapshot: AggregateSnapshot): Promise<void>;
}

@Injectable()
export class PostgresEventStore implements EventStore {
    constructor(
        private readonly db: DatabaseConnection,
        private readonly serializer: EventSerializer
    ) {}

    async saveEvents(
        aggregateId: string, 
        events: DomainEvent[], 
        expectedVersion: number
    ): Promise<void> {
        const client = await this.db.getClient();
        
        try {
            await client.query('BEGIN');

            // ë‚™ê´€ì  ë™ì‹œì„± ì œì–´
            const result = await client.query(
                'SELECT MAX(version) as version FROM events WHERE aggregate_id = $1',
                [aggregateId]
            );

            const currentVersion = result.rows[0]?.version || 0;
            
            if (currentVersion !== expectedVersion) {
                throw new ConcurrencyException(
                    `Expected version ${expectedVersion} but was ${currentVersion}`
                );
            }

            // ì´ë²¤íŠ¸ ì €ì¥
            for (const event of events) {
                const eventData = this.serializer.serialize(event);
                
                await client.query(
                    `INSERT INTO events 
                     (event_id, aggregate_id, event_type, event_data, version, timestamp)
                     VALUES ($1, $2, $3, $4, $5, $6)`,
                    [
                        event.eventId,
                        aggregateId,
                        event.constructor.name,
                        eventData,
                        ++currentVersion,
                        event.timestamp
                    ]
                );
            }

            await client.query('COMMIT');
            
            // ì´ë²¤íŠ¸ ë°œí–‰
            await this.publishEvents(events);
            
        } catch (error) {
            await client.query('ROLLBACK');
            throw error;
        } finally {
            client.release();
        }
    }

    async getEvents(aggregateId: string): Promise<DomainEvent[]> {
        const result = await this.db.query(
            `SELECT event_type, event_data, version, timestamp 
             FROM events 
             WHERE aggregate_id = $1 
             ORDER BY version`,
            [aggregateId]
        );

        return result.rows.map(row => 
            this.serializer.deserialize(row.event_type, row.event_data)
        );
    }
}

// application/commands/OrderCommandHandler.ts
@Injectable()
export class OrderCommandHandler {
    constructor(
        private readonly eventStore: EventStore,
        private readonly orderRepository: OrderRepository
    ) {}

    async handle(command: PlaceOrderCommand): Promise<void> {
        // ì´ë²¤íŠ¸ ìŠ¤í† ì–´ì—ì„œ í˜„ì¬ ìƒíƒœ ë¡œë“œ
        const events = await this.eventStore.getEvents(command.orderId);
        const order = events.length > 0 
            ? Order.fromEvents(events)
            : Order.create(command);

        // ëª…ë ¹ ì‹¤í–‰
        order.placeOrder(command);

        // ìƒˆ ì´ë²¤íŠ¸ ì €ì¥
        const uncommittedEvents = order.getUncommittedEvents();
        await this.eventStore.saveEvents(
            command.orderId,
            uncommittedEvents,
            order.getVersion()
        );

        // Read Model ì—…ë°ì´íŠ¸ (CQRS)
        await this.updateReadModel(order);
    }

    private async updateReadModel(order: Order): Promise<void> {
        // ì½ê¸° ì „ìš© ëª¨ë¸ ì—…ë°ì´íŠ¸
        const orderView = OrderView.fromAggregate(order);
        await this.orderRepository.save(orderView);
    }
}

// application/queries/OrderQueryHandler.ts
@Injectable()
export class OrderQueryHandler {
    constructor(
        private readonly readDb: ReadDatabaseConnection,
        private readonly cache: CacheService
    ) {}

    async getOrderById(orderId: string): Promise<OrderView> {
        // ìºì‹œ í™•ì¸
        const cached = await this.cache.get(`order:${orderId}`);
        if (cached) return cached;

        // Read DBì—ì„œ ì¡°íšŒ
        const result = await this.readDb.query(
            `SELECT * FROM order_views WHERE order_id = $1`,
            [orderId]
        );

        if (!result.rows[0]) {
            throw new OrderNotFoundException(orderId);
        }

        const orderView = OrderView.fromDb(result.rows[0]);
        
        // ìºì‹œ ì €ì¥
        await this.cache.set(`order:${orderId}`, orderView, 300);
        
        return orderView;
    }

    async getOrdersByCustomer(
        customerId: string, 
        pagination: PaginationParams
    ): Promise<PagedResult<OrderView>> {
        const result = await this.readDb.query(
            `SELECT * FROM order_views 
             WHERE customer_id = $1 
             ORDER BY created_at DESC 
             LIMIT $2 OFFSET $3`,
            [customerId, pagination.limit, pagination.offset]
        );

        const countResult = await this.readDb.query(
            `SELECT COUNT(*) FROM order_views WHERE customer_id = $1`,
            [customerId]
        );

        return {
            items: result.rows.map(row => OrderView.fromDb(row)),
            total: parseInt(countResult.rows[0].count),
            page: pagination.page,
            pageSize: pagination.limit
        };
    }
}</code></pre>
                    </div>

                    <div class="saga-pattern">
                        <h4>Saga íŒ¨í„´ êµ¬í˜„</h4>
                        <pre><code>// sagas/OrderSaga.ts
export class OrderSaga {
    private readonly steps: SagaStep[] = [];
    private readonly compensations: Map<string, CompensationAction> = new Map();

    constructor(
        private readonly orderService: OrderService,
        private readonly inventoryService: InventoryService,
        private readonly paymentService: PaymentService,
        private readonly shippingService: ShippingService
    ) {
        this.defineSteps();
    }

    private defineSteps(): void {
        // Step 1: ì£¼ë¬¸ ìƒì„±
        this.addStep({
            name: 'CREATE_ORDER',
            action: async (context: OrderContext) => {
                const order = await this.orderService.createOrder(context.orderData);
                context.orderId = order.id;
                return order;
            },
            compensation: async (context: OrderContext) => {
                if (context.orderId) {
                    await this.orderService.cancelOrder(context.orderId);
                }
            }
        });

        // Step 2: ì¬ê³  ì˜ˆì•½
        this.addStep({
            name: 'RESERVE_INVENTORY',
            action: async (context: OrderContext) => {
                const reservation = await this.inventoryService.reserveItems(
                    context.orderId,
                    context.orderData.items
                );
                context.reservationId = reservation.id;
                return reservation;
            },
            compensation: async (context: OrderContext) => {
                if (context.reservationId) {
                    await this.inventoryService.releaseReservation(context.reservationId);
                }
            }
        });

        // Step 3: ê²°ì œ ì²˜ë¦¬
        this.addStep({
            name: 'PROCESS_PAYMENT',
            action: async (context: OrderContext) => {
                const payment = await this.paymentService.processPayment({
                    orderId: context.orderId,
                    amount: context.orderData.totalAmount,
                    paymentMethod: context.orderData.paymentMethod
                });
                context.paymentId = payment.transactionId;
                return payment;
            },
            compensation: async (context: OrderContext) => {
                if (context.paymentId) {
                    await this.paymentService.refund(context.paymentId);
                }
            }
        });

        // Step 4: ë°°ì†¡ ì¤€ë¹„
        this.addStep({
            name: 'PREPARE_SHIPPING',
            action: async (context: OrderContext) => {
                const shipping = await this.shippingService.createShipment({
                    orderId: context.orderId,
                    address: context.orderData.shippingAddress,
                    items: context.orderData.items
                });
                context.shipmentId = shipping.id;
                return shipping;
            },
            compensation: async (context: OrderContext) => {
                if (context.shipmentId) {
                    await this.shippingService.cancelShipment(context.shipmentId);
                }
            }
        });
    }

    async execute(orderData: CreateOrderData): Promise<OrderResult> {
        const context: OrderContext = { orderData };
        const executedSteps: string[] = [];

        try {
            // ê° ìŠ¤í… ì‹¤í–‰
            for (const step of this.steps) {
                log.info(`Executing saga step: ${step.name}`);
                
                await step.action(context);
                executedSteps.push(step.name);
                
                // ìŠ¤í… ì™„ë£Œ ì´ë²¤íŠ¸ ë°œí–‰
                await this.publishStepCompleted(step.name, context);
            }

            // ì„±ê³µ ì‹œ ì™„ë£Œ ì´ë²¤íŠ¸ ë°œí–‰
            await this.publishSagaCompleted(context);
            
            return {
                success: true,
                orderId: context.orderId,
                message: 'Order processed successfully'
            };

        } catch (error) {
            log.error(`Saga failed at step: ${executedSteps[executedSteps.length - 1]}`, error);
            
            // ë³´ìƒ íŠ¸ëœì­ì…˜ ì‹¤í–‰
            await this.compensate(executedSteps, context);
            
            // ì‹¤íŒ¨ ì´ë²¤íŠ¸ ë°œí–‰
            await this.publishSagaFailed(context, error);
            
            throw new SagaExecutionException('Order processing failed', error);
        }
    }

    private async compensate(executedSteps: string[], context: OrderContext): Promise<void> {
        // ì—­ìˆœìœ¼ë¡œ ë³´ìƒ ì‹¤í–‰
        for (let i = executedSteps.length - 1; i >= 0; i--) {
            const stepName = executedSteps[i];
            const compensation = this.compensations.get(stepName);
            
            if (compensation) {
                try {
                    log.info(`Executing compensation for: ${stepName}`);
                    await compensation(context);
                } catch (error) {
                    log.error(`Compensation failed for: ${stepName}`, error);
                    // ë³´ìƒ ì‹¤íŒ¨ëŠ” Dead Letter Queueë¡œ
                    await this.sendToDeadLetterQueue(stepName, context, error);
                }
            }
        }
    }
}

// Orchestrator ê¸°ë°˜ Saga
@Injectable()
export class OrderSagaOrchestrator {
    constructor(
        private readonly sagaRepository: SagaRepository,
        private readonly eventBus: EventBus
    ) {}

    @EventHandler(OrderCreatedEvent)
    async handleOrderCreated(event: OrderCreatedEvent): Promise<void> {
        // Saga ì¸ìŠ¤í„´ìŠ¤ ìƒì„±
        const saga = await this.sagaRepository.create({
            sagaId: generateSagaId(),
            orderId: event.orderId,
            status: SagaStatus.STARTED,
            currentStep: 'ORDER_CREATED'
        });

        // ë‹¤ìŒ ìŠ¤í… ì‹¤í–‰
        await this.executeNextStep(saga);
    }

    private async executeNextStep(saga: SagaInstance): Promise<void> {
        const nextStep = this.getNextStep(saga.currentStep);
        
        if (!nextStep) {
            // Saga ì™„ë£Œ
            saga.status = SagaStatus.COMPLETED;
            await this.sagaRepository.update(saga);
            return;
        }

        try {
            // ìŠ¤í… ì‹¤í–‰
            await this.executeStep(nextStep, saga);
            
            // ìƒíƒœ ì—…ë°ì´íŠ¸
            saga.currentStep = nextStep;
            await this.sagaRepository.update(saga);
            
        } catch (error) {
            // ì‹¤íŒ¨ ì²˜ë¦¬
            saga.status = SagaStatus.COMPENSATING;
            await this.sagaRepository.update(saga);
            
            // ë³´ìƒ ì‹œì‘
            await this.startCompensation(saga);
        }
    }
}</code></pre>
                    </div>
                </div>
            </section>

            <section class="content-section">
                <h2><i class="fas fa-chart-network"></i> ë¶„ì‚° ì‹œìŠ¤í…œ íŒ¨í„´</h2>

                <div class="distributed-patterns">
                    <h3>ë¶„ì‚° ì‹œìŠ¤í…œ í•µì‹¬ íŒ¨í„´</h3>
                    
                    <div class="service-mesh">
                        <h4>Service Mesh êµ¬í˜„</h4>
                        <pre><code># istio-service-mesh.yaml
apiVersion: networking.istio.io/v1beta1
kind: VirtualService
metadata:
  name: order-service
  namespace: production
spec:
  hosts:
  - order-service
  http:
  - match:
    - headers:
        x-version:
          exact: v2
    route:
    - destination:
        host: order-service
        subset: v2
      weight: 100
  - route:
    - destination:
        host: order-service
        subset: v1
      weight: 90
    - destination:
        host: order-service
        subset: v2
      weight: 10
    timeout: 30s
    retries:
      attempts: 3
      perTryTimeout: 10s
      retryOn: 5xx,reset,connect-failure,refused-stream

---
apiVersion: networking.istio.io/v1beta1
kind: DestinationRule
metadata:
  name: order-service
  namespace: production
spec:
  host: order-service
  trafficPolicy:
    connectionPool:
      tcp:
        maxConnections: 100
      http:
        http1MaxPendingRequests: 50
        http2MaxRequests: 100
        maxRequestsPerConnection: 2
    loadBalancer:
      consistentHash:
        httpCookie:
          name: "session-affinity"
          ttl: 3600s
    outlierDetection:
      consecutiveErrors: 5
      interval: 30s
      baseEjectionTime: 30s
      maxEjectionPercent: 50
      minHealthPercent: 30
  subsets:
  - name: v1
    labels:
      version: v1
    trafficPolicy:
      connectionPool:
        tcp:
          maxConnections: 50
  - name: v2
    labels:
      version: v2

---
# Circuit Breaker
apiVersion: networking.istio.io/v1beta1
kind: VirtualService
metadata:
  name: payment-service
spec:
  hosts:
  - payment-service
  http:
  - fault:
      delay:
        percentage:
          value: 0.1
        fixedDelay: 5s
      abort:
        percentage:
          value: 0.1
        httpStatus: 503
    route:
    - destination:
        host: payment-service

---
# Distributed Tracing
apiVersion: v1
kind: ConfigMap
metadata:
  name: jaeger-config
data:
  sampling.json: |
    {
      "service_strategies": [
        {
          "service": "order-service",
          "type": "probabilistic",
          "param": 0.1
        },
        {
          "service": "payment-service",
          "type": "adaptive",
          "max_traces_per_second": 100
        }
      ],
      "default_strategy": {
        "type": "probabilistic",
        "param": 0.01
      }
    }</code></pre>
                    </div>

                    <div class="distributed-locking">
                        <h4>ë¶„ì‚° ë½ê³¼ ë¦¬ë” ì„ ì¶œ</h4>
                        <pre><code>// distributed/DistributedLock.ts
export class RedisDistributedLock {
    private readonly redis: RedisClient;
    private readonly defaultTTL = 30000; // 30ì´ˆ

    async acquireLock(
        key: string, 
        ttl: number = this.defaultTTL
    ): Promise<Lock | null> {
        const lockId = generateLockId();
        const lockKey = `lock:${key}`;
        
        // SET NX EX ì›ìì  ì—°ì‚°
        const acquired = await this.redis.set(
            lockKey,
            lockId,
            'PX',
            ttl,
            'NX'
        );

        if (!acquired) {
            return null;
        }

        return new Lock(lockKey, lockId, ttl);
    }

    async releaseLock(lock: Lock): Promise<boolean> {
        // Lua ìŠ¤í¬ë¦½íŠ¸ë¡œ ì›ìì  í•´ì œ
        const script = `
            if redis.call("get", KEYS[1]) == ARGV[1] then
                return redis.call("del", KEYS[1])
            else
                return 0
            end
        `;

        const result = await this.redis.eval(
            script,
            1,
            lock.key,
            lock.id
        );

        return result === 1;
    }

    async extendLock(lock: Lock, ttl: number): Promise<boolean> {
        const script = `
            if redis.call("get", KEYS[1]) == ARGV[1] then
                return redis.call("pexpire", KEYS[1], ARGV[2])
            else
                return 0
            end
        `;

        const result = await this.redis.eval(
            script,
            1,
            lock.key,
            lock.id,
            ttl
        );

        return result === 1;
    }
}

// ë¦¬ë” ì„ ì¶œ
export class LeaderElection {
    private readonly lockKey = 'leader-election';
    private readonly heartbeatInterval = 5000; // 5ì´ˆ
    private isLeader = false;
    private heartbeatTimer?: NodeJS.Timer;

    constructor(
        private readonly lock: DistributedLock,
        private readonly nodeId: string
    ) {}

    async start(onBecomeLeader: () => void, onLoseLeadership: () => void): Promise<void> {
        while (true) {
            try {
                // ë¦¬ë” ì„ ì¶œ ì‹œë„
                const acquired = await this.lock.acquireLock(
                    this.lockKey,
                    this.heartbeatInterval * 2
                );

                if (acquired) {
                    this.isLeader = true;
                    log.info(`Node ${this.nodeId} became leader`);
                    
                    onBecomeLeader();
                    
                    // í•˜íŠ¸ë¹„íŠ¸ ì‹œì‘
                    this.startHeartbeat(acquired);
                    
                    // ë¦¬ë”ì‹­ ìœ ì§€
                    await this.maintainLeadership(acquired, onLoseLeadership);
                } else {
                    // íŒ”ë¡œì›Œë¡œ ëŒ€ê¸°
                    await this.waitAsFollower();
                }
            } catch (error) {
                log.error('Leader election error:', error);
                await this.delay(this.heartbeatInterval);
            }
        }
    }

    private async maintainLeadership(
        lock: Lock, 
        onLoseLeadership: () => void
    ): Promise<void> {
        while (this.isLeader) {
            try {
                // ë½ ê°±ì‹ 
                const extended = await this.lock.extendLock(
                    lock,
                    this.heartbeatInterval * 2
                );

                if (!extended) {
                    // ë¦¬ë”ì‹­ ìƒì‹¤
                    this.isLeader = false;
                    this.stopHeartbeat();
                    onLoseLeadership();
                    break;
                }

                await this.delay(this.heartbeatInterval);
            } catch (error) {
                log.error('Failed to maintain leadership:', error);
                this.isLeader = false;
                this.stopHeartbeat();
                onLoseLeadership();
                break;
            }
        }
    }
}

// ë¶„ì‚° í•©ì˜ (Raft ê°„ë‹¨ êµ¬í˜„)
export class SimpleRaft {
    private state: 'follower' | 'candidate' | 'leader' = 'follower';
    private currentTerm = 0;
    private votedFor: string | null = null;
    private log: LogEntry[] = [];
    private commitIndex = 0;

    constructor(
        private readonly nodeId: string,
        private readonly peers: string[],
        private readonly rpc: RaftRPC
    ) {}

    // ë¦¬ë” ì„ ì¶œ
    private async startElection(): Promise<void> {
        this.state = 'candidate';
        this.currentTerm++;
        this.votedFor = this.nodeId;
        
        const votes = 1; // ìì‹ ì˜ í‘œ
        const majority = Math.floor(this.peers.length / 2) + 1;

        // ë™ì‹œì— ëª¨ë“  ë…¸ë“œì— íˆ¬í‘œ ìš”ì²­
        const votePromises = this.peers.map(peer => 
            this.requestVote(peer)
        );

        const results = await Promise.allSettled(votePromises);
        const approvals = results.filter(r => 
            r.status === 'fulfilled' && r.value.voteGranted
        ).length;

        if (votes + approvals >= majority) {
            this.becomeLeader();
        } else {
            this.state = 'follower';
        }
    }

    private async requestVote(peer: string): Promise<VoteResponse> {
        return this.rpc.requestVote(peer, {
            term: this.currentTerm,
            candidateId: this.nodeId,
            lastLogIndex: this.log.length - 1,
            lastLogTerm: this.log[this.log.length - 1]?.term || 0
        });
    }
}</code></pre>
                    </div>
                </div>
            </section>

            <section class="practice">
                <h2><i class="fas fa-laptop-code"></i> ì‹¤ìŠµ: ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤ ì„¤ê³„</h2>

                <div class="practice-content">
                    <h3>ì˜¨ë¼ì¸ ë±…í‚¹ ì‹œìŠ¤í…œ ì„¤ê³„</h3>
                    <p>AIì™€ í•¨ê»˜ ëŒ€ê·œëª¨ ì˜¨ë¼ì¸ ë±…í‚¹ ì‹œìŠ¤í…œì„ ì„¤ê³„í•´ë´…ì‹œë‹¤.</p>

                    <div class="banking-requirements">
                        <h4>ì‹œìŠ¤í…œ ìš”êµ¬ì‚¬í•­</h4>
                        <ul>
                            <li>ì¼ì¼ 1000ë§Œ ê±°ë˜ ì²˜ë¦¬</li>
                            <li>99.99% ê°€ìš©ì„± ë³´ì¥</li>
                            <li>ê°•ë ¥í•œ ë³´ì•ˆê³¼ ê·œì • ì¤€ìˆ˜</li>
                            <li>ì‹¤ì‹œê°„ ì”ì•¡ ì—…ë°ì´íŠ¸</li>
                            <li>ë‹¤ì¤‘ í†µí™” ì§€ì›</li>
                            <li>ì‚¬ê¸° íƒì§€ ì‹œìŠ¤í…œ</li>
                        </ul>
                    </div>

                    <div class="design-steps">
                        <h4>ì„¤ê³„ ë‹¨ê³„</h4>
                        
                        <div class="step">
                            <h5>1. ë„ë©”ì¸ ë¶„ì„</h5>
                            <p>Chatì— ìš”ì²­: "ì˜¨ë¼ì¸ ë±…í‚¹ì˜ í•µì‹¬ ë„ë©”ì¸ê³¼ ë°”ìš´ë””ë“œ ì»¨í…ìŠ¤íŠ¸ë¥¼ ì •ì˜í•´ì¤˜"</p>
                        </div>
                        
                        <div class="step">
                            <h5>2. ì„œë¹„ìŠ¤ ë¶„í•´</h5>
                            <p>Cmd+K: "ê° ë„ë©”ì¸ë³„ ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤ êµ¬ì¡° ì„¤ê³„"</p>
                        </div>
                        
                        <div class="step">
                            <h5>3. ë°ì´í„° ì „ëµ</h5>
                            <p>Composerë¡œ CQRSì™€ ì´ë²¤íŠ¸ ì†Œì‹± êµ¬í˜„</p>
                        </div>
                        
                        <div class="step">
                            <h5>4. ë³´ì•ˆ ì•„í‚¤í…ì²˜</h5>
                            <p>AIì—ê²Œ: "ê¸ˆìœµ ê·œì •ì„ ì¤€ìˆ˜í•˜ëŠ” ë³´ì•ˆ ì•„í‚¤í…ì²˜ ì„¤ê³„í•´ì¤˜"</p>
                        </div>
                        
                        <div class="step">
                            <h5>5. ì¥ì•  ëŒ€ì‘</h5>
                            <p>ë³µì›ë ¥ ìˆëŠ” ì‹œìŠ¤í…œì„ ìœ„í•œ íŒ¨í„´ ì ìš©</p>
                        </div>
                    </div>

                    <div class="architecture-patterns">
                        <h4>ğŸ›ï¸ ì ìš© íŒ¨í„´</h4>
                        <ul>
                            <li><strong>Event Sourcing:</strong> ëª¨ë“  ê±°ë˜ ë‚´ì—­ ì¶”ì </li>
                            <li><strong>CQRS:</strong> ì½ê¸°/ì“°ê¸° ë¶„ë¦¬</li>
                            <li><strong>Saga:</strong> ë¶„ì‚° íŠ¸ëœì­ì…˜ ê´€ë¦¬</li>
                            <li><strong>Circuit Breaker:</strong> ì¥ì•  ê²©ë¦¬</li>
                            <li><strong>Bulkhead:</strong> ë¦¬ì†ŒìŠ¤ ê²©ë¦¬</li>
                            <li><strong>Service Mesh:</strong> ì„œë¹„ìŠ¤ ê°„ í†µì‹  ê´€ë¦¬</li>
                        </ul>
                    </div>
                </div>
            </section>

            <section class="summary">
                <h2><i class="fas fa-check-circle"></i> í•µì‹¬ ì •ë¦¬</h2>
                
                <div class="key-points">
                    <div class="point">
                        <i class="fas fa-star"></i>
                        <h3>ì§€ëŠ¥ì ì¸ ì•„í‚¤í…ì²˜ ì„¤ê³„</h3>
                        <p>AIê°€ í”„ë¡œì íŠ¸ ìš”êµ¬ì‚¬í•­ì„ ë¶„ì„í•˜ì—¬ ìµœì ì˜ ì•„í‚¤í…ì²˜ë¥¼ ì œì•ˆí•©ë‹ˆë‹¤.</p>
                    </div>
                    
                    <div class="point">
                        <i class="fas fa-star"></i>
                        <h3>íŒ¨í„´ ìë™ ì ìš©</h3>
                        <p>í—¥ì‚¬ê³ ë‚ , ì´ë²¤íŠ¸ ì†Œì‹±, CQRS ë“± ë³µì¡í•œ íŒ¨í„´ì„ ì‰½ê²Œ êµ¬í˜„í•©ë‹ˆë‹¤.</p>
                    </div>
                    
                    <div class="point">
                        <i class="fas fa-star"></i>
                        <h3>ë¶„ì‚° ì‹œìŠ¤í…œ ê´€ë¦¬</h3>
                        <p>ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤ì˜ ë³µì¡ì„±ì„ AIê°€ ê´€ë¦¬í•˜ê³  ìµœì í™”í•©ë‹ˆë‹¤.</p>
                    </div>
                    
                    <div class="point">
                        <i class="fas fa-star"></i>
                        <h3>í™•ì¥ ê°€ëŠ¥í•œ ì„¤ê³„</h3>
                        <p>ì²˜ìŒë¶€í„° í™•ì¥ì„±ì„ ê³ ë ¤í•œ ì•„í‚¤í…ì²˜ë¥¼ êµ¬ì¶•í•©ë‹ˆë‹¤.</p>
                    </div>
                </div>

                <div class="next-steps">
                    <h3>ë‹¤ìŒ ê°•ì˜ ì˜ˆê³ </h3>
                    <p>ë‹¤ìŒ ê°•ì˜ì—ì„œëŠ” AI í™œìš© ê³ ê¸‰ ê¸°ë²•ì„ ë°°ì›ë‹ˆë‹¤.</p>
                    <a href="lesson21.html" class="btn btn-primary">
                        <i class="fas fa-arrow-right"></i> ë‹¤ìŒ ê°•ì˜ë¡œ ì´ë™
                    </a>
                </div>
            </section>
        </main>

        <aside class="sidebar">
            <div class="sidebar-section">
                <h3><i class="fas fa-list"></i> ê°•ì˜ ëª©ì°¨</h3>
                <ol class="lesson-list">
                    <li class="completed">Cursor ì†Œê°œì™€ ì„¤ì¹˜</li>
                    <li class="completed">ì²« ë²ˆì§¸ AI ìë™ì™„ì„±</li>
                    <li class="completed">AI Chat ë§ˆìŠ¤í„°í•˜ê¸°</li>
                    <li class="completed">Cmd+K ì™„ë²½ ê°€ì´ë“œ</li>
                    <li class="completed">í”„ë¡œì íŠ¸ ì»¨í…ìŠ¤íŠ¸</li>
                    <li class="completed">AI ëª¨ë¸ ì„ íƒê³¼ í™œìš©</li>
                    <li class="completed">Composer ê¸°ëŠ¥ í™œìš©</li>
                    <li class="completed">í„°ë¯¸ë„ í†µí•©</li>
                    <li class="completed">ë””ë²„ê¹…ê³¼ ì—ëŸ¬ í•´ê²°</li>
                    <li class="completed">ë‹¨ì¶•í‚¤ì™€ ì„¤ì • ìµœì í™”</li>
                    <li class="completed">Git í†µí•©ê³¼ ë²„ì „ ê´€ë¦¬</li>
                    <li class="completed">í…ŒìŠ¤íŠ¸ ì‘ì„±ê³¼ TDD</li>
                    <li class="completed">ë¦¬íŒ©í† ë§ê³¼ ì½”ë“œ í’ˆì§ˆ</li>
                    <li class="completed">API ê°œë°œê³¼ ë¬¸ì„œí™”</li>
                    <li class="completed">ë°ì´í„°ë² ì´ìŠ¤ ì„¤ê³„ì™€ ìµœì í™”</li>
                    <li class="completed">í”„ë¡ íŠ¸ì—”ë“œ í”„ë ˆì„ì›Œí¬ì™€ Cursor AI</li>
                    <li class="completed">ë°±ì—”ë“œ í”„ë ˆì„ì›Œí¬ì™€ Cursor AI</li>
                    <li class="completed">Dockerì™€ Kubernetes ë°°í¬</li>
                    <li class="completed">ì„±ëŠ¥ ìµœì í™”ì™€ ë³´ì•ˆ</li>
                    <li class="current">ëŒ€ê·œëª¨ í”„ë¡œì íŠ¸ ì•„í‚¤í…ì²˜</li>
                </ol>
            </div>

            <div class="sidebar-section">
                <h3><i class="fas fa-shapes"></i> ì•„í‚¤í…ì²˜ íŒ¨í„´</h3>
                <div class="pattern-list">
                    <div class="pattern-category">
                        <h4>êµ¬ì¡°ì  íŒ¨í„´</h4>
                        <span class="pattern-badge">Layered</span>
                        <span class="pattern-badge">Hexagonal</span>
                        <span class="pattern-badge">Microservices</span>
                    </div>
                    <div class="pattern-category">
                        <h4>í–‰ë™ íŒ¨í„´</h4>
                        <span class="pattern-badge">Event Sourcing</span>
                        <span class="pattern-badge">CQRS</span>
                        <span class="pattern-badge">Saga</span>
                    </div>
                    <div class="pattern-category">
                        <h4>ë³µì›ë ¥ íŒ¨í„´</h4>
                        <span class="pattern-badge">Circuit Breaker</span>
                        <span class="pattern-badge">Retry</span>
                        <span class="pattern-badge">Bulkhead</span>
                    </div>
                </div>
            </div>

            <div class="sidebar-section">
                <h3><i class="fas fa-lightbulb"></i> í”„ë¡œ íŒ</h3>
                <div class="tip-box">
                    <p>ğŸ’¡ ì•„í‚¤í…ì²˜ëŠ” ì§„í™”í•©ë‹ˆë‹¤. ì²˜ìŒë¶€í„° ì™„ë²½í•œ ì„¤ê³„ë¥¼ ì¶”êµ¬í•˜ê¸°ë³´ë‹¤ëŠ”, ë³€ê²½ ê°€ëŠ¥í•œ êµ¬ì¡°ë¥¼ ë§Œë“¤ê³  ì ì§„ì ìœ¼ë¡œ ê°œì„ í•˜ì„¸ìš”. AIê°€ ë¦¬íŒ©í† ë§ì„ ë„ì™€ì¤„ ê²ƒì…ë‹ˆë‹¤.</p>
                </div>
            </div>
        </aside>

        <div class="progress-tracker">
            <div class="progress-bar" style="width: 66.67%"></div>
            <span class="progress-text">20/30 ì™„ë£Œ</span>
        </div>
    </div>

    <script src="../assets/lesson-script.js"></script>
</body>
</html>