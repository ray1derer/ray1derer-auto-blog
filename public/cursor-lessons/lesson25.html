<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ì œ25ê°•: ì½”ë“œ ë§ˆì´ê·¸ë ˆì´ì…˜ê³¼ ë¦¬íŒ©í† ë§ ë„êµ¬ | Cursor AI ë§ˆìŠ¤í„° í´ë˜ìŠ¤</title>
    <link rel="stylesheet" href="../assets/lesson-style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>
<body>
    <div class="lesson-container">
        <header class="lesson-header">
            <div class="lesson-title">
                <h1><i class="fas fa-exchange-alt"></i> ì œ25ê°•: ì½”ë“œ ë§ˆì´ê·¸ë ˆì´ì…˜ê³¼ ë¦¬íŒ©í† ë§ ë„êµ¬</h1>
                <p class="lesson-subtitle">AIì™€ í•¨ê»˜í•˜ëŠ” ëŒ€ê·œëª¨ ì½”ë“œë² ì´ìŠ¤ í˜„ëŒ€í™”</p>
            </div>
            <div class="lesson-meta">
                <span class="difficulty"><i class="fas fa-signal"></i> ë‚œì´ë„: ê³ ê¸‰</span>
                <span class="duration"><i class="fas fa-clock"></i> ì˜ˆìƒ ì‹œê°„: 70ë¶„</span>
                <span class="category"><i class="fas fa-folder"></i> ì¹´í…Œê³ ë¦¬: ê³ ê¸‰</span>
            </div>
        </header>

        <nav class="lesson-nav">
            <a href="lesson24.html" class="nav-link prev">
                <i class="fas fa-chevron-left"></i> ì´ì „ ê°•ì˜
            </a>
            <span class="nav-title">ì œ25ê°•: ì½”ë“œ ë§ˆì´ê·¸ë ˆì´ì…˜ê³¼ ë¦¬íŒ©í† ë§ ë„êµ¬</span>
            <a href="lesson26.html" class="nav-link next">
                ë‹¤ìŒ ê°•ì˜ <i class="fas fa-chevron-right"></i>
            </a>
        </nav>

        <main class="lesson-content">
            <section class="learning-objectives">
                <h2><i class="fas fa-bullseye"></i> í•™ìŠµ ëª©í‘œ</h2>
                <ul>
                    <li>ë ˆê±°ì‹œ ì½”ë“œ í˜„ëŒ€í™” ì „ëµê³¼ ë„êµ¬ ê°œë°œ</li>
                    <li>í”„ë ˆì„ì›Œí¬ ë§ˆì´ê·¸ë ˆì´ì…˜ ìë™í™”</li>
                    <li>ëŒ€ê·œëª¨ ë¦¬íŒ©í† ë§ ì•ˆì „í•˜ê²Œ ìˆ˜í–‰í•˜ê¸°</li>
                    <li>ì½”ë“œ íŒ¨í„´ ë³€í™˜ê³¼ AST ì¡°ì‘</li>
                    <li>ì ì§„ì  ë§ˆì´ê·¸ë ˆì´ì…˜ ì „ëµ êµ¬í˜„</li>
                </ul>
            </section>

            <section class="content-section">
                <h2><i class="fas fa-tools"></i> AI ê¸°ë°˜ ë§ˆì´ê·¸ë ˆì´ì…˜ ë„êµ¬</h2>
                
                <div class="info-box">
                    <p>Cursor AIëŠ” ë³µì¡í•œ ì½”ë“œë² ì´ìŠ¤ì˜ ë§ˆì´ê·¸ë ˆì´ì…˜ì„ ìë™í™”í•˜ê³ , ì•ˆì „í•˜ê²Œ ë¦¬íŒ©í† ë§í•  ìˆ˜ ìˆë„ë¡ ë„ì™€ì¤ë‹ˆë‹¤. AST ë¶„ì„ê³¼ íŒ¨í„´ ë§¤ì¹­ì„ í†µí•´ ëŒ€ê·œëª¨ ë³€ê²½ì„ ì •í™•í•˜ê²Œ ìˆ˜í–‰í•©ë‹ˆë‹¤.</p>
                </div>

                <h3>í”„ë ˆì„ì›Œí¬ ë§ˆì´ê·¸ë ˆì´ì…˜ ìë™í™”</h3>
                <div class="migration-tool">
                    <div class="tool-implementation">
                        <h4>React í´ë˜ìŠ¤ ì»´í¬ë„ŒíŠ¸ â†’ í•¨ìˆ˜í˜• ì»´í¬ë„ŒíŠ¸ ë³€í™˜</h4>
                        <pre><code>// tools/ReactMigrationTool.ts
import { CursorAI } from '@cursor/api';
import { Project, SourceFile, SyntaxKind } from 'ts-morph';
import * as babel from '@babel/core';
import traverse from '@babel/traverse';
import generate from '@babel/generator';
import * as t from '@babel/types';

export class ReactMigrationTool {
    private cursor: CursorAI;
    private project: Project;
    private migrationStats: MigrationStats;

    constructor(projectPath: string) {
        this.cursor = new CursorAI();
        this.project = new Project({
            tsConfigFilePath: `${projectPath}/tsconfig.json`
        });
        this.migrationStats = {
            totalComponents: 0,
            migratedComponents: 0,
            errors: [],
            warnings: []
        };
    }

    async migrateToFunctionalComponents(): Promise<MigrationReport> {
        const files = this.project.getSourceFiles('**/*.{tsx,jsx}');
        
        console.log(`ğŸ” ${files.length}ê°œ íŒŒì¼ ë¶„ì„ ì¤‘...`);

        for (const file of files) {
            try {
                await this.migrateFile(file);
            } catch (error) {
                this.migrationStats.errors.push({
                    file: file.getFilePath(),
                    error: error.message
                });
            }
        }

        return this.generateReport();
    }

    private async migrateFile(file: SourceFile): Promise<void> {
        const filePath = file.getFilePath();
        const sourceCode = file.getFullText();

        // AST íŒŒì‹±
        const ast = babel.parse(sourceCode, {
            sourceType: 'module',
            plugins: ['jsx', 'typescript', 'decorators-legacy'],
            filename: filePath
        });

        let hasChanges = false;

        // í´ë˜ìŠ¤ ì»´í¬ë„ŒíŠ¸ ì°¾ê¸° ë° ë³€í™˜
        traverse(ast, {
            ClassDeclaration: (path) => {
                if (this.isReactComponent(path.node)) {
                    this.migrationStats.totalComponents++;
                    
                    try {
                        const functionalComponent = this.convertToFunctional(path.node);
                        path.replaceWith(functionalComponent);
                        hasChanges = true;
                        this.migrationStats.migratedComponents++;
                    } catch (error) {
                        this.migrationStats.warnings.push({
                            file: filePath,
                            component: path.node.id?.name || 'Anonymous',
                            reason: error.message
                        });
                    }
                }
            }
        });

        if (hasChanges) {
            // ì½”ë“œ ìƒì„± ë° ì €ì¥
            const { code } = generate(ast, {
                retainLines: true,
                decoratorsBeforeExport: true
            });

            // AIë¡œ ì½”ë“œ ìµœì í™”
            const optimizedCode = await this.optimizeWithAI(code, filePath);
            
            file.replaceWithText(optimizedCode);
            await file.save();
        }
    }

    private isReactComponent(node: t.ClassDeclaration): boolean {
        if (!node.superClass) return false;
        
        if (t.isMemberExpression(node.superClass)) {
            return (
                t.isIdentifier(node.superClass.object, { name: 'React' }) &&
                t.isIdentifier(node.superClass.property, { name: 'Component' })
            );
        }
        
        return t.isIdentifier(node.superClass, { name: 'Component' });
    }

    private convertToFunctional(classNode: t.ClassDeclaration): t.Node {
        const componentName = classNode.id?.name || 'Component';
        const { state, methods, lifecycle, render } = this.analyzeClass(classNode);

        // í•¨ìˆ˜í˜• ì»´í¬ë„ŒíŠ¸ ìƒì„±
        const params = [t.identifier('props')];
        const body = [];

        // Stateë¥¼ useStateë¡œ ë³€í™˜
        if (state) {
            body.push(...this.convertStateToHooks(state));
        }

        // Lifecycle ë©”ì„œë“œë¥¼ useEffectë¡œ ë³€í™˜
        if (lifecycle.length > 0) {
            body.push(...this.convertLifecycleToHooks(lifecycle));
        }

        // ë©”ì„œë“œë¥¼ í•¨ìˆ˜ë¡œ ë³€í™˜
        methods.forEach(method => {
            body.push(this.convertMethodToFunction(method));
        });

        // render ë©”ì„œë“œì˜ ë‚´ìš© ì¶”ê°€
        if (render) {
            body.push(...this.extractRenderBody(render));
        }

        // í•¨ìˆ˜í˜• ì»´í¬ë„ŒíŠ¸ ìƒì„±
        return t.functionDeclaration(
            t.identifier(componentName),
            params,
            t.blockStatement(body)
        );
    }

    private analyzeClass(classNode: t.ClassDeclaration) {
        const state = this.extractState(classNode);
        const methods = [];
        const lifecycle = [];
        let render = null;

        classNode.body.body.forEach(member => {
            if (t.isClassMethod(member)) {
                const methodName = (member.key as t.Identifier).name;
                
                if (methodName === 'render') {
                    render = member;
                } else if (this.isLifecycleMethod(methodName)) {
                    lifecycle.push(member);
                } else {
                    methods.push(member);
                }
            }
        });

        return { state, methods, lifecycle, render };
    }

    private convertStateToHooks(state: any): t.Statement[] {
        const statements = [];
        
        Object.entries(state).forEach(([key, value]) => {
            const stateVar = t.identifier(key);
            const setterName = `set${key.charAt(0).toUpperCase()}${key.slice(1)}`;
            const setter = t.identifier(setterName);
            
            // const [state, setState] = useState(initialValue);
            statements.push(
                t.variableDeclaration('const', [
                    t.variableDeclarator(
                        t.arrayPattern([stateVar, setter]),
                        t.callExpression(
                            t.identifier('useState'),
                            [this.valueToAST(value)]
                        )
                    )
                ])
            );
        });

        return statements;
    }

    private convertLifecycleToHooks(lifecycle: t.ClassMethod[]): t.Statement[] {
        const statements = [];

        lifecycle.forEach(method => {
            const methodName = (method.key as t.Identifier).name;
            
            switch (methodName) {
                case 'componentDidMount':
                    statements.push(
                        t.expressionStatement(
                            t.callExpression(t.identifier('useEffect'), [
                                t.arrowFunctionExpression(
                                    [],
                                    method.body
                                ),
                                t.arrayExpression([]) // ë¹ˆ ì˜ì¡´ì„± ë°°ì—´
                            ])
                        )
                    );
                    break;
                    
                case 'componentDidUpdate':
                    statements.push(
                        t.expressionStatement(
                            t.callExpression(t.identifier('useEffect'), [
                                t.arrowFunctionExpression(
                                    [],
                                    method.body
                                )
                                // ì˜ì¡´ì„± ë°°ì—´ ì—†ìŒ - ëª¨ë“  ì—…ë°ì´íŠ¸ì—ì„œ ì‹¤í–‰
                            ])
                        )
                    );
                    break;
                    
                case 'componentWillUnmount':
                    // useEffect cleanupìœ¼ë¡œ ë³€í™˜
                    statements.push(
                        t.expressionStatement(
                            t.callExpression(t.identifier('useEffect'), [
                                t.arrowFunctionExpression(
                                    [],
                                    t.blockStatement([
                                        t.returnStatement(
                                            t.arrowFunctionExpression(
                                                [],
                                                method.body
                                            )
                                        )
                                    ])
                                ),
                                t.arrayExpression([])
                            ])
                        )
                    );
                    break;
            }
        });

        return statements;
    }

    private async optimizeWithAI(code: string, filePath: string): Promise<string> {
        const prompt = `
React í•¨ìˆ˜í˜• ì»´í¬ë„ŒíŠ¸ë¡œ ë³€í™˜ëœ ì½”ë“œë¥¼ ìµœì í™”í•´ì£¼ì„¸ìš”:

íŒŒì¼: ${filePath}
ì½”ë“œ:
\`\`\`typescript
${code}
\`\`\`

ë‹¤ìŒ ì‚¬í•­ì„ ê°œì„ í•´ì£¼ì„¸ìš”:
1. ë¶ˆí•„ìš”í•œ re-renderë¥¼ ë°©ì§€í•˜ê¸° ìœ„í•œ useMemo, useCallback ì‚¬ìš©
2. ì»¤ìŠ¤í…€ í›…ìœ¼ë¡œ ë¡œì§ ë¶„ë¦¬
3. TypeScript íƒ€ì… ê°œì„ 
4. ì½”ë“œ ê°€ë…ì„± í–¥ìƒ
5. React ìµœì‹  íŒ¨í„´ ì ìš©
`;

        const optimizedCode = await this.cursor.ai.generateCode(prompt);
        return optimizedCode;
    }

    private generateReport(): MigrationReport {
        return {
            summary: {
                totalComponents: this.migrationStats.totalComponents,
                migratedComponents: this.migrationStats.migratedComponents,
                failedComponents: this.migrationStats.totalComponents - this.migrationStats.migratedComponents,
                successRate: (this.migrationStats.migratedComponents / this.migrationStats.totalComponents * 100).toFixed(2) + '%'
            },
            errors: this.migrationStats.errors,
            warnings: this.migrationStats.warnings,
            recommendations: this.generateRecommendations()
        };
    }

    private generateRecommendations(): string[] {
        const recommendations = [];
        
        if (this.migrationStats.warnings.length > 0) {
            recommendations.push(
                'ì¼ë¶€ ì»´í¬ë„ŒíŠ¸ëŠ” ìˆ˜ë™ ê²€í† ê°€ í•„ìš”í•©ë‹ˆë‹¤. íŠ¹íˆ ë³µì¡í•œ ìƒëª…ì£¼ê¸° ë¡œì§ì´ë‚˜ HOCë¥¼ ì‚¬ìš©í•˜ëŠ” ê²½ìš°ì…ë‹ˆë‹¤.'
            );
        }
        
        recommendations.push(
            'React.memo()ë¥¼ ì‚¬ìš©í•˜ì—¬ ì„±ëŠ¥ ìµœì í™”ë¥¼ ê³ ë ¤í•˜ì„¸ìš”.',
            'ì»¤ìŠ¤í…€ í›…ì„ ë§Œë“¤ì–´ ë¡œì§ì„ ì¬ì‚¬ìš©í•˜ì„¸ìš”.',
            'Suspenseì™€ Error Boundariesë¥¼ ë„ì…í•˜ì—¬ ì—ëŸ¬ ì²˜ë¦¬ë¥¼ ê°œì„ í•˜ì„¸ìš”.'
        );
        
        return recommendations;
    }
}

// ëŒ€ê·œëª¨ ë¦¬íŒ©í† ë§ ë„êµ¬
export class LargeScaleRefactoringTool {
    private cursor: CursorAI;
    private project: Project;
    private refactoringPlan: RefactoringPlan;

    constructor(projectPath: string) {
        this.cursor = new CursorAI();
        this.project = new Project({
            tsConfigFilePath: `${projectPath}/tsconfig.json`
        });
    }

    async planRefactoring(goals: RefactoringGoals): Promise<RefactoringPlan> {
        // AIë¡œ ë¦¬íŒ©í† ë§ ê³„íš ìƒì„±
        const prompt = `
í”„ë¡œì íŠ¸ ë¦¬íŒ©í† ë§ ê³„íšì„ ìˆ˜ë¦½í•´ì£¼ì„¸ìš”:

ëª©í‘œ:
${JSON.stringify(goals, null, 2)}

í”„ë¡œì íŠ¸ êµ¬ì¡°:
${this.getProjectStructure()}

ë‹¤ìŒì„ í¬í•¨í•œ ìƒì„¸í•œ ê³„íšì„ ì‘ì„±í•´ì£¼ì„¸ìš”:
1. ë¦¬íŒ©í† ë§ ë‹¨ê³„ë³„ ìˆœì„œ
2. ê° ë‹¨ê³„ì˜ ìœ„í—˜ë„ í‰ê°€
3. ë¡¤ë°± ì „ëµ
4. í…ŒìŠ¤íŠ¸ ê³„íš
5. ì˜ˆìƒ ì†Œìš” ì‹œê°„
`;

        const planResponse = await this.cursor.ai.generateCode(prompt);
        this.refactoringPlan = JSON.parse(planResponse);
        
        return this.refactoringPlan;
    }

    async executeRefactoring(dryRun: boolean = true): Promise<RefactoringResult> {
        const results: RefactoringResult = {
            stages: [],
            totalChanges: 0,
            success: true,
            rollbackPoints: []
        };

        for (const stage of this.refactoringPlan.stages) {
            console.log(`ğŸ”§ ${stage.name} ì‹¤í–‰ ì¤‘...`);
            
            // ë¡¤ë°± í¬ì¸íŠ¸ ìƒì„±
            if (!dryRun) {
                const rollbackPoint = await this.createRollbackPoint(stage.name);
                results.rollbackPoints.push(rollbackPoint);
            }

            try {
                const stageResult = await this.executeStage(stage, dryRun);
                results.stages.push(stageResult);
                results.totalChanges += stageResult.changedFiles;
                
                // í…ŒìŠ¤íŠ¸ ì‹¤í–‰
                if (!dryRun && stage.runTests) {
                    const testResult = await this.runTests();
                    if (!testResult.success) {
                        throw new Error(`í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨: ${testResult.failedTests.join(', ')}`);
                    }
                }
            } catch (error) {
                results.success = false;
                if (!dryRun) {
                    await this.rollback(results.rollbackPoints[results.rollbackPoints.length - 1]);
                }
                throw error;
            }
        }

        return results;
    }

    private async executeStage(stage: RefactoringStage, dryRun: boolean): Promise<StageResult> {
        const result: StageResult = {
            name: stage.name,
            changedFiles: 0,
            changes: [],
            duration: 0
        };

        const startTime = Date.now();

        switch (stage.type) {
            case 'rename':
                result.changes = await this.executeRename(stage.config, dryRun);
                break;
                
            case 'extract':
                result.changes = await this.executeExtraction(stage.config, dryRun);
                break;
                
            case 'move':
                result.changes = await this.executeMove(stage.config, dryRun);
                break;
                
            case 'pattern-replace':
                result.changes = await this.executePatternReplace(stage.config, dryRun);
                break;
                
            case 'architecture-change':
                result.changes = await this.executeArchitectureChange(stage.config, dryRun);
                break;
        }

        result.changedFiles = result.changes.length;
        result.duration = Date.now() - startTime;

        return result;
    }

    private async executeRename(config: RenameConfig, dryRun: boolean): Promise<Change[]> {
        const changes: Change[] = [];
        
        // ì‹¬ë³¼ ì°¾ê¸°
        const sourceFiles = this.project.getSourceFiles();
        
        for (const file of sourceFiles) {
            const symbols = file.getDescendantsOfKind(SyntaxKind.Identifier)
                .filter(id => id.getText() === config.oldName);
                
            for (const symbol of symbols) {
                const references = symbol.findReferences();
                
                for (const ref of references) {
                    for (const refEntry of ref.getReferences()) {
                        changes.push({
                            file: refEntry.getSourceFile().getFilePath(),
                            position: refEntry.getTextSpan().getStart(),
                            oldText: config.oldName,
                            newText: config.newName,
                            type: 'rename'
                        });
                        
                        if (!dryRun) {
                            refEntry.getNode().replaceWithText(config.newName);
                        }
                    }
                }
            }
        }
        
        return changes;
    }

    private async executePatternReplace(config: PatternReplaceConfig, dryRun: boolean): Promise<Change[]> {
        const changes: Change[] = [];
        
        // AIë¡œ íŒ¨í„´ ë§¤ì¹­ ë° ë³€í™˜
        const prompt = `
ë‹¤ìŒ ì½”ë“œ íŒ¨í„´ì„ ì°¾ì•„ì„œ ë³€í™˜í•´ì£¼ì„¸ìš”:

ì°¾ì„ íŒ¨í„´:
${config.searchPattern}

ë³€í™˜í•  íŒ¨í„´:
${config.replacePattern}

ì˜ˆì‹œ:
${config.examples?.map(ex => `
ì´ì „: ${ex.before}
ì´í›„: ${ex.after}
`).join('\n')}

AST ë³€í™˜ ì½”ë“œë¥¼ ìƒì„±í•´ì£¼ì„¸ìš”.
`;

        const transformCode = await this.cursor.ai.generateCode(prompt);
        
        // ìƒì„±ëœ ë³€í™˜ ì½”ë“œ ì‹¤í–‰
        const transform = eval(transformCode);
        
        const files = this.project.getSourceFiles(config.filePattern || '**/*.{ts,tsx}');
        
        for (const file of files) {
            const ast = file.compilerNode;
            const transformedAst = transform(ast);
            
            if (transformedAst !== ast) {
                changes.push({
                    file: file.getFilePath(),
                    type: 'pattern-replace',
                    description: `íŒ¨í„´ "${config.searchPattern}" â†’ "${config.replacePattern}"`
                });
                
                if (!dryRun) {
                    file.replaceWithText(transformedAst.getFullText());
                }
            }
        }
        
        return changes;
    }

    private async executeArchitectureChange(config: ArchitectureChangeConfig, dryRun: boolean): Promise<Change[]> {
        const changes: Change[] = [];
        
        // ì•„í‚¤í…ì²˜ ë³€ê²½ì€ ë³µì¡í•˜ë¯€ë¡œ AIì˜ ë„ì›€ì„ ë°›ì•„ ê³„íš ìˆ˜ë¦½
        const prompt = `
ë‹¤ìŒ ì•„í‚¤í…ì²˜ ë³€ê²½ì„ ìˆ˜í–‰í•˜ëŠ” ì½”ë“œë¥¼ ìƒì„±í•´ì£¼ì„¸ìš”:

í˜„ì¬ ì•„í‚¤í…ì²˜: ${config.from}
ëª©í‘œ ì•„í‚¤í…ì²˜: ${config.to}

ë³€ê²½ ì‚¬í•­:
${config.changes.map(c => `- ${c}`).join('\n')}

ë‹¤ìŒì„ í¬í•¨í•´ì£¼ì„¸ìš”:
1. íŒŒì¼ ì´ë™ ê³„íš
2. ì¸í„°í˜ì´ìŠ¤ ë³€ê²½
3. ì˜ì¡´ì„± ì—…ë°ì´íŠ¸
4. ì ì§„ì  ë§ˆì´ê·¸ë ˆì´ì…˜ ì½”ë“œ
`;

        const migrationPlan = await this.cursor.ai.generateCode(prompt);
        
        // ê³„íš ì‹¤í–‰
        const plan = JSON.parse(migrationPlan);
        
        // 1. ìƒˆë¡œìš´ êµ¬ì¡° ìƒì„±
        if (!dryRun) {
            for (const dir of plan.newDirectories) {
                await this.project.createDirectory(dir);
            }
        }
        
        // 2. íŒŒì¼ ì´ë™ ë° ë³€í™˜
        for (const fileMove of plan.fileMoves) {
            const sourceFile = this.project.getSourceFile(fileMove.from);
            if (sourceFile) {
                changes.push({
                    file: fileMove.from,
                    type: 'move',
                    description: `${fileMove.from} â†’ ${fileMove.to}`
                });
                
                if (!dryRun) {
                    // ë‚´ìš© ë³€í™˜
                    const transformedContent = await this.transformFileForNewArchitecture(
                        sourceFile.getFullText(),
                        fileMove.transformations
                    );
                    
                    // ìƒˆ ìœ„ì¹˜ì— íŒŒì¼ ìƒì„±
                    this.project.createSourceFile(fileMove.to, transformedContent);
                    
                    // ê¸°ì¡´ íŒŒì¼ ì‚­ì œ
                    sourceFile.delete();
                }
            }
        }
        
        // 3. ì˜ì¡´ì„± ì—…ë°ì´íŠ¸
        await this.updateDependencies(plan.dependencies, dryRun);
        
        return changes;
    }

    private async transformFileForNewArchitecture(content: string, transformations: any[]): Promise<string> {
        let transformedContent = content;
        
        for (const transformation of transformations) {
            const prompt = `
ë‹¤ìŒ ì½”ë“œë¥¼ ${transformation.description}ì— ë§ê²Œ ë³€í™˜í•´ì£¼ì„¸ìš”:

\`\`\`typescript
${transformedContent}
\`\`\`

ë³€í™˜ ê·œì¹™:
${JSON.stringify(transformation.rules, null, 2)}
`;

            transformedContent = await this.cursor.ai.generateCode(prompt);
        }
        
        return transformedContent;
    }

    private async createRollbackPoint(name: string): Promise<RollbackPoint> {
        // Git stash ë˜ëŠ” ë¸Œëœì¹˜ ìƒì„±
        const timestamp = new Date().toISOString();
        const rollbackId = `rollback_${name}_${timestamp}`;
        
        // í˜„ì¬ ìƒíƒœ ì €ì¥
        await this.executeCommand(`git stash save "${rollbackId}"`);
        
        return {
            id: rollbackId,
            name,
            timestamp,
            files: await this.getModifiedFiles()
        };
    }

    private async rollback(rollbackPoint: RollbackPoint): Promise<void> {
        console.log(`âª ${rollbackPoint.name}ìœ¼ë¡œ ë¡¤ë°± ì¤‘...`);
        await this.executeCommand(`git stash pop`);
    }

    private async runTests(): Promise<TestResult> {
        // í”„ë¡œì íŠ¸ì˜ í…ŒìŠ¤íŠ¸ ëª…ë ¹ ì‹¤í–‰
        try {
            const output = await this.executeCommand('npm test');
            return {
                success: true,
                output,
                failedTests: []
            };
        } catch (error) {
            return {
                success: false,
                output: error.message,
                failedTests: this.parseFailedTests(error.message)
            };
        }
    }

    private async executeCommand(command: string): Promise<string> {
        const { exec } = require('child_process');
        const { promisify } = require('util');
        const execAsync = promisify(exec);
        
        const { stdout } = await execAsync(command);
        return stdout;
    }
}

// ë§ˆì´ê·¸ë ˆì´ì…˜ ì „ëµ ìƒì„±ê¸°
export class MigrationStrategyGenerator {
    private cursor: CursorAI;

    constructor() {
        this.cursor = new CursorAI();
    }

    async generateStrategy(config: MigrationConfig): Promise<MigrationStrategy> {
        const prompt = `
ë‹¤ìŒ ë§ˆì´ê·¸ë ˆì´ì…˜ì„ ìœ„í•œ ìƒì„¸í•œ ì „ëµì„ ìˆ˜ë¦½í•´ì£¼ì„¸ìš”:

í˜„ì¬ ìƒíƒœ:
- ê¸°ìˆ  ìŠ¤íƒ: ${config.currentStack.join(', ')}
- ì½”ë“œë² ì´ìŠ¤ í¬ê¸°: ${config.codebaseSize}
- íŒ€ ê·œëª¨: ${config.teamSize}
- ì¼ì¼ í™œì„± ì‚¬ìš©ì: ${config.dailyActiveUsers}

ëª©í‘œ ìƒíƒœ:
- ê¸°ìˆ  ìŠ¤íƒ: ${config.targetStack.join(', ')}
- ëª©í‘œ ê¸°í•œ: ${config.deadline}

ì œì•½ ì‚¬í•­:
${config.constraints.map(c => `- ${c}`).join('\n')}

ë‹¤ìŒì„ í¬í•¨í•œ ì „ëµì„ ì œì‹œí•´ì£¼ì„¸ìš”:
1. ë‹¨ê³„ë³„ ë§ˆì´ê·¸ë ˆì´ì…˜ ê³„íš
2. ê° ë‹¨ê³„ì˜ ë¦¬ìŠ¤í¬ í‰ê°€
3. ë³‘ë ¬ ì‹¤í–‰ vs ì ì§„ì  ì‹¤í–‰ ì „ëµ
4. ê¸°ëŠ¥ í”Œë˜ê·¸ ì‚¬ìš© ê³„íš
5. ë¡¤ë°± ê³„íš
6. ëª¨ë‹ˆí„°ë§ ë° ê²€ì¦ ë°©ë²•
`;

        const strategyResponse = await this.cursor.ai.generateCode(prompt);
        const strategy = JSON.parse(strategyResponse);

        // ì „ëµ ê²€ì¦
        strategy.validationReport = await this.validateStrategy(strategy, config);
        
        return strategy;
    }

    private async validateStrategy(strategy: MigrationStrategy, config: MigrationConfig): Promise<ValidationReport> {
        const report: ValidationReport = {
            feasible: true,
            risks: [],
            recommendations: []
        };

        // ê¸°í•œ ì‹¤í˜„ ê°€ëŠ¥ì„± ê²€ì¦
        const estimatedDuration = this.estimateDuration(strategy);
        if (estimatedDuration > config.deadline) {
            report.feasible = false;
            report.risks.push({
                level: 'high',
                description: `ì˜ˆìƒ ì†Œìš” ì‹œê°„(${estimatedDuration}ì¼)ì´ ëª©í‘œ ê¸°í•œì„ ì´ˆê³¼í•©ë‹ˆë‹¤.`
            });
        }

        // ë¦¬ì†ŒìŠ¤ ê²€ì¦
        const requiredResources = this.calculateRequiredResources(strategy);
        if (requiredResources.developers > config.teamSize) {
            report.risks.push({
                level: 'medium',
                description: `í•„ìš”í•œ ê°œë°œì ìˆ˜(${requiredResources.developers})ê°€ í˜„ì¬ íŒ€ ê·œëª¨ë¥¼ ì´ˆê³¼í•©ë‹ˆë‹¤.`
            });
        }

        // ë‹¤ìš´íƒ€ì„ ë¦¬ìŠ¤í¬ í‰ê°€
        if (strategy.requiresDowntime && config.dailyActiveUsers > 10000) {
            report.risks.push({
                level: 'high',
                description: 'ë†’ì€ ì‚¬ìš©ì ìˆ˜ë¡œ ì¸í•´ ë‹¤ìš´íƒ€ì„ì´ ë¹„ì¦ˆë‹ˆìŠ¤ì— í° ì˜í–¥ì„ ì¤„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.'
            });
            report.recommendations.push('ë¸”ë£¨-ê·¸ë¦° ë°°í¬ ë˜ëŠ” ì¹´ë‚˜ë¦¬ ë°°í¬ ì „ëµì„ ê³ ë ¤í•˜ì„¸ìš”.');
        }

        return report;
    }

    private estimateDuration(strategy: MigrationStrategy): number {
        return strategy.phases.reduce((total, phase) => {
            return total + phase.estimatedDays;
        }, 0);
    }

    private calculateRequiredResources(strategy: MigrationStrategy): RequiredResources {
        const maxConcurrentTasks = Math.max(...strategy.phases.map(p => p.tasks.length));
        
        return {
            developers: Math.ceil(maxConcurrentTasks / 2), // 2 tasks per developer
            qaEngineers: Math.ceil(maxConcurrentTasks / 4), // 4 tasks per QA
            devOpsEngineers: strategy.phases.some(p => p.requiresInfraChange) ? 2 : 1
        };
    }
}
</code></pre>
                    </div>
                </div>

                <h3>ì ì§„ì  ë§ˆì´ê·¸ë ˆì´ì…˜ íŒ¨í„´</h3>
                <div class="gradual-migration">
                    <div class="migration-patterns">
                        <h4>Strangler Fig íŒ¨í„´ êµ¬í˜„</h4>
                        <pre><code>// patterns/StranglerFigPattern.ts
export class StranglerFigMigration {
    private oldSystem: LegacySystem;
    private newSystem: ModernSystem;
    private router: TrafficRouter;
    private featureFlags: FeatureFlagService;

    constructor(config: StranglerConfig) {
        this.oldSystem = config.oldSystem;
        this.newSystem = config.newSystem;
        this.router = new TrafficRouter();
        this.featureFlags = new FeatureFlagService();
    }

    async migrateFeature(featureName: string): Promise<void> {
        // 1. ìƒˆ ì‹œìŠ¤í…œì— ê¸°ëŠ¥ êµ¬í˜„
        console.log(`ğŸ”¨ ${featureName} ê¸°ëŠ¥ì„ ìƒˆ ì‹œìŠ¤í…œì— êµ¬í˜„ ì¤‘...`);
        await this.implementInNewSystem(featureName);

        // 2. ê¸°ëŠ¥ í”Œë˜ê·¸ë¡œ íŠ¸ë˜í”½ ì ì§„ì  ì´ë™
        console.log(`ğŸš¦ íŠ¸ë˜í”½ ë¼ìš°íŒ… ì‹œì‘...`);
        await this.setupProgressiveRollout(featureName);

        // 3. ëª¨ë‹ˆí„°ë§ ë° ê²€ì¦
        console.log(`ğŸ“Š ì„±ëŠ¥ ë° ì •í™•ì„± ëª¨ë‹ˆí„°ë§...`);
        await this.monitorAndValidate(featureName);

        // 4. êµ¬ ì‹œìŠ¤í…œì—ì„œ ê¸°ëŠ¥ ì œê±°
        console.log(`ğŸ—‘ï¸ ë ˆê±°ì‹œ ì½”ë“œ ì œê±°...`);
        await this.decommissionOldFeature(featureName);
    }

    private async implementInNewSystem(featureName: string): Promise<void> {
        const legacyCode = await this.oldSystem.getFeatureCode(featureName);
        
        // AIë¡œ í˜„ëŒ€ì ì¸ ì½”ë“œë¡œ ë³€í™˜
        const prompt = `
ë ˆê±°ì‹œ ì½”ë“œë¥¼ í˜„ëŒ€ì ì¸ íŒ¨í„´ìœ¼ë¡œ ì¬êµ¬í˜„í•´ì£¼ì„¸ìš”:

ë ˆê±°ì‹œ ì½”ë“œ:
\`\`\`
${legacyCode}
\`\`\`

ìš”êµ¬ì‚¬í•­:
- TypeScript ì‚¬ìš©
- ì˜ì¡´ì„± ì£¼ì… íŒ¨í„´ ì ìš©
- ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ ê°€ëŠ¥í•œ êµ¬ì¡°
- ë¹„ë™ê¸°/ëŒ€ê¸° íŒ¨í„´ ì‚¬ìš©
- ì—ëŸ¬ ì²˜ë¦¬ ê°œì„ 
`;

        const modernCode = await this.cursor.ai.generateCode(prompt);
        await this.newSystem.deployFeature(featureName, modernCode);
    }

    private async setupProgressiveRollout(featureName: string): Promise<void> {
        // ì ì§„ì  ë¡¤ì•„ì›ƒ ì„¤ì •
        const rolloutPlan = [
            { percentage: 1, duration: '1h', description: 'ì¹´ë‚˜ë¦¬ í…ŒìŠ¤íŠ¸' },
            { percentage: 5, duration: '6h', description: 'ì´ˆê¸° ê²€ì¦' },
            { percentage: 25, duration: '24h', description: 'ë¶€ë¶„ ë¡¤ì•„ì›ƒ' },
            { percentage: 50, duration: '48h', description: 'ì ˆë°˜ ë¡¤ì•„ì›ƒ' },
            { percentage: 100, duration: 'permanent', description: 'ì „ì²´ ë¡¤ì•„ì›ƒ' }
        ];

        for (const stage of rolloutPlan) {
            await this.featureFlags.setRolloutPercentage(featureName, stage.percentage);
            
            // ë¼ìš°íŒ… ê·œì¹™ ì—…ë°ì´íŠ¸
            this.router.updateRule({
                feature: featureName,
                condition: (request) => {
                    const userId = request.userId;
                    const bucket = this.hashUserId(userId) % 100;
                    return bucket < stage.percentage;
                },
                target: this.newSystem
            });

            // ëª¨ë‹ˆí„°ë§ ê¸°ê°„ ëŒ€ê¸°
            if (stage.duration !== 'permanent') {
                await this.waitAndMonitor(stage.duration);
                
                // ë¬¸ì œ ë°œìƒ ì‹œ ë¡¤ë°±
                const metrics = await this.collectMetrics(featureName);
                if (!this.meetsQualityCriteria(metrics)) {
                    await this.rollback(featureName);
                    throw new Error(`í’ˆì§ˆ ê¸°ì¤€ ë¯¸ë‹¬: ${JSON.stringify(metrics)}`);
                }
            }
        }
    }

    private async monitorAndValidate(featureName: string): Promise<void> {
        const monitoring = new MonitoringService();
        
        // ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ ì„¤ì •
        monitoring.track({
            feature: featureName,
            metrics: [
                'response_time',
                'error_rate',
                'throughput',
                'cpu_usage',
                'memory_usage'
            ],
            alerts: [
                {
                    condition: 'error_rate > 0.01',
                    action: 'notify',
                    severity: 'warning'
                },
                {
                    condition: 'response_time > old_system_p99 * 1.1',
                    action: 'rollback',
                    severity: 'critical'
                }
            ]
        });

        // ë°ì´í„° ì¼ê´€ì„± ê²€ì¦
        const validator = new DataConsistencyValidator();
        const validationResult = await validator.compare(
            this.oldSystem,
            this.newSystem,
            featureName
        );

        if (!validationResult.isConsistent) {
            console.error('âŒ ë°ì´í„° ë¶ˆì¼ì¹˜ ë°œê²¬:', validationResult.differences);
            await this.reconcileData(validationResult.differences);
        }
    }

    private async decommissionOldFeature(featureName: string): Promise<void> {
        // ì•ˆì „í•œ ì œê±°ë¥¼ ìœ„í•œ ë‹¨ê³„
        
        // 1. ë” ì´ìƒ ì‚¬ìš©ë˜ì§€ ì•ŠìŒ í‘œì‹œ
        await this.oldSystem.markAsDeprecated(featureName);
        
        // 2. ì¼ì • ê¸°ê°„ ëŒ€ê¸° (í˜¹ì‹œ ëª¨ë¥¼ ë¡¤ë°±ì„ ìœ„í•´)
        await this.wait('7d');
        
        // 3. ì½”ë“œ ì œê±°
        const removalPlan = await this.generateRemovalPlan(featureName);
        
        for (const step of removalPlan.steps) {
            console.log(`ğŸ§¹ ${step.description}`);
            await step.execute();
            
            // ê° ë‹¨ê³„ í›„ ì‹œìŠ¤í…œ ì •ìƒ ì‘ë™ í™•ì¸
            const healthCheck = await this.oldSystem.healthCheck();
            if (!healthCheck.healthy) {
                throw new Error(`ì‹œìŠ¤í…œ í—¬ìŠ¤ì²´í¬ ì‹¤íŒ¨: ${healthCheck.errors}`);
            }
        }
        
        // 4. ê´€ë ¨ ì¸í”„ë¼ ì •ë¦¬
        await this.cleanupInfrastructure(featureName);
    }

    private async generateRemovalPlan(featureName: string): Promise<RemovalPlan> {
        const dependencies = await this.analyzeDependencies(featureName);
        
        const prompt = `
ë‹¤ìŒ ê¸°ëŠ¥ì„ ì•ˆì „í•˜ê²Œ ì œê±°í•˜ëŠ” ê³„íšì„ ìˆ˜ë¦½í•´ì£¼ì„¸ìš”:

ê¸°ëŠ¥: ${featureName}
ì˜ì¡´ì„±: ${JSON.stringify(dependencies)}

ì•ˆì „í•œ ì œê±°ë¥¼ ìœ„í•´:
1. ì œê±° ìˆœì„œ ê²°ì •
2. ê° ë‹¨ê³„ë³„ ê²€ì¦ ë°©ë²•
3. ë¶€ì‘ìš© ìµœì†Œí™” ë°©ì•ˆ
`;

        const plan = await this.cursor.ai.generateCode(prompt);
        return JSON.parse(plan);
    }
}

// ì½”ë“œë² ì´ìŠ¤ ë¶„ì„ ë„êµ¬
export class CodebaseAnalyzer {
    async analyzeForMigration(projectPath: string): Promise<AnalysisReport> {
        const report: AnalysisReport = {
            statistics: await this.gatherStatistics(projectPath),
            dependencies: await this.analyzeDependencies(projectPath),
            complexity: await this.measureComplexity(projectPath),
            testCoverage: await this.getTestCoverage(projectPath),
            technicalDebt: await this.assessTechnicalDebt(projectPath),
            migrationCandidates: [],
            estimatedEffort: 0
        };

        // AIë¡œ ë§ˆì´ê·¸ë ˆì´ì…˜ í›„ë³´ ì‹ë³„
        report.migrationCandidates = await this.identifyMigrationCandidates(report);
        report.estimatedEffort = await this.estimateEffort(report);

        return report;
    }

    private async identifyMigrationCandidates(analysis: Partial<AnalysisReport>): Promise<MigrationCandidate[]> {
        const prompt = `
ì½”ë“œë² ì´ìŠ¤ ë¶„ì„ ê²°ê³¼ë¥¼ ë°”íƒ•ìœ¼ë¡œ ë§ˆì´ê·¸ë ˆì´ì…˜ ìš°ì„ ìˆœìœ„ë¥¼ ì •í•´ì£¼ì„¸ìš”:

í†µê³„: ${JSON.stringify(analysis.statistics)}
ë³µì¡ë„: ${JSON.stringify(analysis.complexity)}
ê¸°ìˆ  ë¶€ì±„: ${JSON.stringify(analysis.technicalDebt)}

ë‹¤ìŒ ê¸°ì¤€ìœ¼ë¡œ í‰ê°€í•´ì£¼ì„¸ìš”:
1. ë¹„ì¦ˆë‹ˆìŠ¤ ì˜í–¥ë„
2. ê¸°ìˆ ì  ë³µì¡ë„
3. ì˜ì¡´ì„±
4. ë¦¬ìŠ¤í¬
5. ì˜ˆìƒ ROI

ê° í›„ë³´ì— ëŒ€í•´ ì ìˆ˜(1-10)ì™€ ê·¼ê±°ë¥¼ ì œì‹œí•´ì£¼ì„¸ìš”.
`;

        const candidates = await this.cursor.ai.generateCode(prompt);
        return JSON.parse(candidates);
    }
}
</code></pre>
                    </div>
                </div>
            </section>

            <section class="content-section">
                <h2><i class="fas fa-sync-alt"></i> ì•ˆì „í•œ ë¦¬íŒ©í† ë§ ì „ëµ</h2>
                
                <h3>ìë™í™”ëœ ë¦¬íŒ©í† ë§ ê²€ì¦</h3>
                <div class="refactoring-validation">
                    <div class="validation-implementation">
                        <h4>ë¦¬íŒ©í† ë§ ì•ˆì „ì„± ê²€ì¦ ì‹œìŠ¤í…œ</h4>
                        <pre><code>// validation/RefactoringValidator.ts
export class RefactoringValidator {
    private cursor: CursorAI;
    private testRunner: TestRunner;
    private performanceProfiler: PerformanceProfiler;

    async validateRefactoring(
        before: CodeSnapshot,
        after: CodeSnapshot
    ): Promise<ValidationResult> {
        const result: ValidationResult = {
            behaviorPreserved: true,
            performanceImpact: 'neutral',
            issues: [],
            suggestions: []
        };

        // 1. ë™ì‘ ë³´ì¡´ ê²€ì¦
        console.log('ğŸ§ª ë™ì‘ ë³´ì¡´ í…ŒìŠ¤íŠ¸...');
        const behaviorTest = await this.testBehaviorPreservation(before, after);
        result.behaviorPreserved = behaviorTest.passed;
        result.issues.push(...behaviorTest.issues);

        // 2. ì„±ëŠ¥ ì˜í–¥ ë¶„ì„
        console.log('âš¡ ì„±ëŠ¥ ì˜í–¥ ë¶„ì„...');
        const perfAnalysis = await this.analyzePerformanceImpact(before, after);
        result.performanceImpact = perfAnalysis.impact;
        
        // 3. ì‹œë§¨í‹± ë™ë“±ì„± ê²€ì¦
        console.log('ğŸ” ì‹œë§¨í‹± ë¶„ì„...');
        const semanticAnalysis = await this.verifySemanticEquivalence(before, after);
        result.issues.push(...semanticAnalysis.issues);

        // 4. íƒ€ì… ì•ˆì „ì„± ê²€ì¦
        console.log('ğŸ“ íƒ€ì… ì•ˆì „ì„± ê²€ì¦...');
        const typeCheck = await this.verifyTypeSafety(after);
        result.issues.push(...typeCheck.issues);

        // 5. AI ê¸°ë°˜ ê°œì„  ì œì•ˆ
        result.suggestions = await this.generateImprovementSuggestions(after);

        return result;
    }

    private async testBehaviorPreservation(
        before: CodeSnapshot,
        after: CodeSnapshot
    ): Promise<BehaviorTestResult> {
        // ì†ì„± ê¸°ë°˜ í…ŒìŠ¤íŠ¸ ìƒì„±
        const propertyTests = await this.generatePropertyTests(before);
        
        // ìŠ¤ëƒ…ìƒ· í…ŒìŠ¤íŠ¸
        const snapshotTests = await this.generateSnapshotTests(before);
        
        // ì–‘ìª½ ì½”ë“œì— ëŒ€í•´ í…ŒìŠ¤íŠ¸ ì‹¤í–‰
        const beforeResults = await this.runTests([...propertyTests, ...snapshotTests], before);
        const afterResults = await this.runTests([...propertyTests, ...snapshotTests], after);
        
        // ê²°ê³¼ ë¹„êµ
        const issues = this.compareTestResults(beforeResults, afterResults);
        
        return {
            passed: issues.length === 0,
            issues,
            coverage: afterResults.coverage
        };
    }

    private async generatePropertyTests(code: CodeSnapshot): Promise<Test[]> {
        const prompt = `
ë‹¤ìŒ ì½”ë“œì— ëŒ€í•œ ì†ì„± ê¸°ë°˜ í…ŒìŠ¤íŠ¸ë¥¼ ìƒì„±í•´ì£¼ì„¸ìš”:

\`\`\`typescript
${code.content}
\`\`\`

fast-check ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì‚¬ìš©í•˜ì—¬:
1. í•¨ìˆ˜ì˜ ë¶ˆë³€ì„± í…ŒìŠ¤íŠ¸
2. ì…ì¶œë ¥ ê´€ê³„ í…ŒìŠ¤íŠ¸
3. ì—ì§€ ì¼€ì´ìŠ¤ í…ŒìŠ¤íŠ¸
4. ì„±ëŠ¥ íŠ¹ì„± í…ŒìŠ¤íŠ¸
`;

        const tests = await this.cursor.ai.generateCode(prompt);
        return this.parseTests(tests);
    }

    private async verifySemanticEquivalence(
        before: CodeSnapshot,
        after: CodeSnapshot
    ): Promise<SemanticAnalysis> {
        // ì¶”ìƒ êµ¬ë¬¸ íŠ¸ë¦¬ ë¹„êµ
        const beforeAST = this.parseToAST(before.content);
        const afterAST = this.parseToAST(after.content);
        
        // ì˜ë¯¸ë¡ ì  ì°¨ì´ ë¶„ì„
        const differences = this.compareASTs(beforeAST, afterAST);
        
        const issues = [];
        for (const diff of differences) {
            if (diff.type === 'semantic-change') {
                issues.push({
                    severity: 'warning',
                    message: `ì˜ë¯¸ë¡ ì  ë³€ê²½ ê°ì§€: ${diff.description}`,
                    location: diff.location
                });
            }
        }
        
        return { issues };
    }

    private async generateImprovementSuggestions(code: CodeSnapshot): Promise<Suggestion[]> {
        const prompt = `
ë¦¬íŒ©í† ë§ëœ ì½”ë“œë¥¼ ë¶„ì„í•˜ì—¬ ì¶”ê°€ ê°œì„ ì‚¬í•­ì„ ì œì•ˆí•´ì£¼ì„¸ìš”:

\`\`\`typescript
${code.content}
\`\`\`

ë‹¤ìŒ ê´€ì ì—ì„œ ë¶„ì„:
1. ê°€ë…ì„± ê°œì„ 
2. ì„±ëŠ¥ ìµœì í™” ê¸°íšŒ
3. íƒ€ì… ì•ˆì „ì„± ê°•í™”
4. í…ŒìŠ¤íŠ¸ ìš©ì´ì„± ê°œì„ 
5. ì¬ì‚¬ìš©ì„± ì¦ëŒ€
`;

        const suggestions = await this.cursor.ai.generateCode(prompt);
        return JSON.parse(suggestions);
    }
}

// ë¦¬íŒ©í† ë§ ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´í„°
export class RefactoringOrchestrator {
    private validator: RefactoringValidator;
    private executor: RefactoringExecutor;
    private monitor: RefactoringMonitor;

    async orchestrateRefactoring(plan: RefactoringPlan): Promise<void> {
        // 1. ì‚¬ì „ ê²€ì¦
        await this.preValidation(plan);
        
        // 2. ë°±ì—… ìƒì„±
        const backup = await this.createBackup();
        
        // 3. ë‹¨ê³„ë³„ ì‹¤í–‰
        for (const step of plan.steps) {
            try {
                // ì‹¤í–‰
                await this.executeStep(step);
                
                // ê²€ì¦
                const validation = await this.validator.validateStep(step);
                if (!validation.success) {
                    throw new Error(`ê²€ì¦ ì‹¤íŒ¨: ${validation.errors.join(', ')}`);
                }
                
                // ëª¨ë‹ˆí„°ë§
                await this.monitor.checkHealth();
                
            } catch (error) {
                // ë¡¤ë°±
                await this.rollback(backup);
                throw error;
            }
        }
        
        // 4. ìµœì¢… ê²€ì¦
        await this.finalValidation();
        
        // 5. ì •ë¦¬
        await this.cleanup(backup);
    }

    private async executeStep(step: RefactoringStep): Promise<void> {
        console.log(`ğŸ”§ ${step.name} ì‹¤í–‰ ì¤‘...`);
        
        // ë³‘ë ¬ ì‹¤í–‰ ê°€ëŠ¥í•œ ì‘ì—… ì‹ë³„
        const parallelTasks = step.tasks.filter(t => t.canRunInParallel);
        const sequentialTasks = step.tasks.filter(t => !t.canRunInParallel);
        
        // ë³‘ë ¬ ì‘ì—… ì‹¤í–‰
        await Promise.all(parallelTasks.map(task => this.executor.execute(task)));
        
        // ìˆœì°¨ ì‘ì—… ì‹¤í–‰
        for (const task of sequentialTasks) {
            await this.executor.execute(task);
        }
    }
}
</code></pre>
                    </div>
                </div>
            </section>

            <section class="practice-section">
                <h2><i class="fas fa-laptop-code"></i> ì‹¤ìŠµ: ë ˆê±°ì‹œ í”„ë¡œì íŠ¸ í˜„ëŒ€í™”</h2>
                
                <div class="exercise">
                    <h3>ê³¼ì œ: jQuery í”„ë¡œì íŠ¸ë¥¼ Reactë¡œ ë§ˆì´ê·¸ë ˆì´ì…˜</h3>
                    <p>ë‹¤ìŒ ìš”êµ¬ì‚¬í•­ì„ ë§Œì¡±í•˜ëŠ” ë§ˆì´ê·¸ë ˆì´ì…˜ ë„êµ¬ë¥¼ êµ¬ì¶•í•˜ì„¸ìš”:</p>
                    
                    <div class="requirements">
                        <h4>ìš”êµ¬ì‚¬í•­:</h4>
                        <ul>
                            <li>jQuery ì½”ë“œë¥¼ React ì»´í¬ë„ŒíŠ¸ë¡œ ìë™ ë³€í™˜</li>
                            <li>ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ì™€ DOM ì¡°ì‘ ì½”ë“œ ë§ˆì´ê·¸ë ˆì´ì…˜</li>
                            <li>AJAX í˜¸ì¶œì„ modern fetch/axiosë¡œ ë³€í™˜</li>
                            <li>ì ì§„ì  ë§ˆì´ê·¸ë ˆì´ì…˜ ì§€ì› (í˜ì´ì§€ë³„)</li>
                            <li>ìë™ í…ŒìŠ¤íŠ¸ ìƒì„±</li>
                            <li>ë§ˆì´ê·¸ë ˆì´ì…˜ ì§„í–‰ ìƒí™© ëŒ€ì‹œë³´ë“œ</li>
                        </ul>
                    </div>

                    <div class="hints">
                        <h4>íŒíŠ¸:</h4>
                        <ul>
                            <li>jQuery ì„ íƒìë¥¼ React refë¡œ ë§¤í•‘</li>
                            <li>ì´ë²¤íŠ¸ ìœ„ì„ íŒ¨í„´ì„ React ì´ë²¤íŠ¸ë¡œ ë³€í™˜</li>
                            <li>jQuery í”ŒëŸ¬ê·¸ì¸ì€ React ì»´í¬ë„ŒíŠ¸ë¡œ ë˜í•‘</li>
                            <li>ìƒíƒœ ê´€ë¦¬ë¥¼ ìœ„í•´ useState/useReducer í™œìš©</li>
                            <li>ê¸°ì¡´ ìŠ¤íƒ€ì¼ì€ CSS Modulesë¡œ ë¶„ë¦¬</li>
                        </ul>
                    </div>
                </div>
            </section>

            <section class="summary-section">
                <h2><i class="fas fa-bookmark"></i> í•µì‹¬ ìš”ì•½</h2>
                <div class="summary-grid">
                    <div class="summary-item">
                        <h3>ë§ˆì´ê·¸ë ˆì´ì…˜ ë„êµ¬</h3>
                        <ul>
                            <li>AST ê¸°ë°˜ ì½”ë“œ ë³€í™˜</li>
                            <li>íŒ¨í„´ ì¸ì‹ê³¼ ìë™ ë³€í™˜</li>
                            <li>ì ì§„ì  ë§ˆì´ê·¸ë ˆì´ì…˜</li>
                        </ul>
                    </div>
                    <div class="summary-item">
                        <h3>ë¦¬íŒ©í† ë§ ì „ëµ</h3>
                        <ul>
                            <li>ì•ˆì „ì„± ìš°ì„  ì ‘ê·¼</li>
                            <li>ìë™í™”ëœ ê²€ì¦</li>
                            <li>ë¡¤ë°± ê³„íš ìˆ˜ë¦½</li>
                        </ul>
                    </div>
                    <div class="summary-item">
                        <h3>í’ˆì§ˆ ë³´ì¦</h3>
                        <ul>
                            <li>ë™ì‘ ë³´ì¡´ í…ŒìŠ¤íŠ¸</li>
                            <li>ì„±ëŠ¥ ì˜í–¥ ë¶„ì„</li>
                            <li>íƒ€ì… ì•ˆì „ì„± ê²€ì¦</li>
                        </ul>
                    </div>
                    <div class="summary-item">
                        <h3>í”„ë¡œì íŠ¸ ê´€ë¦¬</h3>
                        <ul>
                            <li>ë‹¨ê³„ë³„ ì‹¤í–‰ ê³„íš</li>
                            <li>ë¦¬ìŠ¤í¬ ê´€ë¦¬</li>
                            <li>ì§„í–‰ ìƒí™© ëª¨ë‹ˆí„°ë§</li>
                        </ul>
                    </div>
                </div>
            </section>
        </main>

        <aside class="sidebar">
            <div class="progress-indicator">
                <h3>ì§„í–‰ ìƒí™©</h3>
                <div class="progress-bar">
                    <div class="progress-fill" style="width: 83.33%;"></div>
                </div>
                <span>25/30 ê°•ì˜ (83.33%)</span>
            </div>

            <nav class="lesson-nav-sidebar">
                <h3>ì „ì²´ ê°•ì˜</h3>
                <ul>
                    <li><a href="lesson23.html">ì œ23ê°•: AI ì½”ë“œ ë¦¬ë·°</a></li>
                    <li><a href="lesson24.html">ì œ24ê°•: ë¬¸ì„œí™” ìë™í™”</a></li>
                    <li class="current">ì œ25ê°•: ë§ˆì´ê·¸ë ˆì´ì…˜ ë„êµ¬</li>
                    <li><a href="lesson26.html">ì œ26ê°•: ì„±ëŠ¥ í”„ë¡œíŒŒì¼ë§</a></li>
                    <li><a href="lesson27.html">ì œ27ê°•: AI ë””ë²„ê¹… ë„êµ¬</a></li>
                </ul>
            </nav>

            <div class="study-tips">
                <h3>í•™ìŠµ íŒ</h3>
                <ul>
                    <li>ë§ˆì´ê·¸ë ˆì´ì…˜ì€ í•­ìƒ ì‘ì€ ë‹¨ìœ„ë¶€í„° ì‹œì‘í•˜ì„¸ìš”</li>
                    <li>ìë™í™” ë„êµ¬ë¥¼ ë§Œë“¤ê¸° ì „ì— ìˆ˜ë™ìœ¼ë¡œ ëª‡ ë²ˆ í•´ë³´ì„¸ìš”</li>
                    <li>ê¸°ì¡´ í…ŒìŠ¤íŠ¸ë¥¼ ìµœëŒ€í•œ í™œìš©í•˜ì—¬ ì•ˆì „ì„±ì„ í™•ë³´í•˜ì„¸ìš”</li>
                    <li>ì„±ëŠ¥ ì €í•˜ê°€ ì—†ëŠ”ì§€ ì§€ì†ì ìœ¼ë¡œ ëª¨ë‹ˆí„°ë§í•˜ì„¸ìš”</li>
                </ul>
            </div>
        </aside>
    </div>

    <script src="../assets/lesson-script.js"></script>
</body>
</html>