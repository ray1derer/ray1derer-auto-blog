<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>제21강: AI 페어 프로그래밍 고급 기법 | Cursor AI 마스터 클래스</title>
    <link rel="stylesheet" href="../assets/lesson-style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>
<body>
    <div class="lesson-container">
        <header class="lesson-header">
            <div class="lesson-title">
                <h1><i class="fas fa-robot"></i> 제21강: AI 페어 프로그래밍 고급 기법</h1>
                <p class="lesson-subtitle">AI와 함께하는 효율적인 협업 프로그래밍 마스터하기</p>
            </div>
            <div class="lesson-meta">
                <span class="difficulty"><i class="fas fa-signal"></i> 난이도: 고급</span>
                <span class="duration"><i class="fas fa-clock"></i> 예상 시간: 60분</span>
                <span class="category"><i class="fas fa-folder"></i> 카테고리: 고급</span>
            </div>
        </header>

        <nav class="lesson-nav">
            <a href="lesson20.html" class="nav-link prev">
                <i class="fas fa-chevron-left"></i> 이전 강의
            </a>
            <span class="nav-title">제21강: AI 페어 프로그래밍 고급 기법</span>
            <a href="lesson22.html" class="nav-link next">
                다음 강의 <i class="fas fa-chevron-right"></i>
            </a>
        </nav>

        <main class="lesson-content">
            <section class="learning-objectives">
                <h2><i class="fas fa-bullseye"></i> 학습 목표</h2>
                <ul>
                    <li>AI와의 효과적인 대화 패턴과 프롬프트 엔지니어링</li>
                    <li>컨텍스트 관리와 세션 최적화 전략</li>
                    <li>복잡한 문제 해결을 위한 단계적 접근법</li>
                    <li>AI 제안 평가와 선택적 적용 기법</li>
                    <li>협업 워크플로우 최적화와 생산성 향상</li>
                </ul>
            </section>

            <section class="content-section">
                <h2><i class="fas fa-comments"></i> 고급 프롬프트 엔지니어링</h2>
                
                <div class="info-box">
                    <p>Cursor AI와의 효과적인 소통은 프롬프트 작성 기술에서 시작됩니다. 명확하고 구조화된 프롬프트는 더 정확하고 유용한 코드를 생성합니다.</p>
                </div>

                <h3>프롬프트 패턴과 템플릿</h3>
                <div class="prompt-patterns">
                    <div class="pattern-example">
                        <h4>1. 컨텍스트-액션-제약 패턴</h4>
                        <div class="prompt-structure">
                            <pre><code># 효과적인 프롬프트 구조

## Context (배경)
- 현재 작업: React 기반 대시보드 개발
- 기술 스택: React 18, TypeScript, Redux Toolkit, RTK Query
- 목표: 실시간 데이터 시각화 컴포넌트

## Action (요청)
실시간으로 업데이트되는 차트 컴포넌트를 만들어주세요.

## Constraints (제약사항)
- WebSocket을 통해 1초마다 데이터 수신
- 최대 100개의 데이터 포인트만 표시
- 메모리 누수 방지를 위한 적절한 cleanup
- React.memo로 불필요한 리렌더링 방지
- 에러 상태와 로딩 상태 처리

## Expected Output (기대 결과)
- 재사용 가능한 컴포넌트
- TypeScript 타입 정의
- 유닛 테스트 포함
- Storybook 스토리 작성</code></pre>
                        </div>
                    </div>

                    <div class="pattern-example">
                        <h4>2. 예제 기반 패턴</h4>
                        <div class="prompt-structure">
                            <pre><code># 예제를 활용한 프롬프트

다음과 같은 API 응답을 처리하는 코드가 필요합니다:

입력 예제:
```json
{
  "data": {
    "users": [
      { "id": 1, "name": "John", "role": "admin" },
      { "id": 2, "name": "Jane", "role": "user" }
    ],
    "pagination": {
      "page": 1,
      "total": 100
    }
  },
  "error": null
}
```

다음 요구사항을 만족하는 TypeScript 코드를 작성해주세요:
1. Zod를 사용한 런타임 유효성 검사
2. 에러 발생 시 기본값 반환
3. 페이지네이션 정보 추출 유틸리티
4. React Query와 통합 가능한 형태</code></pre>
                        </div>
                    </div>

                    <div class="pattern-example">
                        <h4>3. 점진적 구체화 패턴</h4>
                        <div class="progressive-prompting">
                            <pre><code># Step 1: 고수준 설계
"인증 시스템의 전체 아키텍처를 설계해주세요"

# Step 2: 구체적 구현
"JWT 기반 인증 미들웨어를 Express.js로 구현해주세요"

# Step 3: 엣지 케이스 처리
"토큰 만료, 갱신, 동시 로그인 제한을 추가해주세요"

# Step 4: 최적화
"Redis를 사용한 토큰 블랙리스트와 rate limiting을 구현해주세요"

# Step 5: 테스트
"인증 시스템의 통합 테스트를 작성해주세요"</code></pre>
                        </div>
                    </div>
                </div>

                <h3>고급 프롬프트 기법</h3>
                <div class="advanced-prompting">
                    <div class="technique">
                        <h4>Chain of Thought (사고 연쇄)</h4>
                        <pre><code>"""
복잡한 알고리즘 문제를 해결해주세요.

문제: 주어진 그래프에서 모든 노드를 최소 비용으로 연결하는 트리를 찾아야 합니다.

해결 과정:
1. 먼저 문제를 분석해주세요
2. 가능한 알고리즘들을 나열하고 장단점을 설명해주세요
3. 최적의 알고리즘을 선택하고 이유를 설명해주세요
4. 단계별로 구현 과정을 보여주세요
5. 시간/공간 복잡도를 분석해주세요
6. 최적화 가능한 부분을 제안해주세요
"""</code></pre>
                    </div>

                    <div class="technique">
                        <h4>Role Playing (역할 부여)</h4>
                        <pre><code>"""
당신은 10년 경력의 시니어 보안 엔지니어입니다.
다음 코드의 보안 취약점을 분석하고 개선 방안을 제시해주세요.

[코드]

다음 관점에서 분석해주세요:
- OWASP Top 10 기준
- 잠재적 공격 벡터
- 데이터 유출 가능성
- 성능에 미치는 영향
- 규정 준수 (GDPR, PCI-DSS 등)
"""</code></pre>
                    </div>

                    <div class="technique">
                        <h4>Few-Shot Learning</h4>
                        <pre><code>"""
다음 예제를 참고하여 새로운 Custom Hook을 만들어주세요.

예제 1: useDebounce
- 입력: value, delay
- 출력: 지연된 값
- 용도: 검색 입력 최적화

예제 2: useLocalStorage
- 입력: key, initialValue
- 출력: [value, setValue]
- 용도: 로컬 스토리지 동기화

이제 useWebSocket Hook을 만들어주세요:
- 자동 재연결
- 메시지 큐잉
- 연결 상태 관리
- 타입 안전성
"""</code></pre>
                    </div>
                </div>
            </section>

            <section class="content-section">
                <h2><i class="fas fa-brain"></i> 컨텍스트 관리 전략</h2>

                <div class="context-management">
                    <h3>효율적인 컨텍스트 구성</h3>
                    
                    <div class="context-strategy">
                        <h4>.cursorrules 파일 활용</h4>
                        <pre><code># .cursorrules
# 프로젝트별 AI 가이드라인

## 코딩 스타일
- TypeScript strict mode 사용
- 함수형 프로그래밍 선호
- 불변성 유지
- 명시적 타입 정의

## 아키텍처 원칙
- 의존성 역전 원칙 준수
- 레이어 간 명확한 경계
- 도메인 로직과 인프라 분리
- 테스트 가능한 설계

## 네이밍 컨벤션
- 컴포넌트: PascalCase
- 함수/변수: camelCase
- 상수: UPPER_SNAKE_CASE
- 타입/인터페이스: PascalCase with 'I' or 'T' prefix

## 선호하는 라이브러리
- 상태 관리: Redux Toolkit
- 폼 처리: React Hook Form + Zod
- 날짜 처리: date-fns
- HTTP 클라이언트: Axios with interceptors
- 테스트: Jest + React Testing Library

## 금지 사항
- any 타입 사용
- console.log (production)
- 직접적인 DOM 조작
- 인라인 스타일

## 보안 고려사항
- 모든 사용자 입력 검증
- XSS 방지
- SQL Injection 방지
- 민감 정보 로깅 금지</code></pre>
                    </div>

                    <div class="context-strategy">
                        <h4>컨텍스트 파일 구조</h4>
                        <pre><code># project-context.md
# 프로젝트 컨텍스트 문서

## 프로젝트 개요
- **이름**: E-Commerce Platform
- **버전**: 2.0.0
- **팀 규모**: 5명
- **개발 기간**: 6개월

## 기술 스택
### Frontend
- React 18.2.0
- TypeScript 5.0
- Vite 4.0
- TailwindCSS 3.3

### Backend
- Node.js 18 LTS
- Express.js 4.18
- PostgreSQL 15
- Redis 7.0

### Infrastructure
- AWS ECS Fargate
- CloudFront CDN
- RDS Aurora
- ElastiCache

## 주요 기능
1. **사용자 시스템**
   - OAuth 2.0 소셜 로그인
   - 2FA 인증
   - 역할 기반 권한 관리

2. **상품 관리**
   - 실시간 재고 추적
   - 다중 이미지 업로드
   - 변형 상품 지원

3. **주문 처리**
   - 실시간 결제 처리
   - 주문 추적 시스템
   - 환불/교환 자동화

## API 구조
```
/api/v2
├── /auth
│   ├── POST /login
│   ├── POST /logout
│   └── POST /refresh
├── /users
│   ├── GET /profile
│   └── PUT /profile
├── /products
│   ├── GET /
│   ├── GET /:id
│   └── GET /search
└── /orders
    ├── POST /
    ├── GET /:id
    └── PUT /:id/status
```

## 데이터베이스 스키마
[주요 테이블 구조와 관계 설명]

## 현재 과제
- 성능 최적화 (LCP < 2.5s)
- 마이크로서비스 전환
- 실시간 알림 시스템
- AI 기반 추천 시스템</code></pre>
                    </div>

                    <div class="context-optimization">
                        <h4>컨텍스트 최적화 기법</h4>
                        <pre><code>// context-manager.ts
class ContextManager {
    private static instance: ContextManager;
    private contexts: Map<string, Context> = new Map();
    private maxContextSize = 8000; // 토큰 제한
    
    // 컨텍스트 우선순위 관리
    prioritizeContext(prompt: string): string[] {
        const relevantContexts = this.findRelevantContexts(prompt);
        
        return relevantContexts
            .sort((a, b) => b.relevance - a.relevance)
            .slice(0, 5) // 상위 5개만 선택
            .map(ctx => ctx.content);
    }
    
    // 동적 컨텍스트 로딩
    async loadDynamicContext(topic: string): Promise<void> {
        const contextFiles = await this.findContextFiles(topic);
        
        for (const file of contextFiles) {
            const content = await fs.readFile(file, 'utf-8');
            const compressed = this.compressContext(content);
            
            this.contexts.set(file, {
                content: compressed,
                relevance: this.calculateRelevance(content, topic),
                timestamp: Date.now()
            });
        }
    }
    
    // 컨텍스트 압축
    private compressContext(content: string): string {
        // 중복 제거
        const lines = content.split('\n');
        const unique = [...new Set(lines)];
        
        // 중요도 기반 필터링
        return unique
            .filter(line => this.isImportantLine(line))
            .join('\n');
    }
    
    // 컨텍스트 캐싱
    cacheContext(key: string, content: string): void {
        if (this.contexts.size > 100) {
            // LRU 방식으로 오래된 컨텍스트 제거
            const oldest = [...this.contexts.entries()]
                .sort((a, b) => a[1].timestamp - b[1].timestamp)[0];
            
            this.contexts.delete(oldest[0]);
        }
        
        this.contexts.set(key, {
            content,
            relevance: 1.0,
            timestamp: Date.now()
        });
    }
}</code></pre>
                    </div>
                </div>
            </section>

            <section class="content-section">
                <h2><i class="fas fa-puzzle-piece"></i> 복잡한 문제 해결 전략</h2>

                <div class="problem-solving">
                    <h3>단계별 문제 분해</h3>
                    
                    <div class="decomposition-example">
                        <h4>대규모 리팩토링 프로젝트</h4>
                        <pre><code>"""
# Phase 1: 현재 상태 분석
프로젝트의 현재 아키텍처를 분석하고 문제점을 파악해주세요:
- 순환 의존성
- 높은 결합도
- 테스트 불가능한 코드
- 성능 병목 지점

# Phase 2: 목표 아키텍처 설계
Clean Architecture 기반으로 목표 아키텍처를 설계해주세요:
- 레이어 정의
- 의존성 방향
- 인터페이스 설계
- 모듈 경계

# Phase 3: 마이그레이션 전략
안전한 점진적 마이그레이션 계획을 수립해주세요:
- 우선순위 결정
- 단계별 작업 계획
- 롤백 전략
- 테스트 계획

# Phase 4: 첫 번째 모듈 리팩토링
가장 독립적인 모듈부터 시작해주세요:
```
// 현재 코드
[legacy code]
```

다음 요구사항으로 리팩토링:
- 의존성 주입
- 단위 테스트 가능
- SOLID 원칙 준수
"""</code></pre>
                    </div>

                    <div class="iterative-refinement">
                        <h4>반복적 개선 프로세스</h4>
                        <pre><code>// AI와의 반복적 개선 워크플로우

// Round 1: 초기 구현
const prompt1 = `
GraphQL 스키마와 리졸버를 구현해주세요.
요구사항: 사용자, 포스트, 댓글 CRUD
`;

// AI 응답 검토 후...

// Round 2: 성능 최적화
const prompt2 = `
이전 구현에 다음을 추가해주세요:
- DataLoader로 N+1 문제 해결
- 필드 레벨 캐싱
- 쿼리 복잡도 제한
`;

// Round 3: 보안 강화
const prompt3 = `
보안 측면을 강화해주세요:
- 인증/인가 미들웨어
- Rate limiting
- Query depth 제한
- 입력 검증
`;

// Round 4: 모니터링 추가
const prompt4 = `
프로덕션 준비를 위해 추가해주세요:
- 성능 메트릭 수집
- 에러 추적
- 쿼리 로깅
- Health check 엔드포인트
`;

// Round 5: 문서화
const prompt5 = `
다음 문서를 생성해주세요:
- API 문서 (GraphQL Playground)
- 개발자 가이드
- 배포 가이드
- 트러블슈팅 가이드
`;</code></pre>
                    </div>

                    <div class="ai-debugging">
                        <h4>AI 활용 디버깅 전략</h4>
                        <pre><code>"""
# 복잡한 버그 해결 프로세스

## 1. 증상 설명
다음과 같은 문제가 발생하고 있습니다:
- 특정 조건에서만 발생
- 재현 빈도: 약 30%
- 에러 메시지: [에러 내용]
- 영향 범위: [영향받는 기능]

## 2. 환경 정보
- Node.js 버전: 18.16.0
- 운영체제: Ubuntu 22.04
- 관련 라이브러리: [버전 정보]

## 3. 코드 컨텍스트
```javascript
[문제가 발생하는 코드]
```

## 4. 시도한 해결 방법
1. [시도 1]: 실패 (이유)
2. [시도 2]: 부분적 성공
3. [시도 3]: 부작용 발생

## 5. 요청 사항
- 가능한 원인 분석
- 체계적인 디버깅 방법
- 근본적인 해결책
- 재발 방지 대책
"""</code></pre>
                    </div>
                </div>
            </section>

            <section class="content-section">
                <h2><i class="fas fa-chart-line"></i> AI 제안 평가와 적용</h2>

                <div class="ai-evaluation">
                    <h3>코드 품질 평가 프레임워크</h3>
                    
                    <div class="evaluation-criteria">
                        <h4>평가 체크리스트</h4>
                        <pre><code>// AI 생성 코드 평가 기준

class AICodeEvaluator {
    evaluate(code: string): EvaluationResult {
        return {
            // 1. 정확성
            correctness: {
                syntaxValid: this.checkSyntax(code),
                logicSound: this.checkLogic(code),
                requirementsMet: this.checkRequirements(code)
            },
            
            // 2. 성능
            performance: {
                timeComplexity: this.analyzeTimeComplexity(code),
                spaceComplexity: this.analyzeSpaceComplexity(code),
                scalability: this.checkScalability(code)
            },
            
            // 3. 보안
            security: {
                vulnerabilities: this.scanVulnerabilities(code),
                inputValidation: this.checkInputValidation(code),
                authorizationChecks: this.checkAuthorization(code)
            },
            
            // 4. 유지보수성
            maintainability: {
                readability: this.scoreReadability(code),
                modularity: this.checkModularity(code),
                testability: this.assessTestability(code),
                documentation: this.checkDocumentation(code)
            },
            
            // 5. 베스트 프랙티스
            bestPractices: {
                designPatterns: this.checkPatterns(code),
                codeStandards: this.checkStandards(code),
                errorHandling: this.checkErrorHandling(code)
            }
        };
    }
    
    // 자동 개선 제안
    suggest-improvements(evaluation: EvaluationResult): Improvement[] {
        const improvements = [];
        
        if (evaluation.performance.timeComplexity > 'O(n)') {
            improvements.push({
                type: 'performance',
                priority: 'high',
                suggestion: '알고리즘 최적화 필요',
                example: this.getOptimizedAlgorithm()
            });
        }
        
        if (!evaluation.security.inputValidation) {
            improvements.push({
                type: 'security',
                priority: 'critical',
                suggestion: '입력 검증 추가 필요',
                code: this.generateValidationCode()
            });
        }
        
        return improvements;
    }
}</code></pre>
                    </div>

                    <div class="selective-application">
                        <h4>선택적 적용 전략</h4>
                        <pre><code>// AI 제안 선택적 적용 워크플로우

class AIResponseProcessor {
    async processAIResponse(response: string, context: Context) {
        // 1. 응답 파싱
        const suggestions = this.parseResponse(response);
        
        // 2. 각 제안 평가
        const evaluatedSuggestions = await Promise.all(
            suggestions.map(async (suggestion) => ({
                ...suggestion,
                score: await this.evaluateSuggestion(suggestion, context),
                risks: this.assessRisks(suggestion),
                benefits: this.assessBenefits(suggestion)
            }))
        );
        
        // 3. 우선순위 정렬
        const prioritized = evaluatedSuggestions
            .sort((a, b) => b.score - a.score)
            .filter(s => s.score > 0.7); // 70% 이상만 고려
        
        // 4. 점진적 적용
        for (const suggestion of prioritized) {
            // 테스트 환경에서 먼저 적용
            const testResult = await this.applyInTestEnvironment(suggestion);
            
            if (testResult.success) {
                // A/B 테스트로 검증
                const abTestResult = await this.runABTest(suggestion);
                
                if (abTestResult.improvement > 0.1) {
                    // 프로덕션 적용
                    await this.applyToProduction(suggestion);
                }
            }
        }
    }
    
    // 위험 평가
    assessRisks(suggestion: Suggestion): Risk[] {
        const risks = [];
        
        // Breaking change 검사
        if (this.hasBreakingChanges(suggestion)) {
            risks.push({
                type: 'breaking-change',
                severity: 'high',
                mitigation: 'Feature flag 사용'
            });
        }
        
        // 성능 영향 검사
        if (this.hasPerformanceImpact(suggestion)) {
            risks.push({
                type: 'performance',
                severity: 'medium',
                mitigation: '점진적 롤아웃'
            });
        }
        
        return risks;
    }
}</code></pre>
                    </div>

                    <div class="feedback-loop">
                        <h4>피드백 루프 구축</h4>
                        <pre><code>// AI 학습을 위한 피드백 시스템

class AIFeedbackSystem {
    private feedbackHistory: FeedbackEntry[] = [];
    
    // 피드백 수집
    recordFeedback(
        prompt: string,
        response: string,
        applied: boolean,
        outcome?: Outcome
    ) {
        this.feedbackHistory.push({
            timestamp: new Date(),
            prompt,
            response,
            applied,
            outcome,
            metrics: this.collectMetrics()
        });
        
        // 패턴 분석
        this.analyzePatterns();
    }
    
    // 패턴 분석
    private analyzePatterns() {
        // 성공적인 프롬프트 패턴 추출
        const successfulPrompts = this.feedbackHistory
            .filter(f => f.outcome?.success)
            .map(f => f.prompt);
        
        const patterns = this.extractPatterns(successfulPrompts);
        
        // 프롬프트 템플릿 업데이트
        this.updatePromptTemplates(patterns);
        
        // 실패 패턴 분석
        const failurePatterns = this.feedbackHistory
            .filter(f => !f.outcome?.success)
            .map(f => ({
                prompt: f.prompt,
                reason: f.outcome?.failureReason
            }));
        
        // 안티패턴 문서화
        this.documentAntiPatterns(failurePatterns);
    }
    
    // 개선 제안 생성
    generateImprovementSuggestions(): Suggestion[] {
        const recentFeedback = this.getRecentFeedback(30); // 최근 30일
        
        return [
            {
                type: 'prompt-optimization',
                suggestion: '더 구체적인 제약사항 명시',
                examples: this.getBestPromptExamples()
            },
            {
                type: 'context-enhancement',
                suggestion: '도메인 특화 컨텍스트 추가',
                templates: this.getContextTemplates()
            },
            {
                type: 'workflow-improvement',
                suggestion: '반복 작업 자동화',
                automation: this.getAutomationOpportunities()
            }
        ];
    }
}</code></pre>
                    </div>
                </div>
            </section>

            <section class="content-section">
                <h2><i class="fas fa-users"></i> 팀 협업 워크플로우</h2>

                <div class="team-collaboration">
                    <h3>AI 기반 팀 개발 프로세스</h3>
                    
                    <div class="shared-context">
                        <h4>팀 공유 컨텍스트 관리</h4>
                        <pre><code># team-context/README.md
# 팀 AI 컨텍스트 가이드

## 1. 공유 컨텍스트 파일
```
team-context/
├── architecture/
│   ├── system-design.md
│   ├── api-contracts.md
│   └── database-schema.sql
├── conventions/
│   ├── coding-standards.md
│   ├── git-workflow.md
│   └── review-checklist.md
├── patterns/
│   ├── design-patterns.md
│   ├── error-handling.md
│   └── testing-strategies.md
└── prompts/
    ├── feature-template.md
    ├── bug-fix-template.md
    └── refactoring-template.md
```

## 2. 컨텍스트 동기화 전략
```bash
# 팀원 간 컨텍스트 동기화
git pull origin main
./scripts/sync-ai-context.sh

# 개인 컨텍스트와 병합
cursor context merge team-context/ .cursorrules
```

## 3. 협업 규칙
- 모든 주요 변경사항은 team-context에 반영
- PR 생성 시 AI 컨텍스트 업데이트 포함
- 주간 컨텍스트 리뷰 미팅

## 4. AI 페어 프로그래밍 세션
### 드라이버-네비게이터 모델
- 드라이버: 코드 작성 및 AI 프롬프트 입력
- 네비게이터: AI 응답 검토 및 방향 제시
- 15분마다 역할 교대

### 몹 프로그래밍 with AI
- 전체 팀이 하나의 화면 공유
- 한 명이 AI와 대화
- 나머지는 실시간 피드백
- 복잡한 아키텍처 결정에 효과적</code></pre>
                    </div>

                    <div class="code-review-ai">
                        <h4>AI 지원 코드 리뷰</h4>
                        <pre><code>// .github/workflows/ai-code-review.yml
name: AI Code Review

on:
  pull_request:
    types: [opened, synchronize]

jobs:
  ai-review:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: AI Code Analysis
        run: |
          # AI 컨텍스트 로드
          cursor-cli load-context .cursorrules team-context/
          
          # 변경사항 분석
          cursor-cli analyze-pr \
            --check-patterns \
            --security-scan \
            --performance-impact \
            --breaking-changes
      
      - name: Generate Review Comments
        run: |
          cursor-cli generate-review \
            --style team-conventions \
            --focus "security,performance,maintainability" \
            > ai-review.md
      
      - name: Post Review
        uses: actions/github-script@v6
        with:
          script: |
            const review = fs.readFileSync('ai-review.md', 'utf8');
            github.rest.pulls.createReview({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number,
              body: review,
              event: 'COMMENT'
            });

# 팀 리뷰 체크리스트 (AI가 자동 체크)
checklist:
  - [ ] 테스트 커버리지 80% 이상
  - [ ] 성능 벤치마크 통과
  - [ ] 보안 스캔 통과
  - [ ] 문서 업데이트
  - [ ] Breaking change 확인
  - [ ] 에러 처리 적절성
  - [ ] 로깅 및 모니터링</code></pre>
                    </div>

                    <div class="knowledge-sharing">
                        <h4>AI 지식 공유 시스템</h4>
                        <pre><code>// tools/ai-knowledge-base.ts
class TeamKnowledgeBase {
    // AI 솔루션 아카이브
    async archiveSolution(solution: Solution) {
        const entry = {
            id: generateId(),
            problem: solution.problem,
            context: solution.context,
            prompt: solution.prompt,
            response: solution.response,
            evaluation: solution.evaluation,
            tags: this.extractTags(solution),
            author: solution.author,
            timestamp: new Date()
        };
        
        await this.db.solutions.insert(entry);
        await this.indexForSearch(entry);
        
        // 팀에게 알림
        await this.notifyTeam(entry);
    }
    
    // 유사 문제 검색
    async findSimilarSolutions(problem: string): Promise<Solution[]> {
        const embedding = await this.generateEmbedding(problem);
        
        return this.db.solutions
            .searchByVector(embedding)
            .limit(5)
            .execute();
    }
    
    // 베스트 프랙티스 추출
    async extractBestPractices(): Promise<BestPractice[]> {
        const highRatedSolutions = await this.db.solutions
            .where('evaluation.score', '>', 0.9)
            .orderBy('evaluation.score', 'desc')
            .limit(100)
            .execute();
        
        // 패턴 분석
        const patterns = this.analyzePatterns(highRatedSolutions);
        
        // 베스트 프랙티스 생성
        return patterns.map(pattern => ({
            title: pattern.name,
            description: pattern.description,
            examples: pattern.examples,
            prompt_template: pattern.template,
            success_rate: pattern.successRate,
            use_cases: pattern.useCases
        }));
    }
    
    // 팀 학습 메트릭
    generateTeamMetrics(): TeamMetrics {
        return {
            totalSolutions: this.db.solutions.count(),
            averageQuality: this.calculateAverageQuality(),
            topContributors: this.getTopContributors(),
            mostUsedPatterns: this.getMostUsedPatterns(),
            improvementTrend: this.calculateImprovementTrend(),
            knowledgeGaps: this.identifyKnowledgeGaps()
        };
    }
}</code></pre>
                    </div>
                </div>
            </section>

            <section class="practice">
                <h2><i class="fas fa-laptop-code"></i> 실습: AI 페어 프로그래밍 마스터하기</h2>

                <div class="practice-content">
                    <h3>복잡한 기능 구현 프로젝트</h3>
                    <p>AI와 함께 실시간 협업 화이트보드 애플리케이션을 구축해봅시다.</p>

                    <div class="project-requirements">
                        <h4>프로젝트 요구사항</h4>
                        <ul>
                            <li>실시간 다중 사용자 편집</li>
                            <li>도형, 텍스트, 자유 그리기 도구</li>
                            <li>무한 캔버스와 줌/팬</li>
                            <li>변경 이력과 되돌리기/다시하기</li>
                            <li>협업 커서와 선택 영역 표시</li>
                            <li>음성/비디오 통화 통합</li>
                        </ul>
                    </div>

                    <div class="ai-collaboration-steps">
                        <h4>AI와의 협업 단계</h4>
                        
                        <div class="step">
                            <h5>1. 아키텍처 설계</h5>
                            <p>프롬프트: "실시간 협업 화이트보드의 전체 시스템 아키텍처를 설계해주세요. WebRTC, WebSocket, CRDT를 고려해주세요."</p>
                        </div>
                        
                        <div class="step">
                            <h5>2. 데이터 구조 설계</h5>
                            <p>프롬프트: "CRDT 기반 충돌 해결이 가능한 캔버스 데이터 구조를 설계해주세요."</p>
                        </div>
                        
                        <div class="step">
                            <h5>3. 실시간 동기화</h5>
                            <p>프롬프트: "Y.js를 사용한 실시간 동기화 시스템을 구현해주세요."</p>
                        </div>
                        
                        <div class="step">
                            <h5>4. 성능 최적화</h5>
                            <p>프롬프트: "대량의 객체가 있을 때도 60fps를 유지하는 렌더링 최적화를 구현해주세요."</p>
                        </div>
                        
                        <div class="step">
                            <h5>5. 테스트 전략</h5>
                            <p>프롬프트: "실시간 협업 기능의 E2E 테스트 전략을 수립해주세요."</p>
                        </div>
                    </div>

                    <div class="evaluation-criteria">
                        <h4>🎯 평가 기준</h4>
                        <ul>
                            <li>실시간 동기화 지연시간 < 100ms</li>
                            <li>동시 사용자 100명 지원</li>
                            <li>충돌 해결 100% 성공률</li>
                            <li>오프라인 모드 지원</li>
                            <li>크로스 브라우저 호환성</li>
                        </ul>
                    </div>
                </div>
            </section>

            <section class="summary">
                <h2><i class="fas fa-check-circle"></i> 핵심 정리</h2>
                
                <div class="key-points">
                    <div class="point">
                        <i class="fas fa-star"></i>
                        <h3>고급 프롬프트 엔지니어링</h3>
                        <p>구조화된 프롬프트와 컨텍스트 제공으로 AI의 정확도를 극대화합니다.</p>
                    </div>
                    
                    <div class="point">
                        <i class="fas fa-star"></i>
                        <h3>효율적인 컨텍스트 관리</h3>
                        <p>프로젝트별 맞춤 컨텍스트로 일관된 코드 생성을 보장합니다.</p>
                    </div>
                    
                    <div class="point">
                        <i class="fas fa-star"></i>
                        <h3>체계적인 문제 해결</h3>
                        <p>복잡한 문제를 단계별로 분해하여 AI와 함께 해결합니다.</p>
                    </div>
                    
                    <div class="point">
                        <i class="fas fa-star"></i>
                        <h3>팀 협업 최적화</h3>
                        <p>AI를 팀 개발 프로세스에 통합하여 생산성을 향상시킵니다.</p>
                    </div>
                </div>

                <div class="next-steps">
                    <h3>다음 강의 예고</h3>
                    <p>다음 강의에서는 커스텀 명령어와 확장 기능 개발을 배웁니다.</p>
                    <a href="lesson22.html" class="btn btn-primary">
                        <i class="fas fa-arrow-right"></i> 다음 강의로 이동
                    </a>
                </div>
            </section>
        </main>

        <aside class="sidebar">
            <div class="sidebar-section">
                <h3><i class="fas fa-list"></i> 강의 목차</h3>
                <ol class="lesson-list">
                    <li class="completed">Cursor 소개와 설치</li>
                    <li class="completed">첫 번째 AI 자동완성</li>
                    <li class="completed">AI Chat 마스터하기</li>
                    <li class="completed">Cmd+K 완벽 가이드</li>
                    <li class="completed">프로젝트 컨텍스트</li>
                    <li class="completed">AI 모델 선택과 활용</li>
                    <li class="completed">Composer 기능 활용</li>
                    <li class="completed">터미널 통합</li>
                    <li class="completed">디버깅과 에러 해결</li>
                    <li class="completed">단축키와 설정 최적화</li>
                    <li class="completed">Git 통합과 버전 관리</li>
                    <li class="completed">테스트 작성과 TDD</li>
                    <li class="completed">리팩토링과 코드 품질</li>
                    <li class="completed">API 개발과 문서화</li>
                    <li class="completed">데이터베이스 설계와 최적화</li>
                    <li class="completed">프론트엔드 프레임워크와 Cursor AI</li>
                    <li class="completed">백엔드 프레임워크와 Cursor AI</li>
                    <li class="completed">Docker와 Kubernetes 배포</li>
                    <li class="completed">성능 최적화와 보안</li>
                    <li class="completed">대규모 프로젝트 아키텍처</li>
                    <li class="current">AI 페어 프로그래밍 고급 기법</li>
                </ol>
            </div>

            <div class="sidebar-section">
                <h3><i class="fas fa-magic"></i> 프롬프트 템플릿</h3>
                <div class="prompt-templates">
                    <div class="template">
                        <h4>기능 구현</h4>
                        <code>[Context] + [Requirements] + [Constraints] + [Examples]</code>
                    </div>
                    <div class="template">
                        <h4>디버깅</h4>
                        <code>[Error] + [Context] + [Tried] + [Expected]</code>
                    </div>
                    <div class="template">
                        <h4>리팩토링</h4>
                        <code>[Current] + [Issues] + [Goals] + [Constraints]</code>
                    </div>
                    <div class="template">
                        <h4>설계</h4>
                        <code>[Requirements] + [Scale] + [Constraints] + [Preferences]</code>
                    </div>
                </div>
            </div>

            <div class="sidebar-section">
                <h3><i class="fas fa-lightbulb"></i> 프로 팁</h3>
                <div class="tip-box">
                    <p>💡 AI와의 대화는 페어 프로그래밍과 같습니다. 명확한 의도를 전달하고, 생성된 코드를 비판적으로 검토하며, 지속적으로 개선하는 것이 핵심입니다.</p>
                </div>
            </div>
        </aside>

        <div class="progress-tracker">
            <div class="progress-bar" style="width: 70%"></div>
            <span class="progress-text">21/30 완료</span>
        </div>
    </div>

    <script src="../assets/lesson-script.js"></script>
</body>
</html>