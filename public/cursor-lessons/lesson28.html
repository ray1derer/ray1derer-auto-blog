<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>제28강: 종합 프로젝트 자동화와 워크플로우 | Cursor AI 마스터 클래스</title>
    <link rel="stylesheet" href="../assets/lesson-style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>
<body>
    <div class="lesson-container">
        <header class="lesson-header">
            <div class="lesson-title">
                <h1><i class="fas fa-cogs"></i> 제28강: 종합 프로젝트 자동화와 워크플로우</h1>
                <p class="lesson-subtitle">개발 프로세스 전체를 AI로 자동화하기</p>
            </div>
            <div class="lesson-meta">
                <span class="difficulty"><i class="fas fa-signal"></i> 난이도: 고급</span>
                <span class="duration"><i class="fas fa-clock"></i> 예상 시간: 75분</span>
                <span class="category"><i class="fas fa-folder"></i> 카테고리: 고급</span>
            </div>
        </header>

        <nav class="lesson-nav">
            <a href="lesson27.html" class="nav-link prev">
                <i class="fas fa-chevron-left"></i> 이전 강의
            </a>
            <span class="nav-title">제28강: 종합 프로젝트 자동화와 워크플로우</span>
            <a href="lesson29.html" class="nav-link next">
                다음 강의 <i class="fas fa-chevron-right"></i>
            </a>
        </nav>

        <main class="lesson-content">
            <section class="learning-objectives">
                <h2><i class="fas fa-bullseye"></i> 학습 목표</h2>
                <ul>
                    <li>엔드투엔드 개발 자동화 시스템 구축</li>
                    <li>AI 기반 프로젝트 관리와 추적</li>
                    <li>자동화된 코드 생성과 배포 파이프라인</li>
                    <li>지능형 모니터링과 자가 치유 시스템</li>
                    <li>팀 협업 자동화와 생산성 향상</li>
                </ul>
            </section>

            <section class="content-section">
                <h2><i class="fas fa-robot"></i> AI 개발 자동화 플랫폼</h2>
                
                <div class="info-box">
                    <p>Cursor AI를 중심으로 한 종합적인 개발 자동화 플랫폼을 구축하여, 아이디어부터 배포까지 모든 과정을 자동화합니다. AI가 프로젝트를 이해하고 필요한 작업을 자동으로 수행합니다.</p>
                </div>

                <h3>통합 자동화 시스템</h3>
                <div class="automation-platform">
                    <div class="platform-implementation">
                        <h4>AI 기반 개발 오케스트레이터</h4>
                        <pre><code>// automation/DevelopmentOrchestrator.ts
import { CursorAI } from '@cursor/api';
import { ProjectManager } from './ProjectManager';
import { CodeGenerator } from './CodeGenerator';
import { TestAutomation } from './TestAutomation';
import { DeploymentPipeline } from './DeploymentPipeline';
import { MonitoringSystem } from './MonitoringSystem';

export class DevelopmentOrchestrator {
    private cursor: CursorAI;
    private projectManager: ProjectManager;
    private codeGenerator: CodeGenerator;
    private testAutomation: TestAutomation;
    private deployment: DeploymentPipeline;
    private monitoring: MonitoringSystem;
    private workflowEngine: WorkflowEngine;

    constructor() {
        this.cursor = new CursorAI();
        this.initializeComponents();
        this.setupAutomationRules();
    }

    async createProject(requirements: ProjectRequirements): Promise<Project> {
        console.log('🚀 새 프로젝트 생성 시작...');
        
        // 1. AI로 프로젝트 분석 및 계획 수립
        const projectPlan = await this.analyzeAndPlan(requirements);
        
        // 2. 프로젝트 구조 생성
        const project = await this.scaffoldProject(projectPlan);
        
        // 3. 자동화 워크플로우 설정
        await this.setupWorkflows(project);
        
        // 4. 개발 환경 구성
        await this.setupDevelopmentEnvironment(project);
        
        // 5. 초기 코드 생성
        await this.generateInitialCode(project);
        
        // 6. CI/CD 파이프라인 구성
        await this.setupCICD(project);
        
        return project;
    }

    private async analyzeAndPlan(requirements: ProjectRequirements): Promise<ProjectPlan> {
        const prompt = `
프로젝트 요구사항을 분석하고 상세한 개발 계획을 수립해주세요:

요구사항:
${JSON.stringify(requirements, null, 2)}

다음을 포함한 계획을 제시해주세요:
1. 기술 스택 선택과 이유
2. 프로젝트 구조와 아키텍처
3. 주요 컴포넌트와 모듈
4. 개발 단계와 마일스톤
5. 예상 일정과 리소스
6. 위험 요소와 대응 방안
7. 테스트 전략
8. 배포 전략
`;

        const planResponse = await this.cursor.ai.generateCode(prompt);
        const plan = JSON.parse(planResponse);
        
        // 계획 검증 및 최적화
        return await this.optimizePlan(plan, requirements);
    }

    private async scaffoldProject(plan: ProjectPlan): Promise<Project> {
        const project: Project = {
            id: this.generateProjectId(),
            name: plan.name,
            path: plan.path,
            structure: {},
            config: {},
            metadata: {
                created: new Date(),
                plan,
                status: 'initializing'
            }
        };

        // 디렉토리 구조 생성
        await this.createDirectoryStructure(project, plan.structure);
        
        // 설정 파일 생성
        await this.generateConfigFiles(project, plan);
        
        // 의존성 설치
        await this.installDependencies(project, plan.dependencies);
        
        return project;
    }

    async handleFeatureRequest(feature: FeatureRequest): Promise<FeatureImplementation> {
        console.log(`📋 기능 요청 처리: ${feature.title}`);
        
        // 1. 기능 분석
        const analysis = await this.analyzeFeature(feature);
        
        // 2. 영향도 평가
        const impact = await this.assessImpact(analysis);
        
        // 3. 구현 계획 수립
        const implementationPlan = await this.planImplementation(analysis, impact);
        
        // 4. 코드 생성
        const generatedCode = await this.generateFeatureCode(implementationPlan);
        
        // 5. 테스트 생성
        const tests = await this.generateTests(generatedCode);
        
        // 6. 통합 및 검증
        const integration = await this.integrateFeature(generatedCode, tests);
        
        // 7. 문서 업데이트
        await this.updateDocumentation(feature, integration);
        
        return {
            feature,
            analysis,
            implementation: integration,
            tests,
            documentation: await this.getUpdatedDocs()
        };
    }

    private async generateFeatureCode(plan: ImplementationPlan): Promise<GeneratedCode> {
        const codeFiles: CodeFile[] = [];
        
        for (const component of plan.components) {
            const prompt = `
다음 컴포넌트를 구현해주세요:

컴포넌트: ${component.name}
타입: ${component.type}
설명: ${component.description}

인터페이스:
${JSON.stringify(component.interface, null, 2)}

의존성:
${component.dependencies.join(', ')}

요구사항:
${component.requirements.map(r => `- ${r}`).join('\n')}

기존 코드 스타일과 패턴을 따라주세요.
`;

            const code = await this.cursor.ai.generateCode(prompt);
            
            codeFiles.push({
                path: component.path,
                content: code,
                type: component.type,
                tests: await this.generateComponentTests(component, code)
            });
        }
        
        return {
            files: codeFiles,
            dependencies: this.extractNewDependencies(codeFiles),
            migrations: await this.generateMigrations(plan)
        };
    }

    async automateWorkflow(trigger: WorkflowTrigger): Promise<WorkflowResult> {
        const workflow = this.workflowEngine.getWorkflow(trigger.type);
        const context = await this.buildWorkflowContext(trigger);
        
        const result: WorkflowResult = {
            trigger,
            steps: [],
            status: 'running',
            startTime: Date.now()
        };
        
        try {
            for (const step of workflow.steps) {
                const stepResult = await this.executeStep(step, context);
                result.steps.push(stepResult);
                
                if (stepResult.status === 'failed' && !step.continueOnError) {
                    result.status = 'failed';
                    break;
                }
                
                // AI 기반 다음 단계 결정
                if (step.conditional) {
                    const nextStep = await this.determineNextStep(stepResult, context);
                    if (nextStep) {
                        workflow.steps.push(nextStep);
                    }
                }
            }
            
            result.status = result.status === 'running' ? 'completed' : result.status;
        } catch (error) {
            result.status = 'error';
            result.error = error;
            
            // 자동 복구 시도
            await this.attemptRecovery(error, context);
        }
        
        result.endTime = Date.now();
        result.duration = result.endTime - result.startTime;
        
        // 워크플로우 학습
        await this.learnFromWorkflow(result);
        
        return result;
    }

    private async executeStep(step: WorkflowStep, context: WorkflowContext): Promise<StepResult> {
        console.log(`⚙️ 실행: ${step.name}`);
        
        const result: StepResult = {
            step: step.name,
            status: 'running',
            startTime: Date.now()
        };
        
        try {
            switch (step.type) {
                case 'code-generation':
                    result.output = await this.codeGenerator.generate(step.config, context);
                    break;
                    
                case 'test-execution':
                    result.output = await this.testAutomation.runTests(step.config, context);
                    break;
                    
                case 'deployment':
                    result.output = await this.deployment.deploy(step.config, context);
                    break;
                    
                case 'ai-analysis':
                    result.output = await this.performAIAnalysis(step.config, context);
                    break;
                    
                case 'custom':
                    result.output = await this.executeCustomStep(step, context);
                    break;
            }
            
            result.status = 'completed';
        } catch (error) {
            result.status = 'failed';
            result.error = error;
        }
        
        result.endTime = Date.now();
        result.duration = result.endTime - result.startTime;
        
        return result;
    }
}

// 지능형 프로젝트 관리
export class AIProjectManager {
    private cursor: CursorAI;
    private taskQueue: PriorityQueue<Task>;
    private teamMembers: Map<string, TeamMember>;
    private projectMetrics: ProjectMetrics;

    async manageSprint(sprint: Sprint): Promise<SprintResult> {
        console.log(`🏃 스프린트 ${sprint.number} 관리 시작`);
        
        // 1. 스프린트 계획 최적화
        const optimizedPlan = await this.optimizeSprintPlan(sprint);
        
        // 2. 작업 자동 할당
        await this.assignTasks(optimizedPlan.tasks);
        
        // 3. 진행 상황 모니터링
        const monitor = this.startSprintMonitoring(sprint);
        
        // 4. 일일 자동화
        const dailyAutomation = this.setupDailyAutomation(sprint);
        
        // 스프린트 실행
        while (!this.isSprintComplete(sprint)) {
            // 작업 진행 상황 확인
            const progress = await this.checkProgress();
            
            // 병목 현상 감지 및 해결
            const bottlenecks = await this.detectBottlenecks(progress);
            if (bottlenecks.length > 0) {
                await this.resolveBottlenecks(bottlenecks);
            }
            
            // AI 추천 사항 생성
            const recommendations = await this.generateRecommendations(progress);
            await this.applyRecommendations(recommendations);
            
            // 대기
            await this.wait(3600000); // 1시간마다 체크
        }
        
        // 스프린트 회고
        return await this.conductRetrospective(sprint);
    }

    private async optimizeSprintPlan(sprint: Sprint): Promise<OptimizedSprint> {
        const prompt = `
스프린트 계획을 최적화해주세요:

스프린트 정보:
- 번호: ${sprint.number}
- 기간: ${sprint.duration} 일
- 팀 규모: ${sprint.teamSize} 명
- 목표: ${sprint.goals.join(', ')}

백로그:
${JSON.stringify(sprint.backlog, null, 2)}

팀 역량:
${JSON.stringify(this.getTeamCapabilities(), null, 2)}

최적화 기준:
1. 가치 전달 최대화
2. 리스크 최소화
3. 팀 역량 고려
4. 의존성 관리
5. 버퍼 시간 확보
`;

        const optimizationResponse = await this.cursor.ai.generateCode(prompt);
        return JSON.parse(optimizationResponse);
    }

    private async assignTasks(tasks: Task[]): Promise<void> {
        for (const task of tasks) {
            // AI 기반 최적 담당자 선정
            const bestAssignee = await this.findBestAssignee(task);
            
            // 작업 할당
            await this.assignTaskToMember(task, bestAssignee);
            
            // 자동화 가능 여부 확인
            if (await this.canAutomate(task)) {
                await this.setupTaskAutomation(task);
            }
        }
    }

    private async findBestAssignee(task: Task): Promise<TeamMember> {
        const candidates = Array.from(this.teamMembers.values());
        
        const scores = await Promise.all(
            candidates.map(async (member) => ({
                member,
                score: await this.calculateAssignmentScore(task, member)
            }))
        );
        
        return scores.sort((a, b) => b.score - a.score)[0].member;
    }

    async generateDailyReport(): Promise<DailyReport> {
        const report: DailyReport = {
            date: new Date(),
            summary: await this.generateSummary(),
            progress: await this.calculateProgress(),
            blockers: await this.identifyBlockers(),
            achievements: await this.listAchievements(),
            forecast: await this.forecastCompletion(),
            recommendations: await this.getDailyRecommendations()
        };
        
        // 시각화 생성
        report.visualizations = {
            burndown: await this.generateBurndownChart(),
            velocity: await this.generateVelocityChart(),
            teamHealth: await this.generateTeamHealthMetrics()
        };
        
        return report;
    }
}

// 자동 배포 시스템
export class AutoDeploymentSystem {
    private cursor: CursorAI;
    private environments: Map<string, Environment>;
    private deploymentHistory: DeploymentHistory[];
    private rollbackStrategy: RollbackStrategy;

    async deployFeature(feature: Feature, targetEnv: string = 'staging'): Promise<DeploymentResult> {
        console.log(`🚀 기능 배포: ${feature.name} → ${targetEnv}`);
        
        // 1. 배포 전 검증
        const validation = await this.validateDeployment(feature, targetEnv);
        if (!validation.passed) {
            throw new Error(`배포 검증 실패: ${validation.errors.join(', ')}`);
        }
        
        // 2. 배포 계획 생성
        const deploymentPlan = await this.createDeploymentPlan(feature, targetEnv);
        
        // 3. 점진적 배포 실행
        const result = await this.executeProgressiveDeployment(deploymentPlan);
        
        // 4. 모니터링 및 검증
        await this.monitorDeployment(result);
        
        // 5. 자동 롤백 또는 확정
        if (result.healthCheck.passed) {
            await this.finalizeDeployment(result);
        } else {
            await this.rollbackDeployment(result);
        }
        
        return result;
    }

    private async executeProgressiveDeployment(plan: DeploymentPlan): Promise<DeploymentResult> {
        const stages = [
            { name: 'canary', percentage: 5, duration: 300000 },    // 5분
            { name: 'partial', percentage: 25, duration: 900000 },   // 15분
            { name: 'majority', percentage: 50, duration: 1800000 }, // 30분
            { name: 'full', percentage: 100, duration: Infinity }
        ];
        
        const result: DeploymentResult = {
            id: this.generateDeploymentId(),
            feature: plan.feature,
            environment: plan.environment,
            stages: [],
            status: 'in_progress'
        };
        
        for (const stage of stages) {
            console.log(`📊 배포 단계: ${stage.name} (${stage.percentage}%)`);
            
            // 트래픽 라우팅 업데이트
            await this.updateTrafficRouting(plan, stage.percentage);
            
            // 헬스 체크
            const health = await this.performHealthCheck(plan, stage);
            
            result.stages.push({
                name: stage.name,
                percentage: stage.percentage,
                health,
                timestamp: Date.now()
            });
            
            if (!health.passed) {
                result.status = 'failed';
                break;
            }
            
            // 다음 단계 전 대기
            if (stage.duration !== Infinity) {
                await this.wait(stage.duration);
            }
        }
        
        if (result.status === 'in_progress') {
            result.status = 'completed';
        }
        
        return result;
    }

    async setupContinuousDeployment(project: Project): Promise<void> {
        // GitHub Actions 워크플로우 생성
        const workflow = `
name: Continuous Deployment
on:
  push:
    branches: [main]
  pull_request:
    types: [closed]

jobs:
  analyze:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: AI 코드 분석
        uses: cursor/analyze-action@v1
        with:
          check-quality: true
          check-security: true
          suggest-improvements: true
      
      - name: 위험도 평가
        id: risk
        run: |
          echo "::set-output name=level::$(cursor assess-risk)"
  
  test:
    needs: analyze
    runs-on: ubuntu-latest
    strategy:
      matrix:
        test-suite: [unit, integration, e2e]
    steps:
      - uses: actions/checkout@v3
      
      - name: 테스트 실행
        run: |
          cursor test run --suite ${{ matrix.test-suite }} \\
            --parallel \\
            --coverage \\
            --ai-generated
  
  deploy:
    needs: [analyze, test]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    steps:
      - uses: actions/checkout@v3
      
      - name: AI 배포 결정
        id: deploy-decision
        run: |
          DECISION=$(cursor deploy analyze \\
            --risk-level ${{ needs.analyze.outputs.risk-level }} \\
            --test-results ./test-results \\
            --production-metrics)
          echo "::set-output name=should-deploy::$DECISION"
      
      - name: 점진적 배포
        if: steps.deploy-decision.outputs.should-deploy == 'true'
        run: |
          cursor deploy progressive \\
            --environment production \\
            --strategy canary \\
            --auto-rollback \\
            --monitor-duration 30m
      
      - name: 배포 알림
        if: always()
        run: |
          cursor notify deployment \\
            --status ${{ job.status }} \\
            --channel slack \\
            --include-metrics
`;

        await this.saveWorkflow(project, '.github/workflows/cd.yml', workflow);
    }
}

// 자가 치유 시스템
export class SelfHealingSystem {
    private cursor: CursorAI;
    private monitors: Map<string, Monitor>;
    private healingStrategies: Map<string, HealingStrategy>;
    private incidentHistory: Incident[];

    async startMonitoring(service: Service): Promise<void> {
        const monitor = new Monitor({
            service,
            interval: 60000, // 1분
            metrics: ['cpu', 'memory', 'response_time', 'error_rate'],
            thresholds: await this.determineThresholds(service)
        });
        
        monitor.on('anomaly', async (anomaly) => {
            await this.handleAnomaly(anomaly);
        });
        
        monitor.on('incident', async (incident) => {
            await this.handleIncident(incident);
        });
        
        this.monitors.set(service.id, monitor);
        monitor.start();
    }

    private async handleIncident(incident: Incident): Promise<void> {
        console.log(`🚨 인시던트 감지: ${incident.type}`);
        
        // 1. 근본 원인 분석
        const rootCause = await this.analyzeRootCause(incident);
        
        // 2. 치유 전략 선택
        const strategy = await this.selectHealingStrategy(incident, rootCause);
        
        // 3. 자동 치유 실행
        const healingResult = await this.executeHealing(strategy, incident);
        
        // 4. 검증
        const verification = await this.verifyHealing(healingResult);
        
        // 5. 학습
        await this.learnFromIncident(incident, healingResult);
        
        // 6. 보고
        await this.reportIncident(incident, healingResult);
    }

    private async selectHealingStrategy(
        incident: Incident, 
        rootCause: RootCause
    ): Promise<HealingStrategy> {
        // 기존 전략 확인
        const existingStrategy = this.healingStrategies.get(incident.type);
        if (existingStrategy && existingStrategy.successRate > 0.8) {
            return existingStrategy;
        }
        
        // AI로 새로운 전략 생성
        const prompt = `
인시던트에 대한 자가 치유 전략을 생성해주세요:

인시던트:
${JSON.stringify(incident, null, 2)}

근본 원인:
${JSON.stringify(rootCause, null, 2)}

시스템 상태:
${JSON.stringify(await this.getSystemState(), null, 2)}

다음을 포함한 전략을 제시해주세요:
1. 즉각적인 완화 조치
2. 근본적인 해결 방법
3. 예상 복구 시간
4. 부작용 및 위험
5. 롤백 계획
`;

        const strategyResponse = await this.cursor.ai.generateCode(prompt);
        const strategy = JSON.parse(strategyResponse);
        
        return {
            id: this.generateStrategyId(),
            type: incident.type,
            steps: strategy.steps,
            estimatedDuration: strategy.estimatedDuration,
            risks: strategy.risks,
            rollback: strategy.rollback
        };
    }

    private async executeHealing(
        strategy: HealingStrategy, 
        incident: Incident
    ): Promise<HealingResult> {
        const result: HealingResult = {
            strategy: strategy.id,
            incident: incident.id,
            steps: [],
            status: 'in_progress'
        };
        
        for (const step of strategy.steps) {
            try {
                console.log(`💊 치유 단계 실행: ${step.name}`);
                
                const stepResult = await this.executeHealingStep(step);
                result.steps.push(stepResult);
                
                // 각 단계 후 상태 확인
                if (await this.isIncidentResolved(incident)) {
                    result.status = 'resolved';
                    break;
                }
            } catch (error) {
                result.status = 'failed';
                result.error = error;
                
                // 롤백
                if (strategy.rollback) {
                    await this.executeRollback(strategy.rollback, result);
                }
                break;
            }
        }
        
        return result;
    }

    async generateHealthReport(): Promise<HealthReport> {
        const services = Array.from(this.monitors.keys());
        const report: HealthReport = {
            timestamp: new Date(),
            overall: 'healthy',
            services: {},
            incidents: {
                last24h: 0,
                resolved: 0,
                mttr: 0 // Mean Time To Repair
            },
            predictions: await this.predictFutureIncidents()
        };
        
        for (const serviceId of services) {
            const monitor = this.monitors.get(serviceId)!;
            const metrics = await monitor.getMetrics();
            
            report.services[serviceId] = {
                status: this.calculateServiceHealth(metrics),
                uptime: monitor.getUptime(),
                performance: metrics,
                issues: await this.getActiveIssues(serviceId)
            };
        }
        
        // 전체 건강 상태 계산
        const unhealthyServices = Object.values(report.services)
            .filter(s => s.status !== 'healthy').length;
        
        if (unhealthyServices > services.length * 0.3) {
            report.overall = 'critical';
        } else if (unhealthyServices > 0) {
            report.overall = 'degraded';
        }
        
        return report;
    }
}

// 팀 협업 자동화
export class TeamCollaborationAutomation {
    private cursor: CursorAI;
    private communicator: TeamCommunicator;
    private knowledgeBase: KnowledgeBase;

    async facilitateCodeReview(pr: PullRequest): Promise<ReviewResult> {
        console.log(`👥 코드 리뷰 자동화: PR #${pr.number}`);
        
        // 1. AI 사전 리뷰
        const aiReview = await this.performAIReview(pr);
        
        // 2. 관련 전문가 자동 할당
        const reviewers = await this.assignReviewers(pr, aiReview);
        
        // 3. 리뷰 가이드 생성
        const reviewGuide = await this.generateReviewGuide(pr, aiReview);
        
        // 4. 리뷰 진행 모니터링
        const reviewProcess = await this.monitorReviewProcess(pr, reviewers);
        
        // 5. 합의 도출 지원
        const consensus = await this.facilitateConsensus(reviewProcess);
        
        return {
            pr,
            aiReview,
            humanReviews: reviewProcess.reviews,
            consensus,
            mergeRecommendation: await this.generateMergeRecommendation(consensus)
        };
    }

    private async assignReviewers(pr: PullRequest, aiReview: AIReview): Promise<Reviewer[]> {
        // 변경된 코드 분석
        const changedAreas = this.analyzeChangedAreas(pr);
        
        // 전문성 매칭
        const expertiseNeeded = await this.determineRequiredExpertise(changedAreas, aiReview);
        
        // 팀원 가용성 확인
        const availability = await this.checkTeamAvailability();
        
        // 최적 리뷰어 선정
        const reviewers = await this.selectOptimalReviewers(
            expertiseNeeded,
            availability,
            pr.urgency
        );
        
        // 리뷰 요청 전송
        for (const reviewer of reviewers) {
            await this.sendReviewRequest(reviewer, pr, {
                focusAreas: expertiseNeeded.filter(e => reviewer.expertise.includes(e)),
                estimatedTime: this.estimateReviewTime(pr, reviewer),
                aiInsights: aiReview.keyPoints
            });
        }
        
        return reviewers;
    }

    async automateStandupMeeting(): Promise<StandupSummary> {
        const teamMembers = await this.getActiveTeamMembers();
        const updates: MemberUpdate[] = [];
        
        for (const member of teamMembers) {
            // 자동으로 진행 상황 수집
            const progress = await this.collectMemberProgress(member);
            
            // AI로 업데이트 요약 생성
            const update = await this.generateMemberUpdate(member, progress);
            
            updates.push(update);
        }
        
        // 팀 전체 요약 생성
        const summary = await this.generateTeamSummary(updates);
        
        // 액션 아이템 추출
        const actionItems = await this.extractActionItems(updates);
        
        // 자동 후속 조치
        await this.scheduleFollowUps(actionItems);
        
        return {
            date: new Date(),
            updates,
            summary,
            actionItems,
            nextSteps: await this.suggestNextSteps(summary)
        };
    }

    async shareKnowledge(learning: Learning): Promise<void> {
        // 1. 학습 내용 구조화
        const structured = await this.structureLearning(learning);
        
        // 2. 관련성 분석
        const relevance = await this.analyzeRelevance(structured);
        
        // 3. 적절한 형식으로 변환
        const formats = await this.generateFormats(structured, relevance);
        
        // 4. 대상별 배포
        for (const target of relevance.targets) {
            const format = formats[target.preferredFormat];
            await this.distributeKnowledge(target, format);
        }
        
        // 5. 지식 베이스 업데이트
        await this.knowledgeBase.add(structured);
        
        // 6. Q&A 봇 학습
        await this.trainQABot(structured);
    }
}

// 통합 대시보드
export class IntegratedDashboard {
    private orchestrator: DevelopmentOrchestrator;
    private metrics: MetricsCollector;
    private visualizer: DataVisualizer;

    async renderDashboard(): Promise<DashboardView> {
        const data = await this.collectAllMetrics();
        
        return {
            overview: await this.renderOverview(data),
            development: await this.renderDevelopmentMetrics(data),
            quality: await this.renderQualityMetrics(data),
            deployment: await this.renderDeploymentMetrics(data),
            team: await this.renderTeamMetrics(data),
            ai: await this.renderAIMetrics(data),
            predictions: await this.renderPredictions(data)
        };
    }

    private async renderAIMetrics(data: MetricsData): Promise<AIMetricsView> {
        const aiUsage = await this.calculateAIUsage();
        const automationRate = await this.calculateAutomationRate();
        const timeSaved = await this.calculateTimeSaved();
        
        return {
            usage: {
                codeGeneration: aiUsage.codeGeneration,
                bugFixes: aiUsage.bugFixes,
                reviews: aiUsage.reviews,
                deployments: aiUsage.deployments
            },
            automation: {
                rate: automationRate,
                tasksAutomated: data.automatedTasks,
                manualTasks: data.manualTasks
            },
            efficiency: {
                timeSaved,
                costSaved: this.calculateCostSaved(timeSaved),
                qualityImprovement: await this.measureQualityImprovement()
            },
            insights: await this.generateAIInsights(data)
        };
    }

    async generateExecutiveSummary(): Promise<ExecutiveSummary> {
        const prompt = `
프로젝트의 전체적인 상태와 진행 상황을 경영진을 위해 요약해주세요:

프로젝트 메트릭:
${JSON.stringify(await this.getProjectMetrics(), null, 2)}

AI 활용도:
${JSON.stringify(await this.getAIUtilization(), null, 2)}

팀 성과:
${JSON.stringify(await this.getTeamPerformance(), null, 2)}

다음을 포함해주세요:
1. 핵심 성과 지표 (KPI)
2. 주요 성취 사항
3. 현재 리스크와 대응 방안
4. AI 자동화로 인한 효율성 개선
5. 향후 계획과 예측
6. 투자 대비 수익 (ROI)
`;

        const summary = await this.cursor.ai.generateCode(prompt);
        
        return {
            ...JSON.parse(summary),
            visualizations: await this.generateExecutiveCharts(),
            recommendations: await this.generateStrategicRecommendations()
        };
    }
}
</code></pre>
                    </div>
                </div>

                <h3>엔드투엔드 자동화 워크플로우</h3>
                <div class="e2e-automation">
                    <div class="workflow-implementation">
                        <h4>완전 자동화 개발 프로세스</h4>
                        <pre><code>// workflows/EndToEndAutomation.ts
export class EndToEndAutomation {
    private orchestrator: DevelopmentOrchestrator;
    private aiEngine: CursorAI;
    
    async handleUserStory(story: UserStory): Promise<StoryImplementation> {
        console.log(`📖 사용자 스토리 처리: ${story.title}`);
        
        // 1. 스토리 분석 및 분해
        const analysis = await this.analyzeUserStory(story);
        
        // 2. 기술 사양 자동 생성
        const specification = await this.generateTechnicalSpec(analysis);
        
        // 3. 아키텍처 설계
        const architecture = await this.designArchitecture(specification);
        
        // 4. 태스크 분해
        const tasks = await this.decomposeTasks(specification, architecture);
        
        // 5. 구현
        const implementation = await this.implementFeature(tasks);
        
        // 6. 테스트
        const testResults = await this.runComprehensiveTests(implementation);
        
        // 7. 문서화
        const documentation = await this.generateDocumentation(implementation);
        
        // 8. 배포
        const deployment = await this.deployToEnvironment(implementation, 'staging');
        
        // 9. 모니터링 설정
        await this.setupMonitoring(deployment);
        
        return {
            story,
            implementation,
            tests: testResults,
            documentation,
            deployment,
            metrics: await this.collectImplementationMetrics()
        };
    }

    private async analyzeUserStory(story: UserStory): Promise<StoryAnalysis> {
        const prompt = `
사용자 스토리를 분석하고 기술적 요구사항을 도출해주세요:

스토리: ${story.title}
상세: ${story.description}
인수 조건: ${story.acceptanceCriteria.join('\n')}

분석 내용:
1. 비즈니스 가치와 목적
2. 기술적 요구사항
3. 영향받는 시스템 컴포넌트
4. 필요한 데이터 모델 변경
5. API 엔드포인트
6. UI/UX 요구사항
7. 성능 요구사항
8. 보안 고려사항
9. 예상 복잡도와 소요 시간
`;

        const analysis = await this.aiEngine.generateCode(prompt);
        return JSON.parse(analysis);
    }

    private async implementFeature(tasks: Task[]): Promise<Implementation> {
        const implementation: Implementation = {
            files: [],
            tests: [],
            migrations: [],
            configurations: []
        };
        
        // 병렬 처리 가능한 태스크 식별
        const taskGraph = this.buildDependencyGraph(tasks);
        const parallelGroups = this.identifyParallelGroups(taskGraph);
        
        for (const group of parallelGroups) {
            await Promise.all(
                group.map(async (task) => {
                    const result = await this.implementTask(task);
                    implementation.files.push(...result.files);
                    implementation.tests.push(...result.tests);
                })
            );
        }
        
        // 통합 및 최적화
        await this.integrateAndOptimize(implementation);
        
        return implementation;
    }

    private async implementTask(task: Task): Promise<TaskImplementation> {
        const prompt = `
다음 태스크를 구현해주세요:

태스크: ${task.title}
설명: ${task.description}
타입: ${task.type}

기술 사양:
${JSON.stringify(task.specification, null, 2)}

기존 코드 컨텍스트:
${await this.getRelevantContext(task)}

요구사항:
- 클린 코드 원칙 준수
- 적절한 에러 처리
- 단위 테스트 포함
- 타입 안전성 보장
- 성능 최적화
`;

        const code = await this.aiEngine.generateCode(prompt);
        
        // 코드 파싱 및 파일 생성
        const files = this.parseGeneratedCode(code);
        
        // 테스트 생성
        const tests = await this.generateTestsForTask(task, files);
        
        return { task, files, tests };
    }

    async setupContinuousImprovement(): Promise<void> {
        // 지속적 개선 파이프라인 설정
        const improvementPipeline = {
            // 코드 품질 모니터링
            codeQuality: {
                schedule: '0 */6 * * *', // 6시간마다
                actions: [
                    'analyze-complexity',
                    'detect-code-smells',
                    'suggest-refactoring',
                    'update-documentation'
                ]
            },
            
            // 성능 최적화
            performance: {
                schedule: '0 2 * * *', // 매일 새벽 2시
                actions: [
                    'profile-application',
                    'identify-bottlenecks',
                    'generate-optimization-suggestions',
                    'test-optimizations'
                ]
            },
            
            // 보안 스캔
            security: {
                schedule: '0 */12 * * *', // 12시간마다
                actions: [
                    'dependency-scan',
                    'code-vulnerability-scan',
                    'penetration-testing',
                    'generate-security-patches'
                ]
            },
            
            // 기술 부채 관리
            technicalDebt: {
                schedule: '0 0 * * 0', // 매주 일요일
                actions: [
                    'identify-debt-items',
                    'prioritize-refactoring',
                    'generate-migration-plans',
                    'schedule-debt-reduction'
                ]
            }
        };
        
        // 각 파이프라인 활성화
        for (const [name, config] of Object.entries(improvementPipeline)) {
            await this.scheduleImprovement(name, config);
        }
    }
}

// 프로젝트 생성 마법사
export class ProjectCreationWizard {
    private cursor: CursorAI;
    private templates: ProjectTemplateLibrary;
    
    async createProjectFromIdea(idea: string): Promise<Project> {
        console.log('🎯 아이디어에서 프로젝트 생성 시작...');
        
        // 1. 아이디어 분석 및 구체화
        const projectConcept = await this.analyzeAndRefineIdea(idea);
        
        // 2. 시장 조사 및 경쟁 분석
        const marketAnalysis = await this.performMarketAnalysis(projectConcept);
        
        // 3. 기술 스택 추천
        const techStack = await this.recommendTechStack(projectConcept, marketAnalysis);
        
        // 4. 프로젝트 구조 생성
        const projectStructure = await this.generateProjectStructure(
            projectConcept,
            techStack
        );
        
        // 5. MVP 로드맵 생성
        const mvpRoadmap = await this.createMVPRoadmap(projectConcept);
        
        // 6. 초기 코드 생성
        const initialCode = await this.generateInitialCodebase(
            projectStructure,
            techStack,
            mvpRoadmap.phase1
        );
        
        // 7. 개발 환경 설정
        await this.setupDevelopmentEnvironment(projectStructure);
        
        // 8. CI/CD 파이프라인 구성
        await this.setupCICDPipeline(projectStructure);
        
        // 9. 모니터링 및 분석 도구 설정
        await this.setupMonitoringAndAnalytics(projectStructure);
        
        // 10. 팀 협업 도구 연동
        await this.integrateCollaborationTools(projectStructure);
        
        return {
            ...projectStructure,
            concept: projectConcept,
            marketAnalysis,
            mvpRoadmap,
            automationEnabled: true
        };
    }

    private async analyzeAndRefineIdea(idea: string): Promise<ProjectConcept> {
        const prompt = `
다음 아이디어를 분석하고 구체적인 프로젝트 컨셉으로 발전시켜주세요:

아이디어: ${idea}

다음을 포함해주세요:
1. 핵심 가치 제안 (Value Proposition)
2. 타겟 사용자 페르소나
3. 주요 기능 목록 (우선순위 포함)
4. 수익 모델 옵션
5. 기술적 도전 과제
6. 차별화 요소
7. 성공 지표 (KPIs)
8. 리스크와 대응 전략
`;

        const concept = await this.cursor.ai.generateCode(prompt);
        return JSON.parse(concept);
    }

    private async generateInitialCodebase(
        structure: ProjectStructure,
        techStack: TechStack,
        phase1Features: Feature[]
    ): Promise<Codebase> {
        const codebase: Codebase = {
            files: [],
            dependencies: {},
            scripts: {}
        };
        
        // 1. 기본 프로젝트 파일 생성
        const baseFiles = await this.generateBaseFiles(structure, techStack);
        codebase.files.push(...baseFiles);
        
        // 2. 아키텍처 레이어별 코드 생성
        for (const layer of ['domain', 'application', 'infrastructure', 'presentation']) {
            const layerCode = await this.generateLayerCode(layer, structure, techStack);
            codebase.files.push(...layerCode);
        }
        
        // 3. 기능별 코드 생성
        for (const feature of phase1Features) {
            const featureCode = await this.generateFeatureCode(feature, techStack);
            codebase.files.push(...featureCode);
        }
        
        // 4. 테스트 코드 생성
        const tests = await this.generateTestSuite(codebase.files);
        codebase.files.push(...tests);
        
        // 5. 문서 생성
        const documentation = await this.generateDocumentation(structure, techStack);
        codebase.files.push(...documentation);
        
        return codebase;
    }
}

// AI 기반 프로젝트 인사이트
export class ProjectInsightsEngine {
    private cursor: CursorAI;
    private analytics: AnalyticsService;
    
    async generateWeeklyInsights(project: Project): Promise<WeeklyInsights> {
        const insights: WeeklyInsights = {
            week: this.getCurrentWeek(),
            highlights: await this.getWeeklyHighlights(project),
            metrics: await this.calculateWeeklyMetrics(project),
            risks: await this.identifyEmergingRisks(project),
            opportunities: await this.identifyOpportunities(project),
            recommendations: await this.generateRecommendations(project),
            forecast: await this.generateForecast(project)
        };
        
        // AI 종합 분석
        const aiAnalysis = await this.performAIAnalysis(insights);
        insights.aiSummary = aiAnalysis;
        
        // 시각화 생성
        insights.visualizations = await this.generateVisualizations(insights);
        
        return insights;
    }

    private async identifyOpportunities(project: Project): Promise<Opportunity[]> {
        const opportunities: Opportunity[] = [];
        
        // 코드 재사용 기회
        const reusableComponents = await this.findReusableComponents(project);
        if (reusableComponents.length > 0) {
            opportunities.push({
                type: 'code-reuse',
                title: '재사용 가능한 컴포넌트 발견',
                description: `${reusableComponents.length}개의 컴포넌트를 라이브러리화할 수 있습니다.`,
                impact: 'high',
                effort: 'medium',
                savings: this.estimateTimeSavings(reusableComponents)
            });
        }
        
        // 자동화 기회
        const automationCandidates = await this.findAutomationOpportunities(project);
        opportunities.push(...automationCandidates);
        
        // 성능 최적화 기회
        const performanceOpportunities = await this.findPerformanceOpportunities(project);
        opportunities.push(...performanceOpportunities);
        
        // AI 활용 기회
        const aiOpportunities = await this.findAIOpportunities(project);
        opportunities.push(...aiOpportunities);
        
        return opportunities.sort((a, b) => {
            const impactScore = { high: 3, medium: 2, low: 1 };
            const effortScore = { low: 3, medium: 2, high: 1 };
            
            const aScore = impactScore[a.impact] * effortScore[a.effort];
            const bScore = impactScore[b.impact] * effortScore[b.effort];
            
            return bScore - aScore;
        });
    }

    async generateProjectHealthScore(project: Project): Promise<HealthScore> {
        const dimensions = {
            codeQuality: await this.assessCodeQuality(project),
            testCoverage: await this.assessTestCoverage(project),
            documentation: await this.assessDocumentation(project),
            performance: await this.assessPerformance(project),
            security: await this.assessSecurity(project),
            teamVelocity: await this.assessTeamVelocity(project),
            technicalDebt: await this.assessTechnicalDebt(project),
            userSatisfaction: await this.assessUserSatisfaction(project)
        };
        
        const overallScore = this.calculateOverallScore(dimensions);
        
        return {
            overall: overallScore,
            dimensions,
            trend: await this.calculateTrend(project),
            insights: await this.generateHealthInsights(dimensions),
            actionItems: await this.generateHealthActionItems(dimensions)
        };
    }
}
</code></pre>
                    </div>
                </div>
            </section>

            <section class="content-section">
                <h2><i class="fas fa-infinity"></i> 지속적 개선과 학습</h2>
                
                <h3>자가 개선 시스템</h3>
                <div class="self-improvement">
                    <div class="improvement-system">
                        <h4>AI 기반 지속적 최적화</h4>
                        <pre><code>// improvement/ContinuousImprovement.ts
export class ContinuousImprovementSystem {
    private cursor: CursorAI;
    private learningEngine: MachineLearningEngine;
    private metricsCollector: MetricsCollector;
    
    async startImprovementCycle(): Promise<void> {
        console.log('♾️ 지속적 개선 사이클 시작...');
        
        setInterval(async () => {
            await this.runImprovementCycle();
        }, 24 * 60 * 60 * 1000); // 매일 실행
    }

    private async runImprovementCycle(): Promise<ImprovementReport> {
        // 1. 현재 상태 분석
        const currentState = await this.analyzeCurrentState();
        
        // 2. 개선 기회 식별
        const opportunities = await this.identifyImprovements(currentState);
        
        // 3. 개선 사항 구현
        const implementations = await this.implementImprovements(opportunities);
        
        // 4. 효과 측정
        const results = await this.measureResults(implementations);
        
        // 5. 학습 및 조정
        await this.learnAndAdjust(results);
        
        return {
            cycle: this.getCurrentCycle(),
            improvements: implementations,
            results,
            nextSteps: await this.planNextCycle(results)
        };
    }

    private async identifyImprovements(state: SystemState): Promise<Improvement[]> {
        const improvements: Improvement[] = [];
        
        // 코드 품질 개선
        const codeImprovements = await this.analyzeCodeQuality(state.codebase);
        improvements.push(...codeImprovements);
        
        // 프로세스 개선
        const processImprovements = await this.analyzeProcesses(state.workflows);
        improvements.push(...processImprovements);
        
        // 자동화 개선
        const automationImprovements = await this.analyzeAutomation(state.automation);
        improvements.push(...automationImprovements);
        
        // AI 모델 개선
        const aiImprovements = await this.analyzeAIPerformance(state.aiMetrics);
        improvements.push(...aiImprovements);
        
        return improvements;
    }

    async generateImprovementRoadmap(horizon: number = 90): Promise<Roadmap> {
        const currentCapabilities = await this.assessCurrentCapabilities();
        const industryTrends = await this.analyzeIndustryTrends();
        const teamFeedback = await this.collectTeamFeedback();
        
        const prompt = `
${horizon}일 개선 로드맵을 생성해주세요:

현재 역량:
${JSON.stringify(currentCapabilities, null, 2)}

업계 트렌드:
${JSON.stringify(industryTrends, null, 2)}

팀 피드백:
${JSON.stringify(teamFeedback, null, 2)}

다음을 포함해주세요:
1. 단기 목표 (30일)
2. 중기 목표 (60일)
3. 장기 목표 (90일)
4. 각 목표의 구체적인 액션 아이템
5. 성공 지표
6. 필요한 리소스
7. 위험 요소와 대응 방안
`;

        const roadmap = await this.cursor.ai.generateCode(prompt);
        return JSON.parse(roadmap);
    }

    private async learnAndAdjust(results: ImprovementResults): Promise<void> {
        // 성공/실패 패턴 학습
        const patterns = this.extractPatterns(results);
        
        // ML 모델 업데이트
        await this.learningEngine.updateModel({
            features: patterns.features,
            outcomes: patterns.outcomes,
            feedback: results.feedback
        });
        
        // 전략 조정
        await this.adjustStrategies(patterns);
        
        // 지식 베이스 업데이트
        await this.updateKnowledgeBase(results.learnings);
    }
}

// 팀 생산성 극대화
export class TeamProductivityOptimizer {
    private cursor: CursorAI;
    private analytics: TeamAnalytics;
    
    async optimizeTeamWorkflow(team: Team): Promise<OptimizationResult> {
        // 1. 현재 워크플로우 분석
        const currentWorkflow = await this.analyzeCurrentWorkflow(team);
        
        // 2. 병목 지점 식별
        const bottlenecks = await this.identifyBottlenecks(currentWorkflow);
        
        // 3. 개인별 강점 분석
        const strengths = await this.analyzeIndividualStrengths(team);
        
        // 4. 최적화된 워크플로우 설계
        const optimizedWorkflow = await this.designOptimalWorkflow(
            team,
            bottlenecks,
            strengths
        );
        
        // 5. 자동화 도구 구현
        await this.implementAutomationTools(optimizedWorkflow);
        
        // 6. 팀 교육 및 온보딩
        await this.conductTraining(team, optimizedWorkflow);
        
        return {
            previousProductivity: currentWorkflow.productivity,
            newProductivity: optimizedWorkflow.estimatedProductivity,
            improvements: optimizedWorkflow.improvements,
            timeline: optimizedWorkflow.implementationTimeline
        };
    }

    async createPersonalizedDeveloperAssistant(developer: Developer): Promise<Assistant> {
        // 개발자 프로필 분석
        const profile = await this.analyzeDeveloperProfile(developer);
        
        // 맞춤형 어시스턴트 구성
        const assistant = new PersonalAssistant({
            developerId: developer.id,
            preferences: profile.preferences,
            strengths: profile.strengths,
            improvementAreas: profile.improvementAreas,
            learningStyle: profile.learningStyle
        });
        
        // 기능 설정
        assistant.addCapability('code-suggestions', {
            style: profile.codingStyle,
            complexity: profile.preferredComplexity,
            languages: profile.languages
        });
        
        assistant.addCapability('learning-recommendations', {
            topics: profile.interestAreas,
            difficulty: profile.skillLevel,
            format: profile.preferredLearningFormat
        });
        
        assistant.addCapability('productivity-coaching', {
            workPattern: profile.workPattern,
            focusAreas: profile.productivityChallenges,
            goals: profile.careerGoals
        });
        
        return assistant;
    }
}

// 미래 예측 시스템
export class FuturePredictionSystem {
    private cursor: CursorAI;
    private trendAnalyzer: TrendAnalyzer;
    
    async predictProjectFuture(project: Project, months: number = 6): Promise<ProjectPrediction> {
        const historicalData = await this.gatherHistoricalData(project);
        const marketTrends = await this.analyzeMarketTrends(project.domain);
        const teamDynamics = await this.analyzeTeamDynamics(project.team);
        
        const predictions = {
            timeline: await this.predictTimeline(project, months),
            challenges: await this.predictChallenges(project, months),
            opportunities: await this.predictOpportunities(project, months),
            resourceNeeds: await this.predictResourceNeeds(project, months),
            successProbability: await this.calculateSuccessProbability(project)
        };
        
        // AI 종합 예측
        const aiPrediction = await this.generateAIPrediction(
            project,
            predictions,
            historicalData,
            marketTrends
        );
        
        return {
            ...predictions,
            aiInsights: aiPrediction,
            recommendations: await this.generateFutureRecommendations(predictions),
            scenarios: await this.generateScenarios(project, predictions)
        };
    }

    private async generateScenarios(
        project: Project, 
        predictions: any
    ): Promise<Scenario[]> {
        return [
            {
                name: 'Best Case',
                probability: 0.2,
                description: await this.generateBestCaseScenario(project, predictions),
                outcomes: await this.predictBestCaseOutcomes(project)
            },
            {
                name: 'Most Likely',
                probability: 0.6,
                description: await this.generateMostLikelyScenario(project, predictions),
                outcomes: await this.predictMostLikelyOutcomes(project)
            },
            {
                name: 'Worst Case',
                probability: 0.2,
                description: await this.generateWorstCaseScenario(project, predictions),
                outcomes: await this.predictWorstCaseOutcomes(project),
                mitigationStrategies: await this.generateMitigationStrategies(project)
            }
        ];
    }
}
</code></pre>
                    </div>
                </div>
            </section>

            <section class="practice-section">
                <h2><i class="fas fa-laptop-code"></i> 실습: 완전 자동화 개발 환경 구축</h2>
                
                <div class="exercise">
                    <h3>과제: AI 기반 자동화 개발 플랫폼 구축</h3>
                    <p>다음 요구사항을 만족하는 종합 자동화 시스템을 구축하세요:</p>
                    
                    <div class="requirements">
                        <h4>요구사항:</h4>
                        <ul>
                            <li>자연어 요구사항에서 자동 코드 생성</li>
                            <li>지능형 프로젝트 관리 및 작업 할당</li>
                            <li>자동 테스트 생성 및 실행</li>
                            <li>CI/CD 파이프라인 자동 구성</li>
                            <li>실시간 모니터링과 자가 치유</li>
                            <li>팀 협업 자동화 도구</li>
                            <li>지속적 개선 시스템</li>
                        </ul>
                    </div>

                    <div class="hints">
                        <h4>힌트:</h4>
                        <ul>
                            <li>마이크로서비스 아키텍처로 구성</li>
                            <li>이벤트 주도 아키텍처 활용</li>
                            <li>GraphQL로 통합 API 제공</li>
                            <li>Kubernetes로 오케스트레이션</li>
                            <li>Prometheus + Grafana로 모니터링</li>
                            <li>GitHub Actions로 워크플로우 자동화</li>
                        </ul>
                    </div>
                </div>
            </section>

            <section class="summary-section">
                <h2><i class="fas fa-bookmark"></i> 핵심 요약</h2>
                <div class="summary-grid">
                    <div class="summary-item">
                        <h3>개발 자동화</h3>
                        <ul>
                            <li>요구사항에서 코드까지</li>
                            <li>자동 아키텍처 설계</li>
                            <li>지능형 코드 생성</li>
                        </ul>
                    </div>
                    <div class="summary-item">
                        <h3>프로젝트 관리</h3>
                        <ul>
                            <li>AI 기반 계획 수립</li>
                            <li>자동 작업 할당</li>
                            <li>실시간 진행 추적</li>
                        </ul>
                    </div>
                    <div class="summary-item">
                        <h3>품질 보증</h3>
                        <ul>
                            <li>자동 테스트 생성</li>
                            <li>지속적 모니터링</li>
                            <li>자가 치유 시스템</li>
                        </ul>
                    </div>
                    <div class="summary-item">
                        <h3>팀 협업</h3>
                        <ul>
                            <li>자동화된 워크플로우</li>
                            <li>지식 공유 시스템</li>
                            <li>생산성 최적화</li>
                        </ul>
                    </div>
                </div>
            </section>
        </main>

        <aside class="sidebar">
            <div class="progress-indicator">
                <h3>진행 상황</h3>
                <div class="progress-bar">
                    <div class="progress-fill" style="width: 93.33%;"></div>
                </div>
                <span>28/30 강의 (93.33%)</span>
            </div>

            <nav class="lesson-nav-sidebar">
                <h3>전체 강의</h3>
                <ul>
                    <li><a href="lesson26.html">제26강: 성능 프로파일링</a></li>
                    <li><a href="lesson27.html">제27강: AI 디버깅 도구</a></li>
                    <li class="current">제28강: 프로젝트 자동화</li>
                    <li><a href="lesson29.html">제29강: AI 개발 생태계</a></li>
                    <li><a href="lesson30.html">제30강: 미래 전망</a></li>
                </ul>
            </nav>

            <div class="study-tips">
                <h3>학습 팁</h3>
                <ul>
                    <li>작은 자동화부터 시작해서 점진적으로 확장하세요</li>
                    <li>팀의 실제 니즈에 맞춰 자동화를 설계하세요</li>
                    <li>자동화된 프로세스도 지속적인 개선이 필요합니다</li>
                    <li>인간의 창의성과 AI의 효율성을 조화롭게 결합하세요</li>
                </ul>
            </div>
        </aside>
    </div>

    <script src="../assets/lesson-script.js"></script>
</body>
</html>