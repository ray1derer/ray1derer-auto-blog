<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ì œ24ê°•: ë¬¸ì„œí™” ìë™í™”ì™€ API ìŠ¤í™ ìƒì„± | Cursor AI ë§ˆìŠ¤í„° í´ë˜ìŠ¤</title>
    <link rel="stylesheet" href="../assets/lesson-style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>
<body>
    <div class="lesson-container">
        <header class="lesson-header">
            <div class="lesson-title">
                <h1><i class="fas fa-book"></i> ì œ24ê°•: ë¬¸ì„œí™” ìë™í™”ì™€ API ìŠ¤í™ ìƒì„±</h1>
                <p class="lesson-subtitle">AIë¡œ ë§Œë“œëŠ” ì™„ë²½í•œ ê¸°ìˆ  ë¬¸ì„œì™€ API ëª…ì„¸</p>
            </div>
            <div class="lesson-meta">
                <span class="difficulty"><i class="fas fa-signal"></i> ë‚œì´ë„: ê³ ê¸‰</span>
                <span class="duration"><i class="fas fa-clock"></i> ì˜ˆìƒ ì‹œê°„: 65ë¶„</span>
                <span class="category"><i class="fas fa-folder"></i> ì¹´í…Œê³ ë¦¬: ê³ ê¸‰</span>
            </div>
        </header>

        <nav class="lesson-nav">
            <a href="lesson23.html" class="nav-link prev">
                <i class="fas fa-chevron-left"></i> ì´ì „ ê°•ì˜
            </a>
            <span class="nav-title">ì œ24ê°•: ë¬¸ì„œí™” ìë™í™”ì™€ API ìŠ¤í™ ìƒì„±</span>
            <a href="lesson25.html" class="nav-link next">
                ë‹¤ìŒ ê°•ì˜ <i class="fas fa-chevron-right"></i>
            </a>
        </nav>

        <main class="lesson-content">
            <section class="learning-objectives">
                <h2><i class="fas fa-bullseye"></i> í•™ìŠµ ëª©í‘œ</h2>
                <ul>
                    <li>ì½”ë“œì—ì„œ ìë™ìœ¼ë¡œ ë¬¸ì„œ ìƒì„±í•˜ê¸°</li>
                    <li>OpenAPI/Swagger ìŠ¤í™ ìë™ ìƒì„±</li>
                    <li>ì¸í„°ë™í‹°ë¸Œ API ë¬¸ì„œ ë§Œë“¤ê¸°</li>
                    <li>ë§ˆí¬ë‹¤ìš´ ê¸°ë°˜ ê¸°ìˆ  ë¬¸ì„œ ìë™í™”</li>
                    <li>ë‹¤êµ­ì–´ ë¬¸ì„œ ë²ˆì—­ê³¼ ê´€ë¦¬</li>
                </ul>
            </section>

            <section class="content-section">
                <h2><i class="fas fa-file-code"></i> ìë™ ë¬¸ì„œ ìƒì„± ì‹œìŠ¤í…œ</h2>
                
                <div class="info-box">
                    <p>Cursor AIëŠ” ì½”ë“œë¥¼ ë¶„ì„í•˜ì—¬ ìë™ìœ¼ë¡œ ë¬¸ì„œë¥¼ ìƒì„±í•©ë‹ˆë‹¤. JSDoc, TypeDoc, Swagger ë“± ë‹¤ì–‘í•œ ë¬¸ì„œ í˜•ì‹ì„ ì§€ì›í•˜ë©°, ì½”ë“œ ë³€ê²½ ì‹œ ë¬¸ì„œë„ ìë™ìœ¼ë¡œ ì—…ë°ì´íŠ¸ë©ë‹ˆë‹¤.</p>
                </div>

                <h3>ì§€ëŠ¥í˜• ë¬¸ì„œ ìƒì„±ê¸°</h3>
                <div class="doc-generator">
                    <div class="generator-implementation">
                        <h4>AI ê¸°ë°˜ ë¬¸ì„œ ìë™ ìƒì„± ì‹œìŠ¤í…œ</h4>
                        <pre><code>// tools/AIDocumentationGenerator.ts
import { CursorAI } from '@cursor/api';
import { Project, SourceFile, ClassDeclaration, FunctionDeclaration } from 'ts-morph';
import * as fs from 'fs/promises';
import * as path from 'path';
import { marked } from 'marked';

export class AIDocumentationGenerator {
    private cursor: CursorAI;
    private project: Project;
    private config: DocGeneratorConfig;

    constructor(config: DocGeneratorConfig) {
        this.cursor = new CursorAI();
        this.project = new Project({
            tsConfigFilePath: config.tsConfigPath,
            skipAddingFilesFromTsConfig: false
        });
        this.config = config;
    }

    async generateDocumentation(): Promise<Documentation> {
        const docs: Documentation = {
            overview: await this.generateOverview(),
            modules: await this.generateModuleDocs(),
            api: await this.generateAPIDocs(),
            examples: await this.generateExamples(),
            guides: await this.generateGuides(),
            changelog: await this.generateChangelog()
        };

        // ë¬¸ì„œ ë Œë”ë§
        await this.renderDocumentation(docs);
        
        // ë‹¤êµ­ì–´ ë²ˆì—­
        if (this.config.languages?.length > 0) {
            await this.translateDocumentation(docs);
        }

        return docs;
    }

    async generateOverview(): Promise<ProjectOverview> {
        const projectFiles = this.project.getSourceFiles();
        
        const prompt = `
í”„ë¡œì íŠ¸ êµ¬ì¡°ë¥¼ ë¶„ì„í•˜ì—¬ í¬ê´„ì ì¸ ê°œìš” ë¬¸ì„œë¥¼ ì‘ì„±í•´ì£¼ì„¸ìš”:

íŒŒì¼ ìˆ˜: ${projectFiles.length}
ì£¼ìš” ë””ë ‰í† ë¦¬: ${this.getMainDirectories()}

ë‹¤ìŒ ë‚´ìš©ì„ í¬í•¨í•´ì£¼ì„¸ìš”:
1. í”„ë¡œì íŠ¸ ëª©ì ê³¼ ì£¼ìš” ê¸°ëŠ¥
2. ì•„í‚¤í…ì²˜ ê°œìš”
3. í•µì‹¬ ì»´í¬ë„ŒíŠ¸ ì„¤ëª…
4. ê¸°ìˆ  ìŠ¤íƒ
5. ì‹œì‘í•˜ê¸° ê°€ì´ë“œ
`;

        const response = await this.cursor.ai.generateCode(prompt);
        
        return {
            title: this.config.projectName,
            description: response,
            architecture: await this.generateArchitectureDiagram(),
            techStack: await this.detectTechStack(),
            quickStart: await this.generateQuickStart()
        };
    }

    async generateModuleDocs(): Promise<ModuleDocumentation[]> {
        const modules: ModuleDocumentation[] = [];
        const sourceFiles = this.project.getSourceFiles();

        for (const file of sourceFiles) {
            const module = await this.documentModule(file);
            if (module) {
                modules.push(module);
            }
        }

        return modules;
    }

    async documentModule(file: SourceFile): Promise<ModuleDocumentation | null> {
        const filePath = file.getFilePath();
        
        // í…ŒìŠ¤íŠ¸ íŒŒì¼ì´ë‚˜ ì„¤ì • íŒŒì¼ì€ ì œì™¸
        if (this.shouldSkipFile(filePath)) {
            return null;
        }

        const classes = file.getClasses();
        const functions = file.getFunctions();
        const interfaces = file.getInterfaces();
        const enums = file.getEnums();

        if (classes.length === 0 && functions.length === 0 && 
            interfaces.length === 0 && enums.length === 0) {
            return null;
        }

        const moduleDoc: ModuleDocumentation = {
            name: path.basename(filePath, path.extname(filePath)),
            path: filePath,
            description: await this.generateModuleDescription(file),
            exports: {
                classes: await Promise.all(classes.map(c => this.documentClass(c))),
                functions: await Promise.all(functions.map(f => this.documentFunction(f))),
                interfaces: await Promise.all(interfaces.map(i => this.documentInterface(i))),
                enums: await Promise.all(enums.map(e => this.documentEnum(e)))
            },
            examples: await this.generateModuleExamples(file),
            dependencies: this.extractDependencies(file)
        };

        return moduleDoc;
    }

    async documentClass(classDecl: ClassDeclaration): Promise<ClassDocumentation> {
        const className = classDecl.getName() || 'Anonymous';
        const methods = classDecl.getMethods();
        const properties = classDecl.getProperties();
        const constructor = classDecl.getConstructors()[0];

        // ê¸°ì¡´ JSDoc ì¶”ì¶œ
        const existingDoc = this.extractJSDoc(classDecl);

        // AIë¡œ ë¬¸ì„œ ë³´ê°•
        const enhancedDoc = await this.enhanceDocumentation(
            className,
            classDecl.getText(),
            existingDoc
        );

        return {
            name: className,
            description: enhancedDoc.description,
            extends: classDecl.getExtends()?.getText(),
            implements: classDecl.getImplements().map(i => i.getText()),
            constructor: constructor ? await this.documentConstructor(constructor) : undefined,
            properties: await Promise.all(properties.map(p => this.documentProperty(p))),
            methods: await Promise.all(methods.map(m => this.documentMethod(m))),
            examples: enhancedDoc.examples,
            usage: enhancedDoc.usage,
            relatedClasses: await this.findRelatedClasses(classDecl)
        };
    }

    async documentFunction(func: FunctionDeclaration): Promise<FunctionDocumentation> {
        const funcName = func.getName() || 'Anonymous';
        const parameters = func.getParameters();
        const returnType = func.getReturnType();

        const prompt = `
í•¨ìˆ˜ë¥¼ ë¶„ì„í•˜ì—¬ ë¬¸ì„œë¥¼ ì‘ì„±í•´ì£¼ì„¸ìš”:

í•¨ìˆ˜ëª…: ${funcName}
ì½”ë“œ:
\`\`\`typescript
${func.getText()}
\`\`\`

ë‹¤ìŒì„ í¬í•¨í•´ì£¼ì„¸ìš”:
1. í•¨ìˆ˜ì˜ ëª©ì ê³¼ ë™ì‘ ì„¤ëª…
2. ê° ë§¤ê°œë³€ìˆ˜ì˜ ìƒì„¸ ì„¤ëª…
3. ë°˜í™˜ê°’ ì„¤ëª…
4. ì‚¬ìš© ì˜ˆì œ (2-3ê°œ)
5. ì˜ˆì™¸ ìƒí™©ê³¼ ì—ëŸ¬ ì²˜ë¦¬
6. ë³µì¡ë„ì™€ ì„±ëŠ¥ ê³ ë ¤ì‚¬í•­
`;

        const aiDoc = await this.cursor.ai.generateCode(prompt);
        const parsedDoc = this.parseAIDocumentation(aiDoc);

        return {
            name: funcName,
            description: parsedDoc.description,
            parameters: parameters.map((param, index) => ({
                name: param.getName(),
                type: param.getType().getText(),
                description: parsedDoc.parameters?.[index]?.description || '',
                optional: param.isOptional(),
                default: param.getInitializer()?.getText()
            })),
            returns: {
                type: returnType.getText(),
                description: parsedDoc.returns?.description || ''
            },
            throws: parsedDoc.throws || [],
            examples: parsedDoc.examples || [],
            complexity: this.calculateComplexity(func),
            sideEffects: parsedDoc.sideEffects || [],
            relatedFunctions: await this.findRelatedFunctions(func)
        };
    }

    async generateAPIDocs(): Promise<APIDocumentation> {
        const apiEndpoints = await this.detectAPIEndpoints();
        const openApiSpec = await this.generateOpenAPISpec(apiEndpoints);

        return {
            openapi: openApiSpec,
            endpoints: await Promise.all(
                apiEndpoints.map(endpoint => this.documentEndpoint(endpoint))
            ),
            authentication: await this.documentAuthentication(),
            rateLimiting: await this.documentRateLimiting(),
            errors: await this.documentErrorResponses(),
            webhooks: await this.documentWebhooks(),
            postmanCollection: await this.generatePostmanCollection(apiEndpoints)
        };
    }

    async generateOpenAPISpec(endpoints: APIEndpoint[]): Promise<OpenAPISpec> {
        const spec: OpenAPISpec = {
            openapi: '3.1.0',
            info: {
                title: this.config.projectName,
                version: this.config.version || '1.0.0',
                description: await this.generateAPIDescription(),
                contact: this.config.contact,
                license: this.config.license
            },
            servers: this.config.servers || [],
            paths: {},
            components: {
                schemas: {},
                securitySchemes: {},
                parameters: {},
                responses: {}
            },
            security: []
        };

        // ê° ì—”ë“œí¬ì¸íŠ¸ë¥¼ OpenAPI ê²½ë¡œë¡œ ë³€í™˜
        for (const endpoint of endpoints) {
            const path = endpoint.path;
            if (!spec.paths[path]) {
                spec.paths[path] = {};
            }

            spec.paths[path][endpoint.method.toLowerCase()] = {
                summary: endpoint.summary,
                description: endpoint.description,
                operationId: endpoint.operationId,
                tags: endpoint.tags,
                parameters: await this.generateParameters(endpoint),
                requestBody: await this.generateRequestBody(endpoint),
                responses: await this.generateResponses(endpoint),
                security: endpoint.security || []
            };
        }

        // ìŠ¤í‚¤ë§ˆ ìë™ ìƒì„±
        spec.components.schemas = await this.generateSchemas();

        return spec;
    }

    async documentEndpoint(endpoint: APIEndpoint): Promise<EndpointDocumentation> {
        const prompt = `
API ì—”ë“œí¬ì¸íŠ¸ë¥¼ ë¶„ì„í•˜ì—¬ ìƒì„¸ ë¬¸ì„œë¥¼ ì‘ì„±í•´ì£¼ì„¸ìš”:

ê²½ë¡œ: ${endpoint.method} ${endpoint.path}
í•¸ë“¤ëŸ¬ ì½”ë“œ:
\`\`\`typescript
${endpoint.handler}
\`\`\`

ë‹¤ìŒ ë‚´ìš©ì„ í¬í•¨í•´ì£¼ì„¸ìš”:
1. ì—”ë“œí¬ì¸íŠ¸ì˜ ëª©ì ê³¼ ê¸°ëŠ¥
2. ìš”ì²­ ë§¤ê°œë³€ìˆ˜ ìƒì„¸ ì„¤ëª…
3. ìš”ì²­ ë³¸ë¬¸ í˜•ì‹ê³¼ ì˜ˆì œ
4. ì‘ë‹µ í˜•ì‹ê³¼ ìƒíƒœ ì½”ë“œ
5. ì¸ì¦ ìš”êµ¬ì‚¬í•­
6. ì‚¬ìš© ì˜ˆì œ (cURL, JavaScript, Python)
7. ì¼ë°˜ì ì¸ ì—ëŸ¬ ì‹œë‚˜ë¦¬ì˜¤
`;

        const aiDoc = await this.cursor.ai.generateCode(prompt);
        const examples = await this.generateAPIExamples(endpoint);

        return {
            ...endpoint,
            detailedDescription: aiDoc,
            examples: {
                curl: examples.curl,
                javascript: examples.javascript,
                python: examples.python,
                go: examples.go
            },
            testing: {
                unitTests: await this.generateEndpointTests(endpoint),
                integrationTests: await this.generateIntegrationTests(endpoint)
            },
            performance: {
                expectedLatency: await this.estimateLatency(endpoint),
                rateLimit: endpoint.rateLimit,
                caching: endpoint.caching
            }
        };
    }

    async generateExamples(): Promise<ExampleCollection> {
        const examples: ExampleCollection = {
            quickStart: [],
            useCases: [],
            integrations: [],
            troubleshooting: []
        };

        // ë¹ ë¥¸ ì‹œì‘ ì˜ˆì œ
        examples.quickStart.push({
            title: 'ê¸°ë³¸ ì„¤ì •',
            description: 'í”„ë¡œì íŠ¸ ì´ˆê¸° ì„¤ì • ë°©ë²•',
            code: await this.generateQuickStartExample(),
            language: 'typescript'
        });

        // ì‚¬ìš© ì‚¬ë¡€ë³„ ì˜ˆì œ
        const useCases = await this.detectUseCases();
        for (const useCase of useCases) {
            examples.useCases.push({
                title: useCase.title,
                description: useCase.description,
                code: await this.generateUseCaseExample(useCase),
                explanation: await this.explainExample(useCase)
            });
        }

        // í†µí•© ì˜ˆì œ
        examples.integrations = await this.generateIntegrationExamples();

        // ë¬¸ì œ í•´ê²° ê°€ì´ë“œ
        examples.troubleshooting = await this.generateTroubleshootingGuides();

        return examples;
    }

    async generateGuides(): Promise<GuideCollection> {
        const guides: GuideCollection = {
            gettingStarted: await this.generateGettingStartedGuide(),
            architecture: await this.generateArchitectureGuide(),
            bestPractices: await this.generateBestPracticesGuide(),
            deployment: await this.generateDeploymentGuide(),
            migration: await this.generateMigrationGuide(),
            contributing: await this.generateContributingGuide()
        };

        return guides;
    }

    async generateArchitectureGuide(): Promise<ArchitectureGuide> {
        const prompt = `
í”„ë¡œì íŠ¸ì˜ ì•„í‚¤í…ì²˜ ê°€ì´ë“œë¥¼ ì‘ì„±í•´ì£¼ì„¸ìš”:

í”„ë¡œì íŠ¸ êµ¬ì¡°:
${this.getProjectStructure()}

ë‹¤ìŒ ë‚´ìš©ì„ í¬í•¨í•´ì£¼ì„¸ìš”:
1. ì „ì²´ ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜
2. ì£¼ìš” ì»´í¬ë„ŒíŠ¸ì™€ ì±…ì„
3. ë°ì´í„° íë¦„
4. ë””ìì¸ íŒ¨í„´ê³¼ ì›ì¹™
5. í™•ì¥ì„± ê³ ë ¤ì‚¬í•­
6. ë³´ì•ˆ ì•„í‚¤í…ì²˜
7. ì„±ëŠ¥ ìµœì í™” ì „ëµ
`;

        const aiGuide = await this.cursor.ai.generateCode(prompt);
        
        return {
            overview: aiGuide,
            diagrams: await this.generateArchitectureDiagrams(),
            components: await this.documentComponents(),
            patterns: await this.documentDesignPatterns(),
            dataFlow: await this.documentDataFlow(),
            security: await this.documentSecurityArchitecture(),
            scalability: await this.documentScalabilityConsiderations()
        };
    }

    async renderDocumentation(docs: Documentation): Promise<void> {
        const outputDir = this.config.outputDir || './docs';
        
        // ë””ë ‰í† ë¦¬ êµ¬ì¡° ìƒì„±
        await this.createDocumentationStructure(outputDir);

        // ë©”ì¸ ë¬¸ì„œ ë Œë”ë§
        await this.renderMainDocumentation(docs, outputDir);

        // API ë¬¸ì„œ ë Œë”ë§
        await this.renderAPIDocumentation(docs.api, path.join(outputDir, 'api'));

        // ê°€ì´ë“œ ë Œë”ë§
        await this.renderGuides(docs.guides, path.join(outputDir, 'guides'));

        // ì¸í„°ë™í‹°ë¸Œ ë¬¸ì„œ ìƒì„±
        if (this.config.interactive) {
            await this.generateInteractiveDocs(docs, outputDir);
        }

        // ê²€ìƒ‰ ì¸ë±ìŠ¤ ìƒì„±
        await this.generateSearchIndex(docs, outputDir);
    }

    async generateInteractiveDocs(docs: Documentation, outputDir: string): Promise<void> {
        // Docusaurus ì„¤ì • ìƒì„±
        const docusaurusConfig = {
            title: this.config.projectName,
            tagline: docs.overview.description.split('\n')[0],
            url: this.config.url || 'https://example.com',
            baseUrl: this.config.baseUrl || '/',
            onBrokenLinks: 'throw',
            onBrokenMarkdownLinks: 'warn',
            favicon: 'img/favicon.ico',
            organizationName: this.config.organization,
            projectName: this.config.projectName,
            
            presets: [
                [
                    'classic',
                    {
                        docs: {
                            sidebarPath: require.resolve('./sidebars.js'),
                            editUrl: this.config.editUrl
                        },
                        blog: false,
                        theme: {
                            customCss: require.resolve('./src/css/custom.css')
                        }
                    }
                ]
            ],

            themeConfig: {
                navbar: {
                    title: this.config.projectName,
                    items: [
                        {
                            type: 'doc',
                            docId: 'intro',
                            position: 'left',
                            label: 'ë¬¸ì„œ'
                        },
                        {
                            to: '/api',
                            label: 'API',
                            position: 'left'
                        },
                        {
                            href: this.config.githubUrl,
                            label: 'GitHub',
                            position: 'right'
                        }
                    ]
                },
                footer: {
                    style: 'dark',
                    copyright: `Copyright Â© ${new Date().getFullYear()} ${this.config.organization}`
                },
                prism: {
                    theme: lightCodeTheme,
                    darkTheme: darkCodeTheme,
                    additionalLanguages: ['typescript', 'javascript', 'python', 'go']
                }
            }
        };

        // Docusaurus í”„ë¡œì íŠ¸ ìƒì„±
        await this.createDocusaurusProject(docusaurusConfig, outputDir);
        
        // API í”Œë ˆì´ê·¸ë¼ìš´ë“œ ìƒì„±
        await this.createAPIPlayground(docs.api, path.join(outputDir, 'static', 'api-playground'));
    }

    async translateDocumentation(docs: Documentation): Promise<void> {
        const languages = this.config.languages || [];
        
        for (const lang of languages) {
            const translatedDocs = await this.translateToLanguage(docs, lang);
            await this.renderDocumentation(translatedDocs);
        }
    }

    async translateToLanguage(docs: Documentation, targetLang: string): Promise<Documentation> {
        const prompt = `
ë‹¤ìŒ ê¸°ìˆ  ë¬¸ì„œë¥¼ ${targetLang}ë¡œ ë²ˆì—­í•´ì£¼ì„¸ìš”.
ê¸°ìˆ  ìš©ì–´ëŠ” ì ì ˆíˆ í˜„ì§€í™”í•˜ë˜, ì½”ë“œì™€ API ì´ë¦„ì€ ê·¸ëŒ€ë¡œ ìœ ì§€í•´ì£¼ì„¸ìš”.

ì›ë³¸:
${JSON.stringify(docs, null, 2)}
`;

        const translatedContent = await this.cursor.ai.generateCode(prompt);
        return JSON.parse(translatedContent);
    }

    async generateSearchIndex(docs: Documentation, outputDir: string): Promise<void> {
        const searchIndex = [];
        
        // ëª¨ë“  ë¬¸ì„œì—ì„œ ê²€ìƒ‰ ê°€ëŠ¥í•œ ì½˜í…ì¸  ì¶”ì¶œ
        this.extractSearchableContent(docs, searchIndex);
        
        // Algolia DocSearch í˜¸í™˜ ì¸ë±ìŠ¤ ìƒì„±
        const algoliaIndex = {
            index_name: this.config.projectName,
            start_urls: [this.config.url],
            selectors: {
                lvl0: '.doc h1',
                lvl1: '.doc h2',
                lvl2: '.doc h3',
                text: '.doc p, .doc li'
            }
        };

        await fs.writeFile(
            path.join(outputDir, 'search-index.json'),
            JSON.stringify(searchIndex, null, 2)
        );

        await fs.writeFile(
            path.join(outputDir, 'algolia-config.json'),
            JSON.stringify(algoliaIndex, null, 2)
        );
    }
}

// ìë™ ë¬¸ì„œí™” ì›Œí¬í”Œë¡œìš°
export async function generateProjectDocumentation() {
    const generator = new AIDocumentationGenerator({
        projectName: 'My Awesome Project',
        tsConfigPath: './tsconfig.json',
        outputDir: './docs',
        interactive: true,
        languages: ['ko', 'ja', 'zh'],
        servers: [
            { url: 'https://api.example.com', description: 'Production' },
            { url: 'https://staging-api.example.com', description: 'Staging' }
        ]
    });

    console.log('ğŸ“š ë¬¸ì„œ ìƒì„± ì‹œì‘...');
    const docs = await generator.generateDocumentation();
    
    console.log('âœ… ë¬¸ì„œ ìƒì„± ì™„ë£Œ!');
    console.log(`ğŸ“ ì¶œë ¥ ìœ„ì¹˜: ${generator.config.outputDir}`);
    
    // ë¬¸ì„œ ë¯¸ë¦¬ë³´ê¸° ì„œë²„ ì‹¤í–‰
    if (generator.config.preview) {
        await startDocumentationServer(generator.config.outputDir);
    }
}
</code></pre>
                    </div>
                </div>

                <h3>API ë¬¸ì„œ ìë™ ìƒì„±</h3>
                <div class="api-doc-generator">
                    <div class="api-doc-implementation">
                        <h4>OpenAPI/Swagger ìŠ¤í™ ìë™ ìƒì„±</h4>
                        <pre><code>// decorators/api-documentation.ts
import 'reflect-metadata';

// API ë¬¸ì„œí™”ë¥¼ ìœ„í•œ ë°ì½”ë ˆì´í„°
export function ApiDoc(options: ApiDocOptions) {
    return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
        Reflect.defineMetadata('api-doc', options, target, propertyKey);
    };
}

export function ApiParam(name: string, options: ParamOptions) {
    return function (target: any, propertyKey: string, parameterIndex: number) {
        const existingParams = Reflect.getMetadata('api-params', target, propertyKey) || [];
        existingParams[parameterIndex] = { name, ...options };
        Reflect.defineMetadata('api-params', existingParams, target, propertyKey);
    };
}

export function ApiResponse(status: number, options: ResponseOptions) {
    return function (target: any, propertyKey: string) {
        const existingResponses = Reflect.getMetadata('api-responses', target, propertyKey) || {};
        existingResponses[status] = options;
        Reflect.defineMetadata('api-responses', existingResponses, target, propertyKey);
    };
}

// ì‚¬ìš© ì˜ˆì‹œ
export class UserController {
    @ApiDoc({
        summary: 'ì‚¬ìš©ì ëª©ë¡ ì¡°íšŒ',
        description: 'í˜ì´ì§€ë„¤ì´ì…˜ì„ ì§€ì›í•˜ëŠ” ì‚¬ìš©ì ëª©ë¡ì„ ì¡°íšŒí•©ë‹ˆë‹¤.',
        tags: ['Users'],
        security: [{ bearerAuth: [] }]
    })
    @ApiResponse(200, {
        description: 'ì„±ê³µ',
        schema: {
            type: 'object',
            properties: {
                users: {
                    type: 'array',
                    items: { $ref: '#/components/schemas/User' }
                },
                pagination: { $ref: '#/components/schemas/Pagination' }
            }
        }
    })
    @ApiResponse(401, { description: 'ì¸ì¦ ì‹¤íŒ¨' })
    async getUsers(
        @ApiParam('page', { 
            type: 'integer', 
            description: 'í˜ì´ì§€ ë²ˆí˜¸',
            default: 1,
            minimum: 1
        }) page: number,
        @ApiParam('limit', {
            type: 'integer',
            description: 'í˜ì´ì§€ë‹¹ í•­ëª© ìˆ˜',
            default: 20,
            minimum: 1,
            maximum: 100
        }) limit: number
    ) {
        // êµ¬í˜„ ë¡œì§
    }

    @ApiDoc({
        summary: 'ì‚¬ìš©ì ìƒì„±',
        description: 'ìƒˆë¡œìš´ ì‚¬ìš©ìë¥¼ ìƒì„±í•©ë‹ˆë‹¤.',
        tags: ['Users'],
        requestBody: {
            required: true,
            content: {
                'application/json': {
                    schema: { $ref: '#/components/schemas/CreateUserDto' }
                }
            }
        }
    })
    @ApiResponse(201, { 
        description: 'ìƒì„± ì„±ê³µ',
        schema: { $ref: '#/components/schemas/User' }
    })
    @ApiResponse(400, { description: 'ì˜ëª»ëœ ìš”ì²­' })
    @ApiResponse(409, { description: 'ì´ë©”ì¼ ì¤‘ë³µ' })
    async createUser(body: CreateUserDto) {
        // êµ¬í˜„ ë¡œì§
    }
}

// OpenAPI ìŠ¤í™ ìƒì„±ê¸°
export class OpenAPIGenerator {
    private spec: OpenAPISpec;
    
    constructor(config: OpenAPIConfig) {
        this.spec = {
            openapi: '3.1.0',
            info: config.info,
            servers: config.servers || [],
            paths: {},
            components: {
                schemas: {},
                securitySchemes: config.securitySchemes || {}
            }
        };
    }

    generateFromControllers(controllers: any[]): OpenAPISpec {
        for (const controller of controllers) {
            this.processController(controller);
        }
        
        // AIë¡œ ëˆ„ë½ëœ ë¬¸ì„œ ë³´ì™„
        this.enhanceWithAI();
        
        return this.spec;
    }

    private processController(controller: any) {
        const prototype = controller.prototype;
        const basePath = Reflect.getMetadata('base-path', controller) || '';
        
        Object.getOwnPropertyNames(prototype).forEach(methodName => {
            if (methodName === 'constructor') return;
            
            const method = prototype[methodName];
            const apiDoc = Reflect.getMetadata('api-doc', prototype, methodName);
            
            if (apiDoc) {
                const httpMethod = Reflect.getMetadata('http-method', prototype, methodName);
                const path = basePath + Reflect.getMetadata('path', prototype, methodName);
                
                this.addEndpoint(path, httpMethod, {
                    ...apiDoc,
                    operationId: `${controller.name}.${methodName}`,
                    parameters: this.extractParameters(prototype, methodName),
                    responses: this.extractResponses(prototype, methodName)
                });
            }
        });
    }

    private async enhanceWithAI() {
        const cursor = new CursorAI();
        
        // ìŠ¤í‚¤ë§ˆ ìë™ ìƒì„±
        for (const [name, schema] of Object.entries(this.spec.components.schemas)) {
            if (!schema.description) {
                const prompt = `
ìŠ¤í‚¤ë§ˆ ì´ë¦„: ${name}
ì†ì„±: ${JSON.stringify(schema.properties, null, 2)}

ì´ ìŠ¤í‚¤ë§ˆì— ëŒ€í•œ ì„¤ëª…ì„ ì‘ì„±í•´ì£¼ì„¸ìš”.
ê° ì†ì„±ì˜ ìš©ë„ì™€ ì œì•½ì‚¬í•­ì„ í¬í•¨í•´ì£¼ì„¸ìš”.
`;
                
                const description = await cursor.ai.generateCode(prompt);
                schema.description = description;
            }
        }
        
        // ì˜ˆì œ ìƒì„±
        for (const path of Object.keys(this.spec.paths)) {
            for (const method of Object.keys(this.spec.paths[path])) {
                const endpoint = this.spec.paths[path][method];
                
                if (!endpoint.examples) {
                    endpoint.examples = await this.generateExamples(endpoint);
                }
            }
        }
    }

    private async generateExamples(endpoint: any): Promise<any> {
        const examples = {};
        
        // ìš”ì²­ ì˜ˆì œ
        if (endpoint.requestBody) {
            examples.request = {
                summary: 'ê¸°ë³¸ ìš”ì²­ ì˜ˆì œ',
                value: await this.generateSampleData(endpoint.requestBody.content['application/json'].schema)
            };
        }
        
        // ì‘ë‹µ ì˜ˆì œ
        for (const [status, response] of Object.entries(endpoint.responses)) {
            if (response.content?.['application/json']?.schema) {
                examples[`response_${status}`] = {
                    summary: response.description,
                    value: await this.generateSampleData(response.content['application/json'].schema)
                };
            }
        }
        
        return examples;
    }

    async exportToFile(filepath: string) {
        await fs.writeFile(filepath, JSON.stringify(this.spec, null, 2));
    }

    async exportToHTML(filepath: string) {
        const html = await this.generateSwaggerUI();
        await fs.writeFile(filepath, html);
    }

    private generateSwaggerUI(): string {
        return `
<!DOCTYPE html>
<html lang="ko">
<head>
    <title>${this.spec.info.title} - API Documentation</title>
    <link rel="stylesheet" href="https://unpkg.com/swagger-ui-dist@latest/swagger-ui.css">
    <style>
        body { margin: 0; padding: 0; }
        #swagger-ui { max-width: 1200px; margin: 0 auto; }
    </style>
</head>
<body>
    <div id="swagger-ui"></div>
    <script src="https://unpkg.com/swagger-ui-dist@latest/swagger-ui-bundle.js"></script>
    <script>
        window.onload = () => {
            window.ui = SwaggerUIBundle({
                spec: ${JSON.stringify(this.spec)},
                dom_id: '#swagger-ui',
                deepLinking: true,
                presets: [
                    SwaggerUIBundle.presets.apis,
                    SwaggerUIBundle.SwaggerUIStandalonePreset
                ],
                plugins: [
                    SwaggerUIBundle.plugins.DownloadUrl
                ],
                layout: "StandaloneLayout",
                tryItOutEnabled: true,
                supportedSubmitMethods: ['get', 'post', 'put', 'delete', 'patch'],
                onComplete: () => {
                    console.log('Swagger UI loaded');
                }
            });
        };
    </script>
</body>
</html>
        `;
    }
}
</code></pre>
                    </div>
                </div>
            </section>

            <section class="content-section">
                <h2><i class="fas fa-language"></i> ë‹¤êµ­ì–´ ë¬¸ì„œ ê´€ë¦¬</h2>
                
                <h3>AI ê¸°ë°˜ ë¬¸ì„œ ë²ˆì—­ ì‹œìŠ¤í…œ</h3>
                <div class="translation-system">
                    <div class="translation-implementation">
                        <h4>ê¸°ìˆ  ë¬¸ì„œ ì „ë¬¸ ë²ˆì—­ ì—”ì§„</h4>
                        <pre><code>// i18n/DocumentationTranslator.ts
export class DocumentationTranslator {
    private cursor: CursorAI;
    private translationMemory: Map<string, TranslationEntry>;
    private glossary: TechnicalGlossary;

    constructor() {
        this.cursor = new CursorAI();
        this.translationMemory = new Map();
        this.glossary = new TechnicalGlossary();
    }

    async translateDocumentation(
        docs: Documentation,
        targetLanguages: string[]
    ): Promise<TranslatedDocumentation> {
        const translations: TranslatedDocumentation = {
            original: docs,
            languages: {}
        };

        for (const lang of targetLanguages) {
            console.log(`ğŸŒ ${lang} ë²ˆì—­ ì‹œì‘...`);
            translations.languages[lang] = await this.translateToLanguage(docs, lang);
            console.log(`âœ… ${lang} ë²ˆì—­ ì™„ë£Œ`);
        }

        // ë²ˆì—­ í’ˆì§ˆ ê²€ì¦
        await this.validateTranslations(translations);

        return translations;
    }

    private async translateToLanguage(
        docs: Documentation,
        targetLang: string
    ): Promise<Documentation> {
        // ë¬¸ì„œë¥¼ ì„¹ì…˜ë³„ë¡œ ë¶„í• í•˜ì—¬ ë²ˆì—­
        const translatedDocs = await this.deepTranslate(docs, targetLang);
        
        // ê¸°ìˆ  ìš©ì–´ ì¼ê´€ì„± í™•ì¸
        await this.ensureTerminologyConsistency(translatedDocs, targetLang);
        
        // ì½”ë“œ ë¸”ë¡ê³¼ API ì´ë¦„ ë³´ì¡´ í™•ì¸
        await this.preserveCodeElements(translatedDocs, docs);
        
        return translatedDocs;
    }

    private async deepTranslate(obj: any, targetLang: string): Promise<any> {
        if (typeof obj === 'string') {
            return await this.translateString(obj, targetLang);
        } else if (Array.isArray(obj)) {
            return await Promise.all(obj.map(item => this.deepTranslate(item, targetLang)));
        } else if (typeof obj === 'object' && obj !== null) {
            const translated: any = {};
            for (const [key, value] of Object.entries(obj)) {
                // ì½”ë“œ ê´€ë ¨ í•„ë“œëŠ” ë²ˆì—­í•˜ì§€ ì•ŠìŒ
                if (this.shouldSkipTranslation(key)) {
                    translated[key] = value;
                } else {
                    translated[key] = await this.deepTranslate(value, targetLang);
                }
            }
            return translated;
        }
        return obj;
    }

    private async translateString(text: string, targetLang: string): Promise<string> {
        // ë²ˆì—­ ë©”ëª¨ë¦¬ í™•ì¸
        const cacheKey = `${text.substring(0, 50)}_${targetLang}`;
        if (this.translationMemory.has(cacheKey)) {
            return this.translationMemory.get(cacheKey)!.translation;
        }

        // ì½”ë“œ ë¸”ë¡ ë¶„ë¦¬
        const { plainText, codeBlocks } = this.extractCodeBlocks(text);

        // AI ë²ˆì—­ ìš”ì²­
        const prompt = `
ê¸°ìˆ  ë¬¸ì„œë¥¼ ${targetLang}ë¡œ ë²ˆì—­í•´ì£¼ì„¸ìš”.

ì›ë¬¸:
${plainText}

ë²ˆì—­ ì§€ì¹¨:
1. ê¸°ìˆ  ìš©ì–´ëŠ” ì—…ê³„ í‘œì¤€ ë²ˆì—­ì„ ì‚¬ìš©í•˜ì„¸ìš”
2. ì½”ë“œ, API ì´ë¦„, ë³€ìˆ˜ëª…ì€ ë²ˆì—­í•˜ì§€ ë§ˆì„¸ìš”
3. ìì—°ìŠ¤ëŸ½ê³  ì´í•´í•˜ê¸° ì‰¬ìš´ ë¬¸ì¥ìœ¼ë¡œ ë²ˆì—­í•˜ì„¸ìš”
4. ì›ë¬¸ì˜ ì˜ë¯¸ë¥¼ ì •í™•íˆ ì „ë‹¬í•˜ì„¸ìš”

ìš©ì–´ì§‘:
${this.glossary.getTermsForLanguage(targetLang)}
`;

        const translation = await this.cursor.ai.generateCode(prompt);
        
        // ì½”ë“œ ë¸”ë¡ ë³µì›
        const finalTranslation = this.restoreCodeBlocks(translation, codeBlocks);
        
        // ë²ˆì—­ ë©”ëª¨ë¦¬ì— ì €ì¥
        this.translationMemory.set(cacheKey, {
            original: text,
            translation: finalTranslation,
            language: targetLang,
            timestamp: new Date()
        });

        return finalTranslation;
    }

    private extractCodeBlocks(text: string): { plainText: string, codeBlocks: string[] } {
        const codeBlocks: string[] = [];
        let plainText = text;
        
        // ì½”ë“œ ë¸”ë¡ ì¶”ì¶œ (```...```)
        plainText = plainText.replace(/```[\s\S]*?```/g, (match) => {
            codeBlocks.push(match);
            return `__CODE_BLOCK_${codeBlocks.length - 1}__`;
        });
        
        // ì¸ë¼ì¸ ì½”ë“œ ì¶”ì¶œ (`...`)
        plainText = plainText.replace(/`[^`]+`/g, (match) => {
            codeBlocks.push(match);
            return `__CODE_BLOCK_${codeBlocks.length - 1}__`;
        });
        
        return { plainText, codeBlocks };
    }

    private restoreCodeBlocks(text: string, codeBlocks: string[]): string {
        return text.replace(/__CODE_BLOCK_(\d+)__/g, (match, index) => {
            return codeBlocks[parseInt(index)];
        });
    }

    private async validateTranslations(translations: TranslatedDocumentation) {
        const validationReport = {
            issues: [],
            warnings: [],
            statistics: {}
        };

        for (const [lang, docs] of Object.entries(translations.languages)) {
            // ë²ˆì—­ ì™„ì„±ë„ í™•ì¸
            const completeness = await this.checkCompleteness(docs, translations.original);
            
            // ìš©ì–´ ì¼ê´€ì„± í™•ì¸
            const consistency = await this.checkTerminologyConsistency(docs, lang);
            
            // í˜•ì‹ ë³´ì¡´ í™•ì¸
            const formatting = await this.checkFormattingPreservation(docs, translations.original);
            
            validationReport.statistics[lang] = {
                completeness,
                consistency,
                formatting
            };
        }

        return validationReport;
    }

    async generateTranslationReport(): Promise<TranslationReport> {
        const report: TranslationReport = {
            summary: {
                totalStrings: this.translationMemory.size,
                languages: this.getTranslatedLanguages(),
                lastUpdated: new Date()
            },
            coverage: {},
            quality: {},
            suggestions: []
        };

        // ê° ì–¸ì–´ë³„ ì»¤ë²„ë¦¬ì§€ ê³„ì‚°
        for (const lang of report.summary.languages) {
            report.coverage[lang] = this.calculateCoverage(lang);
            report.quality[lang] = await this.assessQuality(lang);
        }

        // ê°œì„  ì œì•ˆ ìƒì„±
        report.suggestions = await this.generateImprovementSuggestions(report);

        return report;
    }
}

// ê¸°ìˆ  ìš©ì–´ì§‘ ê´€ë¦¬
export class TechnicalGlossary {
    private terms: Map<string, TermEntry>;

    constructor() {
        this.terms = new Map();
        this.loadDefaultTerms();
    }

    private loadDefaultTerms() {
        // ê¸°ë³¸ ê¸°ìˆ  ìš©ì–´ ë¡œë“œ
        this.addTerm('API', {
            en: 'API',
            ko: 'API',
            ja: 'API',
            zh: 'API',
            description: 'Application Programming Interface'
        });

        this.addTerm('authentication', {
            en: 'authentication',
            ko: 'ì¸ì¦',
            ja: 'èªè¨¼',
            zh: 'èº«ä»½éªŒè¯',
            description: 'Process of verifying identity'
        });

        // ... ë” ë§ì€ ìš©ì–´
    }

    addTerm(key: string, translations: TermEntry) {
        this.terms.set(key.toLowerCase(), translations);
    }

    getTermsForLanguage(lang: string): string {
        const termsList = [];
        for (const [key, entry] of this.terms) {
            if (entry[lang]) {
                termsList.push(`${key}: ${entry[lang]}`);
            }
        }
        return termsList.join('\n');
    }

    async suggestNewTerms(text: string): Promise<string[]> {
        // AIë¥¼ ì‚¬ìš©í•˜ì—¬ ë²ˆì—­ì´ í•„ìš”í•œ ìƒˆë¡œìš´ ê¸°ìˆ  ìš©ì–´ ì¶”ì¶œ
        const cursor = new CursorAI();
        const prompt = `
ë‹¤ìŒ í…ìŠ¤íŠ¸ì—ì„œ ê¸°ìˆ  ìš©ì–´ë¥¼ ì¶”ì¶œí•´ì£¼ì„¸ìš”:

${text}

ìš©ì–´ì§‘ì— ì—†ëŠ” ìƒˆë¡œìš´ ê¸°ìˆ  ìš©ì–´ë§Œ ì¶”ì¶œí•˜ì„¸ìš”.
`;
        
        const suggestions = await cursor.ai.generateCode(prompt);
        return JSON.parse(suggestions);
    }
}

// ë¬¸ì„œ ë²„ì „ ê´€ë¦¬
export class DocumentationVersionControl {
    private versions: Map<string, DocumentVersion>;
    private currentVersion: string;

    constructor() {
        this.versions = new Map();
        this.currentVersion = '1.0.0';
    }

    async createVersion(docs: Documentation, version: string, changelog: string) {
        const docVersion: DocumentVersion = {
            version,
            docs,
            changelog,
            createdAt: new Date(),
            deprecated: false
        };

        this.versions.set(version, docVersion);
        this.currentVersion = version;

        // ì´ì „ ë²„ì „ê³¼ì˜ ì°¨ì´ì  ë¶„ì„
        const diff = await this.analyzeDifferences(version);
        docVersion.diff = diff;
    }

    async analyzeDifferences(version: string): Promise<VersionDiff> {
        const previous = this.getPreviousVersion(version);
        if (!previous) return null;

        const cursor = new CursorAI();
        const prompt = `
ë‘ ë¬¸ì„œ ë²„ì „ ê°„ì˜ ì£¼ìš” ë³€ê²½ì‚¬í•­ì„ ë¶„ì„í•´ì£¼ì„¸ìš”:

ì´ì „ ë²„ì „: ${previous.version}
í˜„ì¬ ë²„ì „: ${version}

ë‹¤ìŒì„ í¬í•¨í•´ì£¼ì„¸ìš”:
1. ì¶”ê°€ëœ API ì—”ë“œí¬ì¸íŠ¸
2. ë³€ê²½ëœ API ì‹œê·¸ë‹ˆì²˜
3. ì‚­ì œëœ ê¸°ëŠ¥
4. ì£¼ìš” ë™ì‘ ë³€ê²½ì‚¬í•­
5. ë§ˆì´ê·¸ë ˆì´ì…˜ ê°€ì´ë“œ
`;

        const analysis = await cursor.ai.generateCode(prompt);
        return JSON.parse(analysis);
    }

    generateMigrationGuide(fromVersion: string, toVersion: string): string {
        const diff = this.versions.get(toVersion)?.diff;
        if (!diff) return '';

        return `
# ${fromVersion}ì—ì„œ ${toVersion}ë¡œ ë§ˆì´ê·¸ë ˆì´ì…˜ ê°€ì´ë“œ

## ì£¼ìš” ë³€ê²½ì‚¬í•­
${diff.majorChanges.map(change => `- ${change}`).join('\n')}

## API ë³€ê²½ì‚¬í•­
${diff.apiChanges.map(change => `
### ${change.endpoint}
- ë³€ê²½ ë‚´ìš©: ${change.description}
- ì´ì „: \`${change.before}\`
- ì´í›„: \`${change.after}\`
`).join('\n')}

## ë§ˆì´ê·¸ë ˆì´ì…˜ ë‹¨ê³„
${diff.migrationSteps.map((step, index) => `
${index + 1}. ${step.description}
   \`\`\`${step.language}
   ${step.code}
   \`\`\`
`).join('\n')}
`;
    }
}
</code></pre>
                    </div>
                </div>
            </section>

            <section class="practice-section">
                <h2><i class="fas fa-laptop-code"></i> ì‹¤ìŠµ: í”„ë¡œì íŠ¸ ë¬¸ì„œ ìë™í™”</h2>
                
                <div class="exercise">
                    <h3>ê³¼ì œ: ì™„ì „ ìë™í™”ëœ ë¬¸ì„œ ì‹œìŠ¤í…œ êµ¬ì¶•</h3>
                    <p>ë‹¤ìŒ ìš”êµ¬ì‚¬í•­ì„ ë§Œì¡±í•˜ëŠ” ë¬¸ì„œ ìë™í™” ì‹œìŠ¤í…œì„ êµ¬ì¶•í•˜ì„¸ìš”:</p>
                    
                    <div class="requirements">
                        <h4>ìš”êµ¬ì‚¬í•­:</h4>
                        <ul>
                            <li>ì½”ë“œ ë³€ê²½ ì‹œ ìë™ìœ¼ë¡œ ë¬¸ì„œ ì—…ë°ì´íŠ¸</li>
                            <li>OpenAPI 3.0 ìŠ¤í™ ìë™ ìƒì„±</li>
                            <li>ì¸í„°ë™í‹°ë¸Œ API í”Œë ˆì´ê·¸ë¼ìš´ë“œ ì œê³µ</li>
                            <li>í•œêµ­ì–´, ì˜ì–´, ì¼ë³¸ì–´ 3ê°œ ì–¸ì–´ ì§€ì›</li>
                            <li>ë²„ì „ë³„ ë¬¸ì„œ ê´€ë¦¬ì™€ ë§ˆì´ê·¸ë ˆì´ì…˜ ê°€ì´ë“œ</li>
                            <li>ê²€ìƒ‰ ê°€ëŠ¥í•œ ë¬¸ì„œ ì‚¬ì´íŠ¸ ìƒì„±</li>
                        </ul>
                    </div>

                    <div class="hints">
                        <h4>íŒíŠ¸:</h4>
                        <ul>
                            <li>TypeScriptì˜ íƒ€ì… ì •ë³´ë¥¼ ìµœëŒ€í•œ í™œìš©</li>
                            <li>ë°ì½”ë ˆì´í„°ë¡œ ë¬¸ì„œ ë©”íƒ€ë°ì´í„° ìˆ˜ì§‘</li>
                            <li>Docusaurusë‚˜ VuePress ê°™ì€ ì •ì  ì‚¬ì´íŠ¸ ìƒì„±ê¸° í™œìš©</li>
                            <li>GitHub Actionsë¡œ ë¬¸ì„œ ë°°í¬ ìë™í™”</li>
                        </ul>
                    </div>
                </div>
            </section>

            <section class="summary-section">
                <h2><i class="fas fa-bookmark"></i> í•µì‹¬ ìš”ì•½</h2>
                <div class="summary-grid">
                    <div class="summary-item">
                        <h3>ìë™ ë¬¸ì„œ ìƒì„±</h3>
                        <ul>
                            <li>ì½”ë“œ ë¶„ì„ ê¸°ë°˜ ë¬¸ì„œí™”</li>
                            <li>AI ë³´ê°• ë¬¸ì„œ ì‘ì„±</li>
                            <li>ì‹¤ì‹œê°„ ë™ê¸°í™”</li>
                        </ul>
                    </div>
                    <div class="summary-item">
                        <h3>API ëª…ì„¸</h3>
                        <ul>
                            <li>OpenAPI ìë™ ìƒì„±</li>
                            <li>ì¸í„°ë™í‹°ë¸Œ í…ŒìŠ¤íŠ¸</li>
                            <li>ë‹¤ì–‘í•œ í˜•ì‹ ì§€ì›</li>
                        </ul>
                    </div>
                    <div class="summary-item">
                        <h3>ë‹¤êµ­ì–´ ì§€ì›</h3>
                        <ul>
                            <li>AI ê¸°ë°˜ ë²ˆì—­</li>
                            <li>ìš©ì–´ ì¼ê´€ì„± ìœ ì§€</li>
                            <li>ë¬¸í™”ë³„ ìµœì í™”</li>
                        </ul>
                    </div>
                    <div class="summary-item">
                        <h3>ë¬¸ì„œ ê´€ë¦¬</h3>
                        <ul>
                            <li>ë²„ì „ ê´€ë¦¬</li>
                            <li>ë³€ê²½ ì´ë ¥ ì¶”ì </li>
                            <li>ë§ˆì´ê·¸ë ˆì´ì…˜ ê°€ì´ë“œ</li>
                        </ul>
                    </div>
                </div>
            </section>
        </main>

        <aside class="sidebar">
            <div class="progress-indicator">
                <h3>ì§„í–‰ ìƒí™©</h3>
                <div class="progress-bar">
                    <div class="progress-fill" style="width: 80%;"></div>
                </div>
                <span>24/30 ê°•ì˜ (80%)</span>
            </div>

            <nav class="lesson-nav-sidebar">
                <h3>ì „ì²´ ê°•ì˜</h3>
                <ul>
                    <li><a href="lesson22.html">ì œ22ê°•: ì»¤ìŠ¤í…€ ëª…ë ¹ì–´ ê°œë°œ</a></li>
                    <li><a href="lesson23.html">ì œ23ê°•: AI ì½”ë“œ ë¦¬ë·°</a></li>
                    <li class="current">ì œ24ê°•: ë¬¸ì„œí™” ìë™í™”</li>
                    <li><a href="lesson25.html">ì œ25ê°•: ë§ˆì´ê·¸ë ˆì´ì…˜ ë„êµ¬</a></li>
                    <li><a href="lesson26.html">ì œ26ê°•: ì„±ëŠ¥ í”„ë¡œíŒŒì¼ë§</a></li>
                </ul>
            </nav>

            <div class="study-tips">
                <h3>í•™ìŠµ íŒ</h3>
                <ul>
                    <li>ì¢‹ì€ ë¬¸ì„œëŠ” ì½”ë“œë§Œí¼ ì¤‘ìš”í•œ ìì‚°ì…ë‹ˆë‹¤</li>
                    <li>ë¬¸ì„œë„ ì½”ë“œì²˜ëŸ¼ ë²„ì „ ê´€ë¦¬ì™€ ë¦¬ë·°ê°€ í•„ìš”í•©ë‹ˆë‹¤</li>
                    <li>ì‚¬ìš©ì í”¼ë“œë°±ì„ ë°˜ì˜í•˜ì—¬ ë¬¸ì„œë¥¼ ì§€ì†ì ìœ¼ë¡œ ê°œì„ í•˜ì„¸ìš”</li>
                    <li>ì˜ˆì œ ì½”ë“œëŠ” í•­ìƒ ì‹¤í–‰ ê°€ëŠ¥í•œ ìƒíƒœë¡œ ìœ ì§€í•˜ì„¸ìš”</li>
                </ul>
            </div>
        </aside>
    </div>

    <script src="../assets/lesson-script.js"></script>
</body>
</html>